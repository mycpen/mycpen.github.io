{"meta":{"title":"Mycpen","subtitle":"个人博客","description":"个人博客","author":"Mycpen","url":"https://blog1.cpen.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2023-01-01T04:00:00.000Z","updated":"2023-01-01T05:00:00.000Z","comments":false,"path":"/404.html","permalink":"https://blog1.cpen.top/404.html","excerpt":"","text":"回到主页"},{"title":"关于","date":"2023-01-01T04:00:00.000Z","updated":"2023-01-01T05:00:00.000Z","comments":false,"path":"about/index.html","permalink":"https://blog1.cpen.top/about/","excerpt":"","text":"博客 使用 Hexo 静态框架，基于 Pure 主题搭建 部分图片源于网络，侵删 文章采用 CC BY-NC-SA 4.0 协议，转载请注明出处"},{"title":"分类","date":"2023-01-01T04:00:00.000Z","updated":"2023-01-01T05:00:00.000Z","comments":false,"path":"categories/index.html","permalink":"https://blog1.cpen.top/categories/","excerpt":"","text":""},{"title":"相册","date":"2023-01-01T04:00:00.000Z","updated":"2023-01-01T05:00:00.000Z","comments":false,"path":"gallery/index.html","permalink":"https://blog1.cpen.top/gallery/","excerpt":"","text":""},{"title":"","date":"2026-02-27T22:17:45.594Z","updated":"2026-02-27T22:17:45.594Z","comments":true,"path":"js/hexo_resize_image.js","permalink":"https://blog1.cpen.top/js/hexo_resize_image.js","excerpt":"","text":"function set_image_size(image, width, height) { image.setAttribute(\"width\", width + \"px\"); image.setAttribute(\"height\", height + \"px\"); } function hexo_resize_image() { var imgs = document.getElementsByTagName('img'); for (var i = imgs.length - 1; i >= 0; i--) { var img = imgs[i]; var src = img.getAttribute('src').toString(); var fields = src.match(/(? 0) { height = n_height*width/n_width; } if (height.length > 0) { width = n_width*height/n_height; } } set_image_size(img, width, height); } continue; } fields = src.match(/(?"},{"title":"友情链接","date":"2023-01-01T04:00:00.000Z","updated":"2023-01-01T05:00:00.000Z","comments":true,"path":"links/index.html","permalink":"https://blog1.cpen.top/links/","excerpt":"","text":""},{"title":"项目","date":"2023-01-01T04:00:00.000Z","updated":"2023-01-01T05:00:00.000Z","comments":false,"path":"repository/index.html","permalink":"https://blog1.cpen.top/repository/","excerpt":"","text":""},{"title":"资源","date":"2023-01-01T04:00:00.000Z","updated":"2023-01-01T05:00:00.000Z","comments":false,"path":"resources/index.html","permalink":"https://blog1.cpen.top/resources/","excerpt":"","text":""},{"title":"标签","date":"2023-01-01T04:00:00.000Z","updated":"2023-01-01T05:00:00.000Z","comments":false,"path":"tags/index.html","permalink":"https://blog1.cpen.top/tags/","excerpt":"","text":""}],"posts":[{"title":"13_Hexo-操作记录","slug":"Hexo/13_Hexo-操作记录","date":"2023-06-01T04:00:00.000Z","updated":"2023-06-01T05:00:00.000Z","comments":true,"path":"posts/db7b8b04.html","permalink":"https://blog1.cpen.top/posts/db7b8b04.html","excerpt":"","text":"01. Giscus 评论系统 博客弃用 Twikoo，改用 Giscus 进行评论 参考 butterfly Nick Xu 网址：https://giscus.app/zh-CN Discussion 分类选择 General Discussion 分类选择 Announcements，填写信息后获取 repo_id、category_id 需注意 Giscus 不支持最新评论，详见 butterfly 引入的 cdn 资源为 https://giscus.app/client.js ，暂未找到第三方 npm cdn。可自建 Giscus，参考 xaoxuu 示例 123456789101112131415# Giscus# https://giscus.app/giscus: repo: xx/xx repo_id: xx category_id: xx theme: light: light dark: dark option: data-category: Announcements data-input-position: top data-lang: zh-CN data-loading: lazy 其它参考 自建 Giscus，未使用 xaoxuu https://github.com/eallion/eallion.com/discussions https://github.com/xaoxuu/blog-comments/discussions","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"}]},{"title":"12_Hexo-GitHub Actions 发布博客静态资源至 NPM","slug":"Hexo/12_Hexo-GitHubActions发布静态资源至NPM","date":"2023-05-05T04:00:00.000Z","updated":"2023-05-05T05:00:00.000Z","comments":true,"path":"posts/8d01af11.html","permalink":"https://blog1.cpen.top/posts/8d01af11.html","excerpt":"","text":"前言 将博客静态文件上传至 github，通过 github action 自动发包至 npm，使用 npmmirror cdn npm 命令 网址: https://www.npmjs.com/ 切换源 12345# https://blog.anheyu.com/posts/sdxhu.html#npm-镜像npm config set registry http://registry.npmmirror.com# 切回源npm config set registry https://registry.npmjs.org/ 添加本地 npm 用户 1234# 仅第一次使用需要添加用户，之后会提示你输入你的npm账号密码以及注册邮箱npm adduser# 非第一次使用直接登录即可，之后会提示你输入你的npm账号密码以及注册邮箱npm login 初始化 1npm init 发布 1npm publish 生成 npm token npm 官网 =&gt; 头像 =&gt; Access Tokens =&gt; Generate New Token =&gt; 勾选 Automation github 仓库新增 NPM_TOKEN 的 secrets 示例 package.json scripts/generate_package_json.js，生成 public/package.json 1234567891011121314151617181920212223242526272829303132// 生成 public/.package.json// https://blog.anheyu.com/posts/72ea.htmlhexo.extend.generator.register(&#x27;npmpackagejson&#x27;, function(locals)&#123;// Objectreturn &#123;path: &#x27;/package.json&#x27;,data: `&#123; &quot;name&quot;: &quot;mycpen-blog&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;description&quot;: &quot;mycpen blog static file&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;directories&quot;: &#123; &quot;lib&quot;: &quot;lib&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\\\&quot;Error: no test specified\\\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/mycpen/blog.git&quot; &#125;, &quot;author&quot;: &quot;mycpen&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;bugs&quot;: &#123; &quot;url&quot;: &quot;https://github.com/mycpen/blog/issues&quot; &#125;, &quot;homepage&quot;: &quot;https://github.com/mycpen/blog#readme&quot;&#125;`&#125;;&#125;); npm push scripts/npmpublish.js，生成 public/.github/workflows/autopublish.yml 123456789101112131415161718192021222324252627282930313233343536373839// 生成 public/.github/workflows/autopublish.yml// 推送静态资源至 npm// https://akilar.top/posts/e82444a6/#具体操作步骤hexo.extend.generator.register(&#x27;npmpush&#x27;, function(locals)&#123; // Object return &#123; path: &#x27;/.github/workflows/autopublish.yml&#x27;, data: `name: Node.js Package# 监测分支，2020年10月后github新建仓库默认分支改为main，记得更改on: push: branches: - mainjobs: publish-npm: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: actions/setup-node@v1 with: node-version: &quot;18.x&quot; registry-url: https://registry.npmjs.org/ - run: npm publish env: NODE_AUTH_TOKEN: `+ &#x27;$&#123;&#123;secrets.npm_token&#125;&#125;&#x27; + ` - name: Wait for 3 minutes run: sleep 180 # 等待 3 分钟，单位为秒 - name: Sync package from npm to npmmirror run: | npm install -g cnpm --registry=https://registry.npmmirror.com cnpm sync mycpen-blog`&#125;;&#125;); .npmignore scripts/npmignore.js，生成 public/.npmignore。目的 不提交 .html 这类文件至 npm 12345678910111213141516// 生成 public/.npmignore// https://akilar.top/posts/e82444a6/hexo.extend.generator.register(&#x27;npmignore&#x27;, function(locals)&#123;// Objectreturn &#123;path: &#x27;/.npmignore&#x27;,data: `**/*.html.github/download/ads.txtCNAMErobots.txt`&#125;;&#125;); change version .github/replace-localfile-url.py，修改 public/package.json version 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/usr/bin/python# -*- coding: UTF-8 -*-# 源码参考 https://blog.csdn.net/qq_38150250/article/details/118026219import osimport refrom datetime import datetimeimport requestsimport random# 文件查找 find . -name file_name -type f# 查找函数：search_path 查找根路径 # 获取文章路径def search(search_path, search_result, search_fileType_list): # 获取当前路径下地所有文件 all_file = os.listdir(search_path) # 对于每一个文件 for each_file in all_file: # 若文件为一个文件夹 if os.path.isdir(search_path + each_file): # 递归查找 search(search_path + each_file + &#x27;/&#x27;, search_result, search_fileType_list) # 如果是需要被查找的文件 else: for i in search_fileType_list: if re.findall(f&#x27;.*\\\\&#123;i&#125;$&#x27;, each_file) == [each_file]: search_result.append(search_path + each_file)# 替换 sed -i &#x27;s/old_str/new_str/&#x27;# 文本替换 replace_file_name 需要替换的文件路径，replace_old_str 要替换的字符，replace_new_str 替换的字符def replace(replace_file_name, replace_old_str, replace_new_str): with open(replace_file_name, &quot;r&quot;, encoding = &quot;UTF-8&quot;) as f1: content = f1.read() f1.close() t = content.replace(replace_old_str, replace_new_str) with open(replace_file_name, &quot;w&quot;, encoding = &quot;UTF-8&quot;) as f2: f2.write(t) f2.close()# ==================================================================# npm time version | npm_converted_time# ------------------------------------------------------------------# 将数字和字母对应关系定义为字典npm_num_mapping = &#123; &#x27;0&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;u&#x27;], &#x27;1&#x27;: [&#x27;c&#x27;, &#x27;d&#x27;, &#x27;v&#x27;], &#x27;2&#x27;: [&#x27;e&#x27;, &#x27;f&#x27;, &#x27;w&#x27;], &#x27;3&#x27;: [&#x27;g&#x27;, &#x27;h&#x27;, &#x27;x&#x27;], &#x27;4&#x27;: [&#x27;i&#x27;, &#x27;j&#x27;, &#x27;y&#x27;], &#x27;5&#x27;: [&#x27;k&#x27;, &#x27;l&#x27;, &#x27;z&#x27;], &#x27;6&#x27;: [&#x27;m&#x27;, &#x27;n&#x27;], &#x27;7&#x27;: [&#x27;o&#x27;, &#x27;p&#x27;], &#x27;8&#x27;: [&#x27;q&#x27;, &#x27;r&#x27;], &#x27;9&#x27;: [&#x27;s&#x27;, &#x27;t&#x27;]&#125;# 当前时间npm_now = datetime.now()# 格式化当前时间为指定格式 2403230741npm_formatted_time = npm_now.strftime(&quot;%y%m%d%H%M&quot;)# 数字替换为随机映射字母 ejugfhupjvnpm_converted_time = &#x27;&#x27;for char in npm_formatted_time: if char.isdigit(): npm_converted_time += &#x27;&#x27;.join(random.choice(npm_num_mapping[char]) if char in npm_num_mapping else char) else: npm_converted_time += char# 替换 package.json 0.0.0result_npmPackageJson = [&#x27;./public/package.json&#x27;]old_npmPackageJson_version = &#x27;0.0.0&#x27;new_npmPackageJson_version = f&#x27;0.0.0-&#123;npm_converted_time&#125;&#x27;count = 0# jsonfor file_name in result_npmPackageJson: replace(file_name, old_npmPackageJson_version, new_npmPackageJson_version) count += 1 print(&quot;&#123;&#125; done &#123;&#125;&quot;.format(file_name, count)) .github/workflows/autodeploy.yml，执行上方 py 脚本 - name: Replace localFile URL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103name: Auto deploy# 当有改动推送到master分支时，启动Actionon: workflow_dispatch: push: branches: - mainjobs: deploy: runs-on: ubuntu-latest steps: - name: 检查分支 uses: actions/checkout@v2 with: ref: main - uses: szenius/set-timezone@v1.0 # 设置执行环境的时区 with: timezoneLinux: &quot;Asia/Shanghai&quot; - name: 安装 Node uses: actions/setup-node@v1 with: node-version: &quot;18.x&quot; - name: 安装 Hexo run: | export TZ=&#x27;Asia/Shanghai&#x27; npm install hexo-cli -g - name: 缓存 Hexo uses: actions/cache@v4 id: cache with: path: node_modules key: $&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125; - name: 安装依赖 if: steps.cache.outputs.cache-hit != &#x27;true&#x27; run: | npm install gulp-cli -g #全局安装gulp npm install --save - name: Generate static file run: | hexo clean ; hexo generate ; gulp - name: Set up Python 3.10 uses: actions/setup-python@v3 with: python-version: &quot;3.10&quot; - name: Install dependencies run: | python -m pip install --upgrade pip pip install requests - name: Replace imageBed URL run: | python .github/replace-imgbed-url-v2.py - name: Replace localFile URL run: | python .github/replace-localfile-url.py - name: Delete static file repository tags run: | mkdir tmp_mycpen cd tmp_mycpen git clone https://github.com/mycpen/blog.git cd blog git push --force --quiet &quot;https://mycpen:$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@github.com/mycpen/blog.git&quot; --delete $(git tag -l) cd ../.. rm -rf tmp_mycpen - name: Deploy static file run: | cd ./public git init git config --global user.email &#x27;github-actions[bot]@users.noreply.github.com&#x27; git config --global user.name &#x27;github-actions[bot]&#x27; git add . git commit -m &quot;$(date +&#x27;%Y/%m/%d&#x27;)&quot; tag_name=$(date +&#x27;%y.%m.%d&#x27;) git tag $tag_name git push --force --quiet &quot;https://mycpen:$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@github.com/mycpen/blog.git&quot; $tag_name git push --force --quiet &quot;https://mycpen:$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@github.com/mycpen/blog.git&quot; master:main - name: Purge JSD cache run: | jsd_purge_urls=(&quot;https://purge.jsdelivr.net/gh/mycpen/blog/&quot; &quot;https://purge.jsdelivr.net/gh/mycpen/blog@latest/&quot; &quot;https://purge.jsdelivr.net/gh/mycpen/blog@main/&quot;) for url in &quot;$&#123;jsd_purge_urls[@]&#125;&quot;; do curl -s $url; done - name: 推送百度 url run: | hexo deploy - name: Delete workflow runs uses: Mattraks/delete-workflow-runs@v2 with: token: $&#123;&#123; secrets.GH_TOKEN &#125;&#125; repository: $&#123;&#123; github.repository &#125;&#125; retain_days: 30 keep_minimum_runs: 6 参考 akilar | github-action推送博客部署仓库至NPM akilar | npm图床 安知鱼 | hexo博客工作流CI 安知鱼 | npm图床 EtherDream | 文件一键上传到 NPM npmmirror | 同步模块 cnpm sync cnpmcore github | CyanBlog/pkgpublish.js","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://blog1.cpen.top/tags/GitHub/"},{"name":"NPM","slug":"NPM","permalink":"https://blog1.cpen.top/tags/NPM/"}]},{"title":"06_转载-自我提升的8个好习惯","slug":"转载/06_转载-自我提升的8个好习惯","date":"2023-05-04T04:00:00.000Z","updated":"2023-05-04T05:00:00.000Z","comments":true,"path":"posts/85a8374a.html","permalink":"https://blog1.cpen.top/posts/85a8374a.html","excerpt":"","text":"原文：https://blog.zhuxu.xyz/archives/343/ 自我提升的8个好习惯 学习新技能 学会和自己比较 培养一个兴趣爱好 每天早起半小时 不过度透支自己 反省自己 保持阅读 保持好的心态 1. 学习新技能 很多人其实不敢承认，自己害怕接受新事物、学习新技能。不是因为畏惧艰难，而是不想改变旧有的思考方式。 然而这个时代变化飞快，唯有不断提升自己，才能跟上时代的步伐。时间对每个人都是公平的，日日精进不懈怠，才能遇见更好的自己。 2. 学会和自己比较 这个世界上，有多少人就有多少种生活方式、多少种人生目标。不要拿别人的长处，否定自己的短处，也不要羡慕别人拥有的，放大自己没有的，更不要在比较中迷失自我，忽略自己的幸福。 人各有各的活法，没什么好比较的，当你想明白这一点，自然就能静下心来。 3. 培养一个兴趣爱好 人若有自己的兴趣爱好，生活会呈现出另一番景象。悲伤失落时，投入到兴趣中，情绪就有了排解的出口。烦躁不安时，做点喜欢的事，也会忘记烦恼、渐渐开心起来。 一旦有了精神食粮，你会变得越来越欣赏自己，身体自然也会充满无限力量。 4. 每天早起半小时 经常听到有人说，想要自律，但不知道从何做起。那你可以尝试从每天早起30分钟开始。 早起，意味着你有比别人更充足的时间，去准备一天的工作和生活。更重要的是，早起会让你拥有人生的掌控感，找到自己生活的节奏。早起看似是一件微不足道的小事，但在日复一日的坚持后，你会发现人生已悄然改变。 5. 不过度透支自己 很多人往往意识不到健康的重要性，总以为自己是金刚不坏之身，于是通宵熬夜、暴饮暴食，肆无忌惮地透支身体。时间久了，生活将不得不按下暂停键，用来弥补这些毫无节制的消耗。 按时吃饭、早睡早起、坚持运动，只有对自己的身体好，身体才会给你更好的回馈。只有拥有了健康，你才能去创造更精彩的人生。 6. 反省自己 一个人的优秀，离不开不断的复盘和总结。每天睡觉前，可以花15分钟对这一天的经历做个简单的复盘和总结。 哪些地方没有做好，哪些地方还可以做得更好……在这个过程中，及时总结经验、改正错误，才能在人生的道路上行稳致远。 7. 保持阅读 阅读对一个人的重要性，不只在于习得新知识，更在于它能帮助我们保持深度思考的能力，继而获得更快的成长。 有空时，记得多读书。读书是为自己的心注入更多光亮的过程。我们所读过的每一本书，都将引领我们走向更美好的明天。 8. 保持好的心态 我们在生活中常常要去面对各种未知、困境和麻烦，心态不好的人会觉得这是一场磨难，而心态好的人则会把它当成一场历练。 很多时候，心态决定了人生的状态。我们不能决定生活中会发生什么，但可以决定自己以什么样的心态应对。 保持良好的心态，才能拥有美好的未来。 来源：十点读书 | 作者：小嗲 | 主播：赵文龙","categories":[{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"习惯","slug":"习惯","permalink":"https://blog1.cpen.top/tags/%E4%B9%A0%E6%83%AF/"}]},{"title":"05_转载-延寿指南-反向面试-文档写作规范","slug":"转载/05_转载-GitHub-延寿指南-反向面试","date":"2023-05-03T04:00:00.000Z","updated":"2023-05-03T05:00:00.000Z","comments":true,"path":"posts/285c50ae.html","permalink":"https://blog1.cpen.top/posts/285c50ae.html","excerpt":"","text":"程序员延寿指南 原文：https://github.com/geekan/HowToLiveLonger issue：https://github.com/geekan/HowToLiveLonger/issues/143 最佳操作包括： 饮食方面：多吃蔬果和白肉，少吃蛋黄和超加工食物；中量碳水、多吃植物蛋白；多吃辣和坚果；少喝或不喝甜味饮料，喝咖啡、茶和牛奶；戒酒或每周饮酒量不超过100g。 运动方面：每周进行3次45分钟的挥拍运动。 日常生活方面：每天刷牙，睡眠时间为7小时，最好在22-24点间睡觉。 其他方面：保持健康体重，不吸烟，晒太阳，服用二甲双胍、复合维生素、亚精胺和葡萄糖胺等药物。 以上操作可以降低全因死亡率，增加预期寿命，从而稳健地活得更久。但是需要注意，各个变量之间并不符合独立同分布假设，变量之间的实际影响也并不明确，因此需要谨慎实践。 反向面试 原文：https://github.com/yifeikong/reverse-interview-zh 预期使用方式 检查一下哪些问题你感兴趣 检查一下哪些是你可以自己在网上找到答案的 找不到的话就向面试官提问 绝对不要想把这个列表里的每个问题都问一遍。（尊重面试官的时间，而且你可以通过查找已经发布的答案来显示 你的主动性） 请记住事情总是灵活的，组织的结构调整也会经常发生。拥有一个 bug 追踪系统并不会保证高效处理 bug。 CI/CD （持续集成系统） 也不一定保证交付时间会很短。 职责 On-call （电话值班）的计划或者规定是什么？值班或者遇到问题加班时候有加班费吗？ 我的日常工作是什么？ 有给我设定的特定目标吗？ 团队里面初级和高级工程师的比例是多少？（有计划改变吗） 入职培训 (onboarding) 会是什么样的？ 每个开发者有多大的自由来做出决定？ 在你看来，这个工作做到什么程度算成功？ 你期望我在最初的一个月 / 三个月能够完成什么？ 试用期结束的时候，你会怎么样衡量我的绩效？ 自己单独的开发活动和按部就班工作的比例大概是怎样的？ 一个典型的一天或者一周的工作是怎样安排的？ 对我的申请你有什么疑虑么？ 在这份工作上，我将会和谁紧密合作？ 我的直接上级他们的上级都是什么样的管理风格？（事无巨细还是着眼宏观） 我在这个岗位上应该如何发展？会有哪些机会？ 每天预期 / 核心工作时间是多少小时？ 我入职的岗位是新增还是接替之前离职的同事？（是否有技术债需要还）？(zh) 入职之后在哪个项目组，项目是新成立还是已有的？(zh) 技术 公司常用的技术栈是什么？ 你们怎么使用源码控制系统？ 你们怎么测试代码？ 你们怎么追踪 bug? 你们怎样监控项目？ 你们怎么集成和部署代码改动？是使用持续集成和持续部署吗 (CI/CD)？ 你们的基础设施搭建在版本管理系统里吗？或者是代码化的吗？ 从计划到完成一项任务的工作流是什么样的？ 你们如何准备故障恢复？ 有标准的开发环境吗？是强制的吗？ 你们需要花费多长时间来给产品搭建一个本地测试环境？（分钟 / 小时 / 天） 你们需要花费多长时间来响应代码或者依赖中的安全问题？ 所有的开发者都可以使用他们电脑的本地管理员权限吗？ 介绍一下你们的技术原则或者展望。 你们的代码有开发文档吗？有没有单独的供消费者阅读的文档？ 你们有更高层次的文档吗？比如说 ER 图，数据库范式 你们使用静态代码分析吗？ 你们如何管理内部和外部的数字资产？ 你们如何管理依赖？ 公司是否有技术分享交流活动？有的话，多久一次呢？(zh) 你们的数据库是怎么进行版本控制的？(zh) 业务需求有没有文档记录？是如何记录的？(zh) 团队 工作是怎么组织的？ 团队内 / 团队间的交流通常是怎样的？ 你们使用什么工具来做项目组织？你的实际体会是什么？ 如果遇到不同的意见怎样处理？ 谁来设定优先级 / 计划？ 如果团队没能赶上预期发布日期怎么办？ 每周都会开什么类型的会议？ 会有定期的和上级的一对一谈话吗？ 产品 / 服务的规划是什么样的？（n 周一发布 / 持续部署 / 多个发布流 / …) 生产环境发生事故了怎么办？是否有不批评人而分析问题的文化？ 有没有一些团队正在经历还尚待解决的挑战？ 你们如何跟踪进度？ 预期和目标是如何设定的？谁来设定？ Code Review 如何实施？ 给我介绍下团队里一个典型的 sprint 你们如何平衡技术和商业目标？ 你们如何共享知识？ 团队有多大？ 公司技术团队的架构和人员组成？(zh) 团队内开发、产品、运营哪一方是需求的主要提出方？哪一方更强势？(zh) 问未来的同事 开发者倾向于从哪里学习？ 你对在这里工作最满意的地方是？ 最不满意的呢？ 如果可以的话，你想改变哪里？ 团队最老的成员在这里多久了？ 在小团队中，有没有出现成员性格互相冲突的情况？最后是如何解决的？ 公司 公司为什么在招人？（产品发展 / 新产品 / 波动…) 有没有会议 / 旅行预算？使用的规定是什么？ 晋升流程是怎样的？要求 / 预期是怎样沟通的？ 绩效评估流程是怎样的？ 技术和管理两条职业路径是分开的吗？ 对于多元化招聘的现状或者观点是什么？ 有公司级别的学习资源吗？比如电子书订阅或者在线课程？ 有获取证书的预算吗？ 公司的成熟度如何？（早期寻找方向 / 有内容的工作 / 维护中 / …) 我可以为开源项目做贡献吗？是否需要审批？ 你认为公司未来五年或者十年会发展成什么样子？ 公司的大多数员工是如何看待整洁代码的？ 你上次注意到有人成长是什么时候？他们在哪方面成长了？ 在这里成功的定义是什么？如何衡量成功？ 有体育活动或者团建么？ 有内部的黑客马拉松活动吗？ 公司支持开源项目吗？ 有竞业限制或者保密协议需要签吗？ 你们认为公司文化中的空白是什么？ 能够跟我说一公司处于不良情况，以及如何处理的故事吗？ 您在这工作了多久了？您觉得体验如何？(zh) 大家为什么会喜欢这里？(zh) 公司的调薪制度是如何的？(zh) 社会问题 你们关于多元化招聘什么看法？ 你们的公司文化如何？你认为有什么空白么？ 这里的工作生活平衡地怎么样？ 公司对气候变化有什么态度吗？ 冲突 不同的意见如何处理？ 如果被退回了会怎样？（“这个在预计的时间内做不完”） 当团队有压力并且在超负荷工作的时候怎么处理？ 如果有人注意到了在流程或者技术等其他方面又改进的地方，怎么办？ 当管理层的预期和工程师的绩效之间有差距的时候如何处理？ 能给我讲一个公司深处有毒环境以及如何处理的故事吗？ 如果在公司内你的同事因涉嫌性侵犯他人而被调查，请问你会如何处理？ 假设我自己很不幸是在公司内被性侵的受害者，在公司内部有没有争取合法权益的渠道？ 商业 你们现在盈利吗？ 如果没有的话，还需要多久？ 公司的资金来源是什么？谁影响或者制定高层计划或方向？ 你们如何挣钱？ 什么阻止了你们挣更多的钱？ 公司未来一年的增长计划怎样？五年呢？ 你们认为什么是你们的竞争优势？ 你们的竞争优势是什么？ 公司未来的商业规划是怎样的？有上市的计划吗？(zh) 远程工作 远程工作和办公室工作的比例是多少？ 公司提供硬件吗？更新计划如何？ 使用自己的硬件办公可以吗？现在有政策吗？ 额外的附件和家具可以通过公司购买吗？这方面是否有预算？ 有共享办公或者上网的预算吗？ 多久需要去一次办公室？ 公司的会议室是否一直是视频会议就绪的？ 办公室布局 办公室的布局如何？（开放的 / 小隔间 / 独立办公室） 有没有支持 / 市场 / 或者其他需要大量打电话的团队在我的团队旁边办公？ 终极问题 该职位为何会空缺？ 公司如何保证人才不流失？ 这份工作 / 团队 / 公司最好和最坏的方面是？ 你最开始为什么选择了这家公司？ 你为什么留在这家公司？ 待遇 如果有奖金计划的话，奖金如何分配？ 如果有奖金计划的话，过去的几年里通常会发百分之多少的奖金？ 有五险一金(zh)/401k(us)或者其他退休养老金等福利吗？ 五险一金中，补充公积金一般交多少比例？/401k一般交多少比例？我可以自己选择这一比例吗？ 有什么医疗保险吗？如果有的话何时开始？ 有额外商业保险吗？例如人寿保险和额外的养老/医疗保险？ 更换工作地点，公司付费吗？ 休假 带薪休假时间有多久？ 病假和事假是分开的还是一起算？ 我可以提前使用假期时间吗？也就是说应休假期是负的？ 假期的更新策略是什么样的？也就是说未休的假期能否滚入下一周期 照顾小孩的政策如何？ 无薪休假政策是什么样的？ 学术性休假政策是怎么样的？ 技术文档写作规范 摘自 https://www.forvs.com/231.html 作者 https://github.com/ruanyf/document-style-guide 标题 层级 标题分为四级。 一级标题：文章的标题 二级标题：文章主要部分的大标题 三级标题：二级标题下面一级的小标题 四级标题：三级标题下面某一方面的小标题 下面是示例。 1234567# 一级标题## 二级标题### 三级标题#### 四级标题 原则 （1）一级标题下，不能直接出现三级标题。 示例：下面的文章结构，缺少二级标题。 123# 一级标题### 三级标题 （2）标题要避免孤立编号（即同级标题只有一个）。 示例：下面的文章结构，二级标题 A只包含一个三级标题，完全可以省略三级标题 A。 12345## 二级标题 A### 三级标题 A## 二级标题 B （3）下级标题不重复上一级标题的名字。 示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。 123## 概述### 概述 （4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。 如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。 示例：下面的结构二要好于结构一。结构一适用的场景，主要是较长篇幅的内容。 12345678910111213141516171819结构一### 三级标题#### 四级标题 A#### 四级标题 B#### 四级标题 C结构二### 三级标题**（1）A****（2）B****（3）C** 文本 字间距 （1）全角中文字符与半角英文字符之间，应有一个半角空格。 123错误：本文介绍如何快速启动Windows系统。 正确：本文介绍如何快速启动 Windows 系统。 （2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。 123正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。 正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。 半角的百分号，视同阿拉伯数字。 123正确：今年我国经济增长率是6.5%。 正确：今年我国经济增长率是 6.5%。 （3）英文单位若不翻译，单位前的阿拉伯数字与单位符号之间，应留出适当的空隙。 123例1：一部容量为 16 GB 的智能手机 例2：1 h = 60 min = 3,600 s （4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。 123错误：他的电脑是 MacBook Air 。 正确：他的电脑是 MacBook Air。 句子 （1）避免使用长句。 不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，任何情况下都不能接受。 123错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。 正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。 逗号分割的长句，总长度不应该超过 100 字或者正文的 3 行。 （2）尽量使用简单句和并列句，避免使用复合句。 123并列句：他昨天生病了，没有参加会议。 复合句：那个昨天生病的人没有参加会议。 （3）同样一个意思，尽量使用肯定句表达，不使用否定句表达。 123错误：请确认没有接通装置的电源。 正确：请确认装置的电源已关闭。 （4）避免使用双重否定句。 123错误：没有删除权限的用户，不能删除此文件。 正确：用户必须拥有删除权限，才能删除此文件。 写作风格 （1）尽量不使用被动语态，改为使用主动语态。 123错误：假如此软件尚未被安装， 正确：假如尚未安装这个软件， （2）不使用非正式的语言风格。 123错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！ 正确：无法参加本次活动，我深感遗憾。 （3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。 123错误：这是唯二的快速启动的方法。 正确：这是仅有的两种快速启动的方法。 （4）用对“的”、“地”、“得”。 12345678她露出了开心的笑容。（形容词＋的＋名词） 她开心地笑了。（副词＋地＋动词） 她笑得很开心。（动词＋得＋副词） （5）使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。 123错误：从管理系统可以监视中继系统和受其直接控制的分配系统。 正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。 （6）名词前不要使用过多的形容词。 123错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。 正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。 英文处理 （1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。 123英文：⋯information stored in random access memory (RAMs)⋯ 中文：……存储在随机存取存储器（RAM）里的信息…… （2）外文缩写可以使用半角圆点(.)表示缩写。 12U.S.A.Apple, Inc. （3）表示中文时，英文省略号（⋯）应改为中文省略号（……）。 123英文：5 minutes later⋯ 中文：5 分钟过去了…… （4）英文书名或电影名改用中文表达时，双引号应改为书名号。 123英文：He published an article entitled &quot;The Future of the Aviation&quot;. 中文：他发表了一篇名为《航空业的未来》的文章。 （5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。 12345IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。 （6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。 123“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。 “online transaction processing”（在线事务处理）不是专有名词，不应大写。 段落 原则 一个段落只能有一个主题，或一个中心句子。 段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。 一个段落的长度不能超过七行，最佳段落长度小于等于四行。 段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。 段落之间使用一个空行隔开。 段落开头不要留出空白字符。 引用 引用第三方内容时，应注明出处。 12345One man’s constant is another man’s variable. — Alan Perlis 如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。 12345本文转载自 WikiQuote 使用外部图片时，必须在图片下方或文末标明来源。 12345本文部分图片来自 Wikipedia 数值 半角数字 阿拉伯数字一律使用半角形式，不得使用全角形式。 123错误：这件商品的价格是１０００元。 正确：这件商品的价格是 1000 元。 千分号 数值为千位以上，应添加千分号（半角逗号）。 12345XXX 公司的实收资本为 ￥1,258,000 人民币。 对于 4 位的数值，千分号是选用的，比如1000和1,000都可以接受。对于 4 位以上的数值，应添加千分号。 货币 货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。 12$1,0001,000 美元 英文的货币名称，建议参考国际标准 ISO 4217。 数值范围 表示数值范围时，用波浪线（～）或一字线（—）连接。参见《标点符号》一节的“连接号”部分。 带有单位或百分号时，两个数字建议都要加上单位或百分号。 123132 kg～234 kg 67%～89% 变化程度的表示法 数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。 12345增加到过去的两倍（过去为一，现在为二） 增加了两倍（过去为一，现在为三） 数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。 12345降低到百分之八十（定额是一百，现在是八十） 降低了百分之八十（原来是一百，现在是二十） 不能用“降低 N 倍”或“减少 N 倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。 标点符号 原则 （1）中文语句的标点符号，均应该采取全角符号，这样可以与全角文字保持视觉的一致。 （2）如果整句为英文，则该句使用英文/半角标点。 （3）句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。 （4）点号（句号、逗号、顿号、分号、冒号）不得出现在标题的末尾，而标号（引号、括号、破折号、省略号、书名号、着重号、间隔号、叹号、问号）可以。 句号 （1）中文语句的结尾处应该用全角句号（。）。 （2）句子末尾用括号加注时，句号应在括号之外。 123错误：关于文件的输出，请参照第 1.3 节（见第 26 页。） 正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。 逗号 （1）逗号（，）表示句子内部的一般性停顿。 （2）注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。 顿号 （1）句子内部的并列词，应该用全角顿号(、) 分隔，而不用逗号，即使并列词是英语也是如此。 123错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。 正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。 （2）英文句子中，并列词语之间使用半角逗号（,）分隔。 12345例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components. （3）中文句子内部的并列词，最后一个尽量使用（和）来连接，使句子读起来更加连贯，下面两个句子都可以，第二个更优。 123正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里，以及百度等。 正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。 分号 （1）分号（；）表示复句内部并列分句之间的停顿。 引号 （1）引用时，应该使用全角双引号（“ ”），注意前后双引号不同。 12345例句：许多人都认为客户服务的核心是“友好”和“专业”。 （2）引号里面还要用引号时，外面一层用双引号，里面一层用单引号（‘ ’），注意前后单引号不同。 12345例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。” 括号 （1）补充说明时，使用全角圆括号（（）），括号前后不加空格。 12345例句：请确认所有的连接（电缆和接插件）均安装牢固。 （2）几种括号的中英文名称。 英文 中文 &#123; &#125; braces 或 curly brackets 大括号 `` square brackets 或 brackets 方括号 &lt; &gt; angled brackets 尖括号 ( ) parentheses 圆括号 冒号 （1）全角冒号（：）常用在需要解释的词语后边，引出解释和说明。 12345例句：请确认以下几项内容：时间、地点、活动名称和来宾数量。 （2）表示时间时，应使用半角冒号（:）。 12345例句：早上 8:00 省略号 （1）省略号（……）表示语句未完、或者语气的不连续。 （2）省略号占两个汉字空间、包含六个省略点，不要使用。。。或...等非标准形式。 （3）省略号不应与“等”这个词一起使用。 12345错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。 正确：我们为会餐准备了各色水果，有香蕉、苹果、梨…… 正确：我们为会餐准备了香蕉、苹果、梨等各色水果。 感叹号 （1）应该使用平静的语气叙述，尽量避免使用感叹号（！）。 （2）不得多个感叹号连用，比如！！和!!!。 破折号 （1）破折号————一般用于进一步解释。 （2）破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。 123例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。 例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。 连接号 （1）连接号用于连接两个类似的词。 （2）以下场合应该使用直线连接号（-），占一个半角字符的位置。 两个名词的复合 图表编号 123例句：氧化-还原反应 例句：图 1-1 （3）数值范围（例如日期、时间或数字）应该使用波浪连接号（～）或一字号（—），占一个全角字符的位置。 12345例句：2009 年～2011 年 注意，波浪连接号前后两个值都建议加上单位。 （4）波浪连接号也可以用汉字“至”代替。 12345例句：周围温度：-20 °C 至 -10 °C 文档体系 结构 软件手册是一部完整的书，建议采用下面的结构。 简介（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明 快速上手（Getting Started）：[可选] [文件] 如何最快速地使用产品 入门篇 （Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程 环境准备（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件 安装（Installation）：[可选] [文件] 软件的安装方法 设置（Configuration）：[必备] [文件] 软件的设置 进阶篇（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程 API（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍 FAQ：[可选] [文件] 常见问题解答 附录 （Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容 Glossary：[可选] [文件] 名词解释 Recipes：[可选] [文件] 最佳实践 Troubleshooting：[可选] [文件] 故障处理 ChangeLog：[可选] [文件] 版本说明 Feedback：[可选] [文件] 反馈方式 下面是两个真实范例，可参考。 Redux 手册 Atom 手册 文件名 文档的文件名不得含有空格。 文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。 123错误：名词解释.md 正确：glossary.md 文件名建议只使用小写字母，不使用大写字母。 123错误：TroubleShooting.md 正确：troubleshooting.md 为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。 文件名包含多个单词时，单词之间建议使用半角的连词线（-）分隔。 123不佳：advanced_usage.md 正确：advanced-usage.md 参考链接 产品手册中文写作规范, by 华为 写作规范和格式规范, by DaoCloud 技术写作技巧在日汉翻译中的应用, by 刘方 简体中文规范指南, by lengoo 文档风格指南, by LeanCloud 豌豆荚文案风格指南, by 豌豆荚 中文文案排版指北, by sparanoid 中文排版需求, by W3C 为什么文件名要小写？, by 阮一峰 Google Developer Documentation Style Guide, by Google 出版物上数字用法的规定（国家标准GBT15835－2011） GB 3100-1993 国际单位制及其应用","categories":[{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog1.cpen.top/tags/GitHub/"},{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"学习","slug":"学习","permalink":"https://blog1.cpen.top/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"习惯","slug":"习惯","permalink":"https://blog1.cpen.top/tags/%E4%B9%A0%E6%83%AF/"}]},{"title":"04_转载-提问的智慧","slug":"转载/04_转载-GitHub-提问的智慧","date":"2023-05-02T04:00:00.000Z","updated":"2023-05-02T05:00:00.000Z","comments":true,"path":"posts/beb8baf2.html","permalink":"https://blog1.cpen.top/posts/beb8baf2.html","excerpt":"","text":"具体版权见原文。原文：https://github.com/tvvocold/How-To-Ask-Questions-The-Smart-Way 弃权申明 许多项目的网站在如何取得帮助的部分链接了本文，这没有关系，也正是我们想要的。但如果你是该项目生成此链接的网管，请在链接附近显著位置注明：我们不提供该项目的服务支持！ 我们已经领教了没有此说明带来的痛苦，我们将不停地被一些白痴纠缠，他们认为既然我们发布了本文，那么我们就有责任解决世上所有的技术问题。 如果你是因为需要帮助正在阅读本文，然后就带着可以直接从作者那取得帮助的印象离开，那么 你 就不幸成了我们所说的白痴之一。 别向 我们 提问，我们不会理睬的。 我们只是在这教你如何从那些真正懂得你软硬件问题的人那里取得帮助，但 99.9％ 的时间我们不会是那些人。除非你非常地 确定 本文的作者是你遇到问题方面的专家，请不要打搅，这样大家都更开心一点。 引言 在 黑客 的世界里，你所提技术问题的解答很大程度上取决于你提问的方式与解决此问题的难度，本文将教你如何提问才更有可能得到满意的答复。 开源程序的应用已经很广，你通常可以从其他更有经验的用户而不是黑客那里得到解答。这是好事，他们一般对新手常有的毛病更容忍一点。然尔，使用我们推荐的方法，象对待黑客那样对待这些有经验的用户，通常能最有效地得到问题的解答。 第一件需要明白的事是黑客喜欢难题和激发思考的好问题。假如不是这样，我们也不会写本文了。如果你能提出一个有趣的问题让我们咀嚼玩味，我们会感激你。好问题是种激励与礼物，帮助我们发展认知，揭示没有注意或想到的问题。在黑客中，“好问题！” 是非常热烈而真挚的赞许。 此外，黑客还有遇到简单问题就表现出敌视或傲慢的名声。有时，我们看起来还对新手和愚蠢的家伙有条件反射式的无礼，但事情并不真是这样。 我们只是毫无歉意地敌视那些提问前不愿思考、不做自己家庭作业的人。这种人就象时间无底洞──他们只知道索取，不愿意付出，他们浪费了时间，这些时间本可用于其它更有趣的问题或更值得回答的人。我们将这种人叫做 “失败者（loser）” （由于历史原因，我们有时将“loser”拼写为“lusers” 。） 我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，计算机只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做，我们承认这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。不过，我们回答问题的风格是为了适应那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就会在自己能做得最好的事情上不再那么犀利。 我们（大多数）是自愿者， 从自己繁忙的生活中抽时间来回答问题，有时会力不从心。因此，我们会毫不留情地滤除问题，特别是那些看起来象是失败者提的，以便更有效地把回答问题的时间留给那些胜利者。 如果你认为这种态度令人反感、以施惠者自居或傲慢自大，请检查你的假设，我们并未要求你屈服──事实上，假如你做了该做的努力，我们中的大多数将非常乐意平等地与你交流，并欢迎你接纳我们的文化。试图去帮助那些不愿自救的人对我们简直没有效率。不懂没有关系，但愚蠢地做事不行。 所以，你不必在技术上很在行才能吸引我们的注意，但你 必须 表现出能引导你在行的姿态──机 敏、有想法、善于观察、乐于主动参与问题的解决。如果你做不到这些使你与众不同的事情，我们建议你付钱跟别人签商业服务合同，而不是要求黑客无偿帮助。 如果你决定向我们求助，你不会想成为一名失败者，你也不想被看成一个失败者。得到快速有效回答的最好方法是使提问者看起来象个聪明、自信和有想法的人，并且暗示只是碰巧在某一特别问题上需要帮助。 （欢迎对本文指正，可以将建议发至 esr@thyrsus.com 或 respond-auto@linuxmafia.com。 请注意，本文不想成为一般性的 网络礼仪 指南，我一般会拒绝那些与引出技术论坛中有用的回答不特别相关的建议。） 提问前 在通过电邮、新闻组或论坛提技术问题以前，做以下事情： 尝试在你准备提问论坛的历史文档中搜索答案 尝试搜索互联网以找到答案 尝试阅读手册以找到答案 尝试阅读“常见问题文档”（FAQ）以找到答案 尝试自己检查或试验以找到答案 尝试请教懂行的朋友以找到答案 如果你是程序员，尝试阅读源代码以找到答案 提问时，请先表明你已做了上述事情，这将有助于建立你不是寄生虫与浪费别人时间的印象。最好再表述你从中 学到的东西 ，我们喜欢回答那些表现出能从答案中学习的人。 运用某些策略，比如用谷歌（Google）搜索你遇到的各种错误提示（既搜索 谷歌论坛，也搜索网页）， 这样很可能直接就找到了解决问题的文档或邮件列表线索。 即使没有结果，在邮件列表或新闻组寻求帮助时提一句“我在谷歌中搜过下列句子但没有找到什么有用的东西” 也是件好事，至少它表明了搜索引擎不能提供哪些帮助。将搜索关键词与你的问题及可能的解决方案联系起来，还有助于引导其他有类似问题的人。 别着急，不要指望几秒钟的谷歌搜索就能解决一个复杂的问题。读一下常见问题文档。在向专家提问之前，先向后靠靠放松一下，再思考一下问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑抛出，只因你的第一次搜索没有结果（或者结果太多）。 认真地思考，准备好你的问题。轻率的提问只能得到轻率的回答，或者压根没有。在提问时，你越是表现出在此前做过思考与努力去解决自己的问题，你越有可能得到真正的帮助。 注意别提错问题。如果提问基于错误的假设，某黑客多半会一边想 “愚蠢的问题……”，一边按将错就错的答案回复你，并且希望这种只是得到你自己“问的问题”而非真正所需的解答，给你一个教训。 永远不要假设你 有资格 得到解答。你没有这种资格，毕竟你没有为此服务付费。如果你能够提出有内容、有趣和激励思考的问题──那种毫无疑问能够向社区贡献经验，而不仅仅是消极地要求从别人那获取知识的问题，你将“挣到”答案。 另一方面，表明你有能力也乐意参与问题的解决是个很好的开端。“有没有人能指个方向？”，我这还差点什么？”，“我应该查哪个网站？”，通常要比 “请给出我可以用的完整步骤”更容易得到回复，因为你表明了只要有人能指个方向，你就很乐意完成剩下的过程。 提问时 仔细挑选论坛 要对在哪提问留心，如果你做了下述事情，多半会被一笔勾销或被看成“失败者”： 张贴与论坛主题无关的问题 在面向高级技术问题的论坛上张贴肤浅的问题，或者反之。 在太多不同的新闻组同时张贴 给既非熟人也没有义务解决你问题的人发送你私人的电邮 为保护通信的渠道不被无关的东西淹没，黑客会除掉那些没有找对地方的问题，你不会想让这种事落到自己头上的。 因此，第一步是找对论坛。谷歌和其它搜索引擎还是你的朋友，可以用它们搜索你遇到困难的软硬件问题最相关的项目网站。那里通常都有项目的常见问题（FAQ）、邮件列表及文档的链接。如果你的努力（包括 阅读 FAQ）都没有结果，这些邮件列表就是最后能取得帮助的地方。项目的网站也许还有报告Bug的流程或链接，如果是这样，去看看。 向陌生的人或论坛发送邮件极有可能是在冒险。譬如，不要假设一个内容丰富的网页的作者想充当你的免费顾问，不要对你的问题是否会受到欢迎做太乐观的估计──如果你不确定，向别处发或者压根别发。 在选择论坛、新闻组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以明确你的问题是否切题。发贴前先翻翻已有的帖子，这样可以让你感受一下那里行事的方式。事实上，张贴前在新闻组或邮件列表的历史文档中搜索与你问题相关的关键词是个极好的主意，也许就找到答案了。即使没有，也能帮助你归纳出更好的问题。 别象机关枪似的一次性“扫射”所有的帮助渠道，这就象大喊大叫一样会令人不快，温柔地一个一个来。 弄懂主题！最典型的错误之一是在某种致立于跨平台可移植的语言、库或工具的论坛中提关于 Unix 或 Windows 操作系统程序接口的问题。如果你不明白为什么这是大错，最好在搞清楚概念前什么也别问。 一般来说，在仔细挑选的公共论坛中提问比在私有论坛中提同样的问题更容易得到有用的回答。有几个道理支持这点，一是看潜在的回复者有多少，二是看论坛的参与者有多少，黑客更愿回答能启发多数人的问题。 可以理解，老练的黑客和一些流行软件的作者正在承受过多的不当消息。就象那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端──已经好几次了，一些流行软件的作者退出了对自己软件的支持，因为伴随而来的涌入其私人邮箱的垃圾邮件变得无法忍受。 面向新手的论坛和互联网中继聊天（IRC）通常响应最快 本地的用户组织或者你所用的 Linux 发行版也许正在宣传新手取得帮助的论坛或 IRC 通道（在一些非英语国家，新手论坛很可能还是邮件列表），这些地方是开始提问的好去处，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。经过宣传的 IRC 通道是公开邀请提问的地方，通常可以得到实时的回复。 事实上，如果出问题的程序来自某发行版（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的项目论坛或邮件列表，（否则）该项目的黑客可能仅仅回复“用 我们的 代码”。 在任何论坛发贴以前，先看看有没有搜索功能。如果有，就试着用问题的几个关键词搜索一下，也许就有帮助。如果在此之前你已做过全面的网页搜索（你应该这样去做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。 通过论坛或 IRC 通道提供项目的用户支持有增长的趋势，电子邮件交流则更多地为项目开发者保留。所以先在论坛或 IRC 中寻求与该项目相关的帮助。 第二步，使用项目的邮件列表 当某个项目存在开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文档和主页，找到项目的邮件列表并使用它。采用这种办法有几个很好的理由： 向个别开发者提的问题（如果）足够好，也将对整个项目组有益。相反，如果你认为自己的问题对整个项目组来说太愚蠢，这也不能成为骚扰个别开发者的理由。 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导）也许太忙以至于没法回答你的问题。 大多数邮件列表都要存档，那些存档将被搜索引擎索引，如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。 如果某些问题经常被问到，开发者可以利用此信息改进文档或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。 如果一个项目既有 “用户” 也有“开发者”（或 “黑客”）邮件列表或论坛，而你又不摆弄那些代码，向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会遭受你的噪音干扰。 然尔，如果你 确信 你的问题不一般，而且在“用户” 列表或论坛中几天都没有回复，可以试试“开发者”列表或论坛。建议你在张贴前最好先暗暗地观察几天,至少看看最近几天保存的帖子,以了解那的行事方式（事实上这是参与任何私有或半私有列表的好主意） 如果你找不到一个项目的邮件列表，而只能查到项目维护者的地址，只管向其发信。即便在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。 使用有意义且明确的主题 在邮件列表、新闻组或论坛中，主题是你在五十个或更少的字以内吸引有资格专家注意的黄金机会，不要用诸如 “请帮我” （更别提大写的 “请帮我！！！！”，这种主题的消息会被条件反射式地删掉）之类的唠叨浪费机会。不要用你痛苦的深度来打动我们，相反，要在这点空间中使用超级简明扼要的问题描述。 使用主题的好惯例是“对象──偏差”（式的描述），许多技术支持组织就是这样做的。在“对象”部分指明是哪一个或哪一组东西有问题，在“偏差”部分则描述与期望的行为不一致的地方。 愚蠢： 救命啊！我的笔记本视频工作不正常！ 明智： X.org 6.8.1 扭曲鼠标光标，MV1005 型号的某显卡芯片组 更明智： 使用 MV1005 型号的某显卡芯片组在 X.org 6.8.1 的鼠标光标被扭曲 编写 “对象──偏差”式描述的过程有助于你组织对问题的细致思考。是什么被影响了？仅仅是鼠标光标或者还有其它图形？只在 X.org 中出现？或只是在其 6.8.1 版中？是针对某显卡芯片组？或者只是其中的 MV1005 型号？一个黑客只需描一眼就能够立即明白什么是你遇到的问题，什么是你自己的问题。 更一般地，想象一下在一个只显示主题的文档索引中查找。让你的主题更好地反映问题，可以使下一个搜索类似问题的人能够在文档中直接就找到答案的线索，而不用再次发贴提问。 如果你想在回复中提问，确保改变主题以表明你是在问一个问题，一个主题象 Re: 测试 或者 Re: 新Bug 的消息不太可能引起足够的注意。同时，将回复中与新主题不甚相关的引用内容尽量删除。 对于列表消息，不要直接点击回复（按钮）来开始一个全新的线索，这将限制你的观众。有些邮件阅读程序，比如 mutt，允许用户按线索排序并通过折叠线索来隐藏消息，这样做的人永远看不到你发的消息。 仅仅改变主题还不够。mutt 和其它一些邮件阅读程序还要检查邮件头主题以外的其它信息，以便为其指定线索，所以宁可发一个全新的邮件。 在论坛，因为消息与特定的线索紧密结合，并且通常在线索之外不可见，好的提问方式略有不同，通过回复提问并不要紧。不是所有论坛都允许在回复中出现分离的主题，而且这样做了基本上没有人会去看。不过，通过回复提问本身就是令人怀疑的做法，因为它们只会被正在查看该线索的人读到。所以，除非你 只想 在该线索当前活跃的人群中提问，还是另起炉灶比较好。 使问题容易回复 以请向……回复来结束问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟考虑你的问题更麻烦。如果你的邮件客户端程序不支持这样做，换个好点的；如果是操作系统不支持所有这种邮件客户端程序，也换个好点的。 在论坛，要求通过电子邮件回复是完全无礼的，除非你确信回复的信息也许是敏感的（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复线索时得到电子邮件提醒，可以要求论坛发送。几乎所有论坛都支持诸如留意本线索、有回复发送邮件等功能。 用清晰、语法、拼写正确的语句书写 经验告诉我们，粗心与草率的作者通常也粗心与草率地思考和编程（我敢打赌）。为这些粗心与草率的思考者回答问题没有什么好处，我们宁可将时间花在其它地方。 清楚、良好地表达你的问题非常重要。如果你觉得这样做麻烦，我们也觉得注意（你的问题）麻烦。花点额外的精力斟酌一下字句，用不着太僵硬与正式──事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它 必须 很准确，而且有迹象表明你是在思考和关注问题。 正确地拼写、使用标点和大小写，不要将 its 混淆为 it's，loose 搞成 lose 或者将 “discrete” 弄成 “discreet”。不要全部用大写，这会被视为无礼的大声嚷嚷 （全部小写也好不到哪去，因为不易阅读。Alan Cox [注：著名黑客，Linux 内核的重要参与者] 也许可以这样做，但你不行。） 一般而言，如果你写得象个半文盲似的傻子，多半得不到理睬。也不要使用即时通讯中的简写，如将 you 简化为 u 会使你看起来象一个为了节约二次击键的半文盲式的傻子。更糟的是，如果象个小孩似地鬼画桃符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。 如果在非母语论坛提问，你的拼写与语法错误会得到有限的宽容，但懒惰完全不会被容忍（是的，我们通常看得出其中的差别）。同时，除非你知道回复者使用的语言，请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在互联网上英语是工作语言，用英语书写可以将你的问题不被阅读就被直接删除的可能性降到最低。 如果你用英语书写但它是你的第二语言，最好提醒潜在的回复者语言上可能的困难以便绕过这个问题，比如： 英语不是我的母语，请谅解拼写错误。 如果您使用某某语言，请电邮/私聊我，也许我需要您的协助翻译我的问题。 对于这个技术术语本身我很熟悉，但对于它的一些俚语或习惯表达方式就不太明白了。 我已经同时用某某语及英语提问，如果您使用两者之一回复，我很乐意翻译。 使用易于读取且标准的文件格式发送问题 如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以： 使用纯文本而不是 HTML（超文本标注语言）（ 关闭HTML 并不难） 使用 MIME（多用途互联网邮件扩展）附件通常没有问题，前提是真正有内容（譬如附带的源文件或补丁），而不仅仅是邮件客户端程序生成的模板（譬如只是消息内容的拷贝）。 不要发送整段只是单行句子但多次折回的邮件（这使得回复部分内容非常困难）。设想你的读者是在80个字符宽的文本终端阅读邮件，设置你的行折回点小于 80 列。 但是，也 不要 用任何固定列折回数据（譬如日志文件拷贝或会话记录）。数据应该原样包含，使回复者确信他们看到的是与你看到的一样的东西。 在英语论坛中，不要使用’Quoted-Printable’ MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持。当它们分断时，那些文本中四处散布的 “=20”符号既难看也分散注意力，甚至有可能破坏内容的语意。 永远不要 指望黑客们阅读使用封闭的专用格式编写的文档，诸如微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就象有人将还在冒热气的猪粪倒在你门口时你的反应一样。即使他们能够处理，也很厌恶这么做。 如果你从使用视窗的电脑发送电子邮件，关闭问题颇多的微软“聪明引用”功能（在“工具” -&gt; “自动纠正选项”的“输入时自动格式化”下去掉聪明引用的选框），以免在你的邮件中到处散布垃圾字符。 在论坛，勿滥用“表情符号”和“HTML”功能(当它们提供时)。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来象个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是有用的回复更有兴趣。 如果你使用图形用户界面的邮件客户端程序(如网景公司的 Messenger、微软公司的 Outlook 或者其它类似的)，注意它们的缺省配置不一定满足这些要求。大多数这类程序有基于菜单的查看源码命令，用它来检查发送文件夹中的消息，以确保发送的是没有多余杂质的纯文本文件。 描述问题应准确且有内容 仔细、清楚地描述问题的症状 描述问题发生的环境(主机、操作系统、应用程序，任何相关的)，提供销售商的发行版和版本号（如：“Fedora Core 7”、“Slackware 9.1”等） 描述提问前做过的研究及其理解。 描述提问前为确定问题而采取的诊断步骤。 描述最近对计算机或软件配置的任何相关改变。 如果可能，提供在可控环境下重现问题的方法。 尽最大努力预测黑客会提到的问题，并提前备好答案。 如果你认为是代码有问题，向黑客提供在可控环境下重现问题的方法尤其重要。当你这么做时，得到有用且及时回复的可能性将大大增加。 西蒙.泰瑟姆（Simon Tatham）写过一篇《如何有效报告Bug》的文章，我强烈推荐各位阅读。 量不在多，精炼则灵 你应该（写得）精炼且有内容，简单地将一大堆代码或数据罗列在求助消息中达不到目的。如果你有一个很大且复杂的测试样例让程序崩溃，尝试将其裁剪得越小越好。 至少有三个理由支持这点。第一，让别人看到你在努力简化问题使你更有可能得到回复。第二，简化问题使你更有可能得到 有用的 回复。第三，在提纯Bug报告的过程中，你可能自己就找到了解决办法或权宜之计。 别急于宣称找到Bug 当你在一个软件中遇到问题，除非你 非常、非常 的有根据，不要动辄声称找到了Bug。提示：除非你能提供解决问题的源代码补丁，或者对前一版本的回归测试表现出不正确的行为，否则你都多半不够完全确信。对于网页和文档也如此，如果你（声称）发现了文档的“Bug”，你应该能提供相应位置的替代文本。 记住，还有许多其它用户并未经历你遇到的问题，否则你在阅读文档或搜索网页时就应该发现了（[你在报怨前已经做了这些，是吧 ？](#你在报怨前已经做了这些，是吧 ？)）。这也意味着很有可能是你弄错了而不是软件本身有问题。 编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了Bug，也就置疑了他们的能力，即使你是对的，也有可能会使其中的部分人感到不快。（此外，）在主题中嚷嚷“Bug”也是特别不老练的。 提问时，即使你私下非常确信已经发现一个真正的Bug，最好写得象是 你 做错了什么。如果真的有Bug，你会在回复中看到这点。这样做的话，如果真有虫子，维护者就会向你道歉，这总比你弄砸了然后欠别人一个道歉要强。 低声下气代替不了做自己的家庭作业 有些人明白他们不应该粗鲁或傲慢地行事并要求得到答复，但他们退到相反的低声下气的极端：“我知道我只是个可怜的新丁，一个失败者，但……”。这既使人困扰，也没有用，当伴随着对实际问题含糊的描述时还特别令人反感。 别用低级灵长类动物的办法浪费你我的时间，相反，尽可能清楚地描述背景情况和你的问题，这比低声下气更好地摆正了你的位置。 有时，论坛设有单独的初学者提问版面，如果你真的认为遇到了肤浅的问题，到那去就是了，但一样别低声下气。 描述问题症状而不是猜测 告诉黑客是什么导致了问题是没用的（如果你的诊断理论是了不起的东西，你还会向别人咨询求助吗？）。所以，确保只是告诉他们问题的原始症状，而不是你的解释和理论，让他们来解释和诊断。如果你认为陈述自己的猜测很重要，应清楚地说明这只是你的猜测并描述为什么它们不起作用。 愚蠢： 我在编译内核时接连遇到 SIG11 错误，怀疑主板上的某根电路丝断了，找到它们的最好办法是什么？ 明智： 我组装的电脑（K6/233 CPU、FIC-PA2007 主板[威盛 Apollo VP2 芯片组]、Corsair PC133 SDRAM 256Mb 内存）最近在开机 20 分钟左右、做内核编译时频繁地报 SIG11 错，但在头 20 分钟内从不出问题。重启动不会复位时钟，但整夜关机会。更换所有内存未解决问题，相关的典型编译会话日志附后。 由于以上这点许多人似乎难以掌握，这里有句话可以提醒你：“所有的诊断专家都来自密苏里州”。美国国务院的官方座右铭则是“让我看看”（出自国会议员威勒德.D.范迪弗［Willard D. Vandiver］在1899年时的讲话：“我来自一个出产玉米、棉花、牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。”）针对诊断者而言，这并不是怀疑，而只是一种真实而有用的需求，以便让他们看到与你看到的原始证据尽可能一致的东西，而不是你的猜测与总结。（所以，）让我们看看。 按时间先后罗列问题症状 刚出问题之前发生的事情通常包含有解决问题最有效的线索。所以，记录中应准确地描述你、电脑和软件在崩溃前都做了什么。在命令行处理的情况下，有会话日志（如运行脚本工具生成的）并引用相关的若干（如20）行记录会非常有帮助。 如果崩溃的程序有诊断选项（如-v详述开关），试着选择这些能在记录中增加排错信息的选项。记住，“多”不等于“好”。试着选取适当的排错级别以便提供有用的信息而不是将阅读者淹没在垃圾中。 如果你的记录很长（如超过四段），在开头简述问题随后按时间先后罗列详细过程也许更有用。这样，黑客在读你的记录时就知道该注意哪些内容了。 描述目标而不是过程 如果你想弄清楚如何做某事（而不是报告一个Bug），在开头就描述你的目标，然后才陈述遇到问题的特定步骤。 经常出现这种情况，寻求技术帮助的人在脑袋里有个更高层次的目标，他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身有问题，结果要费很大的劲才能通过。 愚蠢： 我怎样才能让某图形程序的颜色拾取器取得十六进制的 RGB 值？ 明智： 我正试着用自己选定数值的颜色替换一幅图片的色表，我现在知道的唯一方法是编辑每个表槽，但却无法让某图形程序的颜色拾取器取得十六进制的 RGB 值。 第二种提法是明智的，它使得建议采用更合适的工具以完成任务的回复成为可能。 别要求私下回复电邮 黑客们认为问题的解决过程应该公开、透明，此过程中如果更有才能的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为回复者也因为能力和学识被其它同行看到而得到某种回报。 当你要求私下回复时，此过程和回报都被中止。别这样做，让 回复者 来决定是否私下回答──如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人毫无意义。 对这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么“向我发电邮，我将为论坛归纳这些回复”将是神奇的句子。试着将邮件列表或新闻组从洪水般雷同的回复中解救出来是非常有礼貌的──但你必须信守诺言。 提问应明确 漫无边际的问题通常也被视为没有明确限制的时间无底洞。最有可能给你有用答案的人通常也是最忙的人（假如只是因为他们承担了太多工作的话），这些人对于没有止境的时间无底洞极其敏感，所以他们也倾向于讨厌那些漫无边际的问题。 如果你明确了想让回复者做的事（如指点方向、发送代码、检查补丁或其它），你更有可能得到有用的回复。（因为）这样可以让他们集中精力并间接地设定了他们为帮助你需要花费的时间和精力上限，这很好。 要想理解专家生活的世界，可以这样设想：那里有丰富的专长资源但稀缺的响应时间。你暗中要求他们奉献的时间越少，你越有可能从这些真正懂行也真正很忙的专家那里得到解答。 所以限定你的问题以使专家回答时需要付出的时间最少──这通常与简化问题还不太一样。举个例，“请问可否指点一下哪有好一点的 X 解释？”通常要比“请解释一下 X”明智。如果你的代码不运行了，通常请别人看看哪有问题比叫他们帮你改正更明智。 关于代码的问题 别要求他人给你出问题的代码排错而不提及应该从何入手。张贴几百行的代码，然后说一声“它不能运行”会让你得不到理睬。只贴几十行代码，然后说一句“在第七行以后，本应该显示，但实际出现的是”非常有可能让你得到回复。 最精确描述代码问题的方法是提供一个能展示问题的最小测试样例。什么是最小测试样例？它是对问题的展现，只需要刚好能够重现非预期行为的代码即可。如何生成一个最小测试样例？如果你知道哪一行或哪一段代码会产生问题，将其复制并提供刚好够用的外围支撑代码以构成一个完整的样例（够用是指源码刚好能被编译器、解释器或任何处理它的程序所接受）。如果你不能将问题缩小到特定的段落，复制源码并去除那些与问题无关的代码段。你能提供的最小测试样例越小越好（参见 量不在多，精炼则灵 ）。 生成一个非常小的最小测试样例并不总是可能，但尽力去做是很好的锻练，这有可能帮助你找到需要自己解决的问题。即使你找不到，黑客们喜欢看到你努力过，这将使他们更合作。 如果你只是想让别人帮忙审一下代码，在最开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。 别张贴家庭作业式问题 黑客们善于发现“家庭作业”式的问题。我们中的大多数人已经做了自己的家庭作业，那是该 你 做的，以便从中学到东西。问一下提示没有关系，但不是要求完整的解决方案。 如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户组、论坛或（作为最后一招）在项目的“用户”邮件列表或论坛中提问。尽管黑客们 会 看出来，一些老用户也许仍会给你提示。 删除无意义的要求 抵制这种诱惑，即在求助消息末尾加上诸如“有人能帮我吗？”或“有没有答案？”之类在语义上毫无意义的东西。第一，如果问题描述还不完整，这些附加的东西最多也只能是多余的。第二，因为它们是多余的，黑客们会认为这些东西烦人──就很有可能用逻辑上无误但打发人的回复，诸如“是的，你可以得到帮助”和“不，没有给你的帮助”。 一般来说，避免提“是或否”类型的问题，除非你想得到 “是或否”类型的回答。 不要把问题标记为“紧急”，即使对你而言的确如此 这是你的问题，不要我们的。宣称“紧急”极有可能事与愿违：大多数黑客会直接删除这种消息，他们认为这是无礼和自私地企图得到即时与特殊的关照。而且“紧急”或其它有类似含义的主题有可能触发垃圾过滤规则，潜在的回复者可能永远看不到你的问题！ 有一点点局部的例外，如果你是在一些知名度很高、会使黑客们激动的地方使用程序，也许值得这样去做。在这种情况下，如果你有期限压力，也很有礼貌地提到这点，人们也许会有足够的兴趣快一点回答。 当然，这是非常冒险的，因为黑客们对什么是令人激动的标准多半与你的不同。譬如从国际空间站这样张贴没有问题，但代表感觉良好的慈善或政治原因这样做几乎肯定不行。事实上，张贴诸如“紧急：帮我救救这个毛绒绒的小海豹！”肯定会被黑客回避或光火，即使他们认为毛绒绒的小海豹很重要。 如果你觉得这不可思议，再把剩下的内容多读几遍，直到弄懂了再发贴也不迟。 礼貌总是有益的 礼貌一点，使用 请 和 谢谢你的关注 或者 谢谢你的关照，让别人明白你感谢他们无偿花时间帮助你。 坦率地讲，这一点没有语法正确、文字清晰、准确、有内容和避免使用专用格式重要（同时也不能替代它们）。黑客们一般宁可读有点唐突但技术鲜明的Bug报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教我们什么来评价它的） 然尔，如果你已经谈清楚了技术问题，客气一点肯定会增加你得到有用回复的机会。 （我们必须指出，本文唯一受到一些老黑客认真反对的地方是以前曾经推荐过的“提前谢了”，一些黑客认为这隐含着事后不用再感谢任何人的暗示。我们的建议是要么先说 提前谢了，事后 再 对回复者表示感谢，要么换种方式表达，譬如用 谢谢你的关注 或 谢谢你的关照）。 问题解决后追加一条简要说明 问题解决后向所有帮助过的人追加一条消息，让他们知道问题是如何解决的并再次感谢。如果问题在邮件列表或新闻组中受到广泛关注，在那里追加此消息比较恰当。 最理想的方式是向最初提问的线索回复此消息，并在主题中包含 已解决、已搞定 或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见线索 问题 X 和 问题 X-已解决 的潜在回复者就明白不用再浪费时间了（除非他个人觉得“问题 X”有趣），因此可以利用此时间去解决其它问题。 追加的消息用不着太长或太复杂，一句简单的“你好──是网线坏了！谢谢大家──比尔”就比什么都没有要强。事实上，除非解决问题的技术真正高深，一条简短而亲切的总结比长篇大论要好。说明是什么行动解决了问题，用不着重演整个排错的故事。 对于有深度的问题，张贴排错历史的摘要是恰当的。描述问题的最终状态，说明是什么解决了问题，在此之后 才指明可以避免的弯路。应避免的弯路部分应放在正确的解决方案和其它总结材料之后，而不要将此消息搞成侦探推理小说。列出那些帮助过你的名字，那样你会交到朋友的。 除了有礼貌、有内容以外，这种类型的追帖将帮助其他人在邮件列表、新闻组或论坛文档中搜索到真正解决你问题的方案，从而也让他们受益。 最后，此类追帖还让每位参与协助的人因问题的解决而产生一种满足感。如果你自己不是技术专家或黑客，相信我们，这种感觉对于你寻求帮助的老手和专家是非常重要的。问题叙述到最后不知所终总是令人沮丧的，黑客们痒痒地渴望它们被解决。挠痒痒 为你挣到的信誉将对你下次再次张贴提问非常非常的有帮助。 考虑一下怎样才能避免他人将来也遇到类似的问题，问问自己编一份文档或 FAQ 补丁会不会有帮助，如果是的话就将补丁发给维护者。 在黑客中，这种良好的后继行动实际上比传统的礼貌更重要，也是你善待他人而赢得声誉的方式，这是非常有价值的财富。 如何解读回答 “读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸 有一个古老而神圣的传统：如果你收到 读读该死的手册（RTFM） 的回复，发信人认为你应该去“读读该死的手册”。他或她多半是对的，去读一下吧。 “读读该死的手册”（RTFM）有个年轻一点的亲戚，如果你收到“搜搜该死的网络”（STFW）的回复，发信人认为你应该“搜搜该死的网络”。那人多半也是对的，去搜一下吧。(更温和一点的说法是“谷歌是你的朋友！”) 在论坛，你也可能被要求去搜索论坛的文档。事实上，有人甚至可能热心地为你提供以前解决此问题的线索。但不要依赖这种关照，提问前应该先搜索一下文档。 通常，叫你搜索的人已经打开了能解决你问题的手册或网页，正在一边看一边敲键盘。这些回复意味着他认为： 第一，你要的信息很容易找到。 第二，自已找要比别人喂到嘴里能学得更多。 你不应该觉得这样就被冒犯了，按黑客的标准，回复者没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。 如果还不明白…… 如果你看不懂回答，不要马上回复一个要求说明的消息，先试试那些最初提问时用过的相同工具（如手册、FAQ、网页、懂行的朋友等）试着搞懂回答。如果还是需要说明，展现你已经明白的。 譬如，假如我告诉你：“看起来象是某输入项有问题，你需要清除它”，接着是个 不好 的回帖：“什么是某输入项？”。而这是一个 很好 的跟帖：“是的，我读了手册，某某输入项只在 -z 和 -p 开关中被提到，但都没有涉及到如何清除它们，你指的是哪一个还是我弄错了什么？” 对待无礼 很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当、一针见血式的交流风格，这种风格对于更关注解决问题而不是使别人感觉舒服而混乱的人是很自然的。 如果你觉得被冒犯了，试着平静地反应。如果有人真的做了过格的事，邮件列表、新闻组或论坛中的前辈多半会招呼他。如果这 没有 发生而你却光火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而 你 将被视为有错的一方，这将伤害到你获取信息或帮助的机会。 另一方面，你会偶而真的碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击、用犀利的语言将其驳得体无完肤都是可以接受的。然尔，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外来者，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。 （有些人断言很多黑客都有轻度的自闭症或阿斯伯格综合症，缺少用于润滑人类社会“正常”交往所需的脑电路。这既可能是真也可能是假。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们 喜欢 现在这个样子，并且一般都对病号标记有站得住脚的怀疑。） 在下一节，我们会谈到另一个问题，当 你 行为不当时会受到的“冒犯”。 别象失败者那样反应 在黑客社区的论坛中有那么几次你可能会搞砸──以本文描述或类似的方式。你会被示众是如何搞砸的，也许言语中还会带点颜色。 这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反，你该这样去做： 熬过去，这很正常。事实上，它是有益健康与恰当的。 社区的标准不会自己维持，它们是通过参与者积极而 公开 地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，这不是事情运作的方式。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。 也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称“如果你不想帮助用户就闭嘴”。有思路的参与者纷纷离开的结果只会使它们变成了毫无意义的唠叨与无用的技术论坛。 是夸张的“友谊”（以上述方式）还是有用？挑一个。 记着：当黑客说你搞砸了，并且(无论多么刺耳地)告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤除要容易得多。如果你无法做到感谢，至少要有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人象对待脆弱的洋娃娃那样对你。 有时候，即使你没有搞砸（或者只是别人想象你搞砸了）， 有些人也会无缘无故地攻击你本人。在这种情况下，报怨倒是 真的 会把问题搞砸。 这些找茬者要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些找茬者在给自己找麻烦，这点你不用操心。 也别让自己卷入口水战，大多数口水战最好不要理睬──当然，是在你核实它们只是口水战、没有指出你搞砸的地方，而且没有巧妙地将问题真正的答案藏于其中之后（这也是可能的）。 提问禁忌 下面是些典型的愚蠢问题和黑客不回答它们时的想法。 问：我到哪可以找到某程序或 X 资源？ 问：我怎样用 X 做 Y？ 问：如何配置我的 shell 提示？ 问：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？ 问：我的{程序、配置、SQL 语句}不运行了 问：我的视窗电脑出问题了，你能帮忙吗？ 问：我的程序不运行了，我认为系统工具X有问题 问：我安装 Linux 或 X 遇到困难，你能帮忙吗？ 问：我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？ 问： 我到哪可以找到某程序或 X 资源？ 答： 在我找到它的同样地方，笨旦──在网页搜索引擎上。上帝啊，难道还有人不知道如何使用 谷歌 吗？ 问： 我怎样用 X 做 Y？ 答： 如果你想解决的是 Y，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对要解决的 Y 问题糊涂，还被特定形势禁锢了思维。等他们把问题弄好再说。 问： 如何配置我的 shell 提示？ 答： 如果你有足够的智慧提这个问题，你也该有足够的智慧去 “读读该死的手册”（RTFM），然后自己去找出来。 问： 我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？ 答： 试试就知道了。如果你试过，你既知道了答案，又不用浪费我的时间了。 问： 我的{程序、配置、SQL 语句}不运行了 答： 这不是一个问题，我也没有兴趣去猜你有什么问题──我有更要紧的事要做。看到这种东西，我的反应一般如下： 你还有什么补充吗？ 噢，太糟了，希望你能搞定。 这跟我究竟有什么关系？ 问： 我的视窗电脑出问题了，你能帮忙吗？ 答： 是的，把视窗垃圾删了，装个象 Linux 或 BSD 的开源操作系统吧。 注意：如果程序有官方的视窗版或者与视窗有交互(如 Samba)，你 可以 问与视窗相关的问题，只是别对问题是由视窗操作系统而不是程序本身造成的回复感到惊讶，因为视窗一般来说太差，这种说法一般都成立。 问： 我的程序不运行了，我认为系统工具 X 有问题 答： 你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文档作后盾。 问： 我安装 Linux 或 X 遇到困难，你能帮忙吗？ 答： 不行，我需要亲手操作你的电脑才能帮你排错，去向当地的 Linux 用户组寻求方便的帮助（你可以在 这里 找到用户组列表） 注意：如果安装问题与某 Linux 发行版有关，在针对 它 的邮件列表、论坛或本地用户组织中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 “linux”和 所有 被怀疑的硬件 [作关键词] 仔细搜索。 问： 我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？ 答： 想做这种事情说明你是个卑劣的家伙，想让黑客教你做这种事情说明你是个白痴。 好问题与坏问题 最后，我将通过举例来演示提问的智慧。同样的问题两种提法，一种愚蠢，另一种明智。 愚蠢：我在哪能找到关于 Foonly Flurbamatic 设备的东西？ 这个问题在乞求得到 “搜搜该死的网络”（STFW） 式的回复。 明智： 我用谷歌搜索过“Foonly Flurbamatic 2600”，但没有找到什么有用的，有谁知道在哪能找到这种设备的编程信息？ 这个人已经搜索过网络了，而且听起来他可能真的遇到了问题。 愚蠢： 我不能编译某项目的源代码，它为什么这么破？ 提问者假设是别人搞砸了，太自大了。 明智： 某项目的源代码不能在某 Linux 6.2 版下编译。我读了常见问题文档，但其中没有与某 Linux 相关的内容。这是编译时的记录，我做错了什么吗？ 提问者已经指明了运行环境，读了常见问题文档（FAQ），列出了错误，也没有假设问题是别人的过错，这家伙值得注意。 愚蠢： 我的主板有问题，谁能帮我？ 某黑客对此的反应可能是：“是的，还需要帮你拍背和换尿布吗？”，然后是敲下删除键。 明智： 我在 S2464 主板上试过 X、Y 和 Z，当它们都失败后，又试了 A、B 和 C。注意我试 C 时的奇怪症状，显然某某东西正在做某某事情，这不是期望的行为。通常在 Athlon MP 主板上导致某某事情的原因是什么？有谁知道我还能再试点什么以确定问题？ 相反地，这个人看来值得回答。他或她展现了解决问题的能力而不是坐等天上掉馅饼。 在最后那个问题中，注意“给我一个回答”与“请帮我看看我还能再做点什么测试以得到启发”之间细微但重要的差别。 事实上，最后那个问题基本上源于 2001 年 8 月 Linux 内核邮件列表（lkml）上的真实事件，是我（Eric）当时提了那个问题，我发现 Tyan S2462 主板有神秘的死机现象，邮件列表成员给我提供了解决此问题的关键信息。 通过这种提问方式，我给了别人可以咀嚼玩味的东西。我设法使之对参与者既轻松又有吸引力，也表明了对同行能力的尊敬并邀请他们与我一起协商。通过告诉他们我已经走过的弯路，我还表明了对他们宝贵时间的尊重。 事后，当我感谢大家并评论这次良好的经历时，一个 Linux 内核邮件列表的成员谈到，他认为我得到答案并不是因为我的名字挂在列表上，而只是因为我正确的提问方式。 黑客们在某种方面是非常不留情面的精英分子。我想在这事上他是对的，如果我 表现得 象个不劳而获的寄生虫，不管我是谁都会被忽略或斥责。他建议将整个事件作为对其它人提问的指导，这直接导致了本文的编写。 如果得不到回答 如果得不到回答，请不要认为我们不想帮你，有时只是因为被问到的小组成员的确不知道答案。没有回复不等于不被理睬，当然必须承认从外面很难看出两者的差别。 一般而言，直接将问题再张贴一次不好，这会被视为毫无意义的骚扰。耐心一点，知道你问题答案的人可能生活在不同的时区，有可能正在睡觉，也有可能你的问题一开始就没有组织好。 还有其它资源可以寻求帮助，通常是在一些面向新手的资源中。 有许多在线与本地的用户组织，虽然它们自己不编写任何软件，但是对软件很热心。这些用户组通常因互助和帮助新手而形成。 还有众多大小商业公司提供签约支持服务，别因为要付点钱才有支持就感到沮丧！毕竟，如果你车子的汽缸垫烧了，你多半还得花钱找个修理店把它弄好。即使软件没花你一分钱，你总不能指望服务支持都是免费的。 象 Linux 这样流行的软件，每个开发者至少有一万个以上的用户，一个人不可能应付这么多用户的服务要求。记住，即使你必须付费才能得到支持，也比你还得额外花钱买软件要少得多（而且对封闭源代码软件的服务支持与开源软件相比通常还要贵一点，也要差一点）。 如何更好地回答 态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。 对初犯者私下回复。 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找 FAQ 都不知道。 如果你不确定，一定要说出来！ 一个听起来权威的错误回复比没有还要糟，别因为听起来象个专家好玩就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。 如果帮不了忙，别妨碍。 不要在具体步骤上开玩笑，那样也许会毁了用户的安装──有些可怜的呆瓜会把它当成真的指令。 探索性的反问以引出更多的细节。 如果你做得好，提问者可以学到点东西──你也可以。试试将很差的问题转变成好问题，别忘了我们都曾是新手。 尽管对那些懒虫报怨一声“读读该死的手册”（RTFM）是正当的，指出文档的位置（即使只是建议做个谷歌关键词搜索）会更好 如果你决意回答，给出好的答案。 当别人正在用错误的工具或方法时别建议笨拙的权宜之计，应推荐更好的工具，重新组织问题。 请回答真正的问题！如果提问者已经做了自己该做的研究，并且说明尝试过 X，Y，Z，A，B 与 C 都没有得到想要的結果，那么回复 试试 A 或 B 或者给出一个内容为 试一下 X，Y，Z，A，B 或 C 的链接将极其无益！ 帮助你的社区从中学习。当回复一个好问题时，问问自己 如何修改相关文件或 FAQ 文档以免再次解答同样的问题？，接着再向文档维护者发一份补丁。 如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟“授人以鱼，不如授人以渔”。 相关资源 如果需要个人电脑、Unix 和互联网如何工作的基础知识，参阅 Unix 和互联网工作的基本原理。 当你发布软件或补丁时，试着按 软件发布实践 操作。 鸣谢 伊夫林.米切尔（Evelyn Mitchell）贡献了一些愚蠢问题例子并启发了编写如何更好地回答问题这一节，米哈伊尔.罗门迪克（Mikhail Ramendik）贡献了一些特别有价值的建议和改进。","categories":[{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog1.cpen.top/tags/GitHub/"},{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"学习","slug":"学习","permalink":"https://blog1.cpen.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"03_转载-中文文案排版指北","slug":"转载/03_转载-GitHub-中文文案排版指北","date":"2023-05-01T04:00:00.000Z","updated":"2023-05-01T05:00:00.000Z","comments":true,"path":"posts/3e42a4ef.html","permalink":"https://blog1.cpen.top/posts/3e42a4ef.html","excerpt":"","text":"原文：https://github.com/sparanoid/chinese-copywriting-guidelines 统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。 空格 「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」——vinta/paranoid-auto-spacing 中英文之间需要增加空格 正确： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。 错误： 在LeanCloud上，数据存储是围绕AVObject进行的。 在 LeanCloud上，数据存储是围绕AVObject 进行的。 完整的正确用法： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。 例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。 中文与数字之间需要增加空格 正确： 今天出去买菜花了 5000 元。 错误： 今天出去买菜花了 5000元。 今天出去买菜花了5000元。 数字与单位之间需要增加空格 正确： 我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB 错误： 我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB 例外：度数／百分比与数字之间不需要增加空格： 正确： 角度为 90° 的角，就是直角。 新 MacBook Pro 有 15% 的 CPU 性能提升。 错误： 角度为 90 ° 的角，就是直角。 新 MacBook Pro 有 15 % 的 CPU 性能提升。 全角标点与其他字符之间不加空格 正确： 刚刚买了一部 iPhone，好开心！ 错误： 刚刚买了一部 iPhone ，好开心！ 刚刚买了一部 iPhone， 好开心！ 用 text-spacing 来挽救？ CSS Text Module Level 4 的 text-spacing 和 Microsoft 的 -ms-text-autospace 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。 标点符号 不重复使用标点符号 虽然中国大陆的标点符号用法允许重复使用标点符号，但是这么做会破坏句子的美观性。 正确： 德国队竟然战胜了巴西队！ 她竟然对你说「喵」？！ 错误： 德国队竟然战胜了巴西队！！ 德国队竟然战胜了巴西队！！！！！！！！ 她竟然对你说「喵」？？！！ 她竟然对你说「喵」？！？！？？！！ 全角和半角 不明白什么是全角（全形）与半角（半形）符号？请查看维基百科条目『全角和半角』。 使用全角中文标点 正确： 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！ 核磁共振成像（NMRI）是什么原理都不知道？JFGI！ 错误： 嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！ 嗨!你知道嘛?今天前台的小妹跟我说&quot;喵&quot;了哎！ 核磁共振成像 (NMRI) 是什么原理都不知道? JFGI! 核磁共振成像(NMRI)是什么原理都不知道?JFGI! 例外：中文句子内夹有英文书籍名、报刊名时，不应借用中文书名号，应以英文斜体表示。 数字使用半角字符 正确： 这个蛋糕只卖 1000 元。 错误： 这个蛋糕只卖 １０００ 元。 例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。 遇到完整的英文整句、特殊名词，其内容使用半角标点 正确： 乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」 推荐你阅读 Hackers &amp; Painters: Big Ideas from the Computer Age，非常地有趣。 错误： 乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」 推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。 名词 专有名词使用正确的大小写 大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。 正确： 使用 GitHub 登录 我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。 错误： 使用 github 登录 使用 GITHUB 登录 使用 Github 登录 使用 gitHub 登录 使用 gｲんĤЦ8 登录 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。 我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。 我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。 我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。 我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。 注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。 不要使用不地道的缩写 正确： 我们需要一位熟悉 TypeScript、HTML5，至少理解一种框架（如 React、Next.js）的前端开发者。 错误： 我们需要一位熟悉 Ts、h5，至少理解一种框架（如 RJS、nextjs）的 FED。 争议 以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。 链接之间增加空格 用法： 请 提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请 点击这里 进行订阅！ 对比用法： 请提交一个 issue并分配给相关同事。 访问我们网站的最新动态，请点击这里进行订阅！ 简体中文使用直角引号 用法： 「老师，『有条不紊』的『紊』是什么意思？」 对比用法： “老师，‘有条不紊’的‘紊’是什么意思？” 工具 仓库 系列 语言 pangu.js pangu JavaScript pangu-go Go pangu.java Java pangu.py Python pangu.rb Ruby pangu.php PHP pangu.vim Vim vue-pangu Vue.js (Web Converter) intellij-pangu Intellij Platform Plugin autocorrect autocorrect Rust, WASM, CLI tool autocorrect-node Node.js autocorrect-py Python autocorrect-rb Ruby autocorrect-java Java autocorrect-go Go autocorrect-php PHP autocorrect-vscode VS Code Extension autocorrect-idea-plugin Intellij Platform Plugin jxlwqq/chinese-typesetting other PHP sparanoid/space-lover PHP (WordPress) sparanoid/grunt-auto-spacing Node.js (Grunt) hjiang/scripts/add-space-between-latin-and-cjk Python hustcc/hint n0vad3v/Tekorrect 谁在这样做？ 网站 文案 UGC Apple 中国 是 N/A Apple 香港 Apple 台湾 V2EX 是 Apple4us N/A Ruby China 是 少数派 N/A 参考文献 Guidelines for Using Capital Letters - ThoughtCo. Letter case - Wikipedia Punctuation - Oxford Dictionaries Punctuation - The Purdue OWL How to Use English Punctuation Correctly - wikiHow 格式 - openSUSE 全形和半形 - 维基百科 引号 - 维基百科 疑问惊叹号 - 维基百科 Forks 衍生项目的用法可能与本项目存在差异。 mzlogin/chinese-copywriting-guidelines","categories":[{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog1.cpen.top/tags/GitHub/"},{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"学习","slug":"学习","permalink":"https://blog1.cpen.top/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"11_Hexo-GitHub Actions 自动部署博客","slug":"Hexo/11_Hexo-GitHubActions自动部署博客","date":"2023-04-04T04:00:00.000Z","updated":"2023-10-11T05:00:00.000Z","comments":true,"path":"posts/8b765f7a.html","permalink":"https://blog1.cpen.top/posts/8b765f7a.html","excerpt":"","text":"简单记录，步骤潦草 示例 1. .gitignore 根路径 .gitignore 内容 1234567891011.DS_Store#/Thumbs.db/db.json*.lognode_modules/public/.deploy*/.deploy_git/.deploy_git*/.ideathemes/butterfly/.git 2. workflows 根路径 .github/workflows/autodeploy.yml 内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970name: Auto deploy# 当有改动推送到master分支时，启动Actionon: workflow_dispatch: push: branches: - mainjobs: deploy: runs-on: ubuntu-latest steps: - name: 检查分支 uses: actions/checkout@v2 with: ref: main - uses: szenius/set-timezone@v1.0 # 设置执行环境的时区 with: timezoneLinux: &quot;Asia/Shanghai&quot; - name: 安装 Node uses: actions/setup-node@v1 with: node-version: &quot;18.x&quot; - name: 安装 Hexo run: | export TZ=&#x27;Asia/Shanghai&#x27; npm install hexo-cli -g - name: 缓存 Hexo uses: actions/cache@v4 id: cache with: path: node_modules key: $&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125; - name: 安装依赖 if: steps.cache.outputs.cache-hit != &#x27;true&#x27; run: | npm install gulp-cli -g #全局安装gulp npm install --save - name: Generate static file run: | hexo clean ; hexo generate ; gulp - name: 推送百度 url run: | hexo deploy - name: Deploy static file run: | cd ./public git init git config --global user.email &#x27;github-actions[bot]@users.noreply.github.com&#x27; git config --global user.name &#x27;github-actions[bot]&#x27; git add . git commit -m &quot;$(date +&#x27;%Y/%m/%d&#x27;)&quot; git push --force --quiet &quot;https://mycpen:$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@github.com/mycpen/blog.git&quot; master:main - name: Delete workflow runs uses: Mattraks/delete-workflow-runs@v2 with: token: $&#123;&#123; secrets.GH_TOKEN &#125;&#125; repository: $&#123;&#123; github.repository &#125;&#125; retain_days: 30 keep_minimum_runs: 6 Actions Secrets 变量含义 Secrets 变量 释义 GH_TOKEN GitHub Token 3. 插件 hexo-baidu-url-submit：https://github.com/huiwang/hexo-baidu-url-submit 根路径 _config.yml 配置文件 123456789101112# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: - type: baidu_url_submitter # 这是新加的百度主动推送# 百度主动推送# https://github.com/huiwang/hexo-baidu-url-submitbaidu_url_submit: count: 1000 # 提交最新的多少个链接 host: blog.xxx.com # 在百度站长平台中添加的域名 token: xxxxxx # 秘钥 path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里 参考 Akilar | 使用Github Action实现全自动部署 安知鱼 | hexo博客工作流CI（一键部署的快乐） CCKNBC | 工作流示例 https://github.com/Mattraks/delete-workflow-runs https://github.com/dmego/home.github.io/blob/gh-pages/.github/workflows/auto-bing.yml","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://blog1.cpen.top/tags/GitHub/"}]},{"title":"10_Hexo-GitHub Actions 自动刷新多吉云 CDN 缓存","slug":"Hexo/10_Hexo-GitHubActions自动刷新多吉云CDN","date":"2023-04-03T04:00:00.000Z","updated":"2023-04-03T05:00:00.000Z","comments":true,"path":"posts/6f7759e0.html","permalink":"https://blog1.cpen.top/posts/6f7759e0.html","excerpt":"","text":"前言 之前一直通过 多吉云控制台 手动刷新博客全站 CDN 缓存，CDN 源站为 Vercel 部署的网址 由 空梦：全自动博客部署方案 这篇文章萌生了自动化的念头，且这些 CDN 服务商都提供了相应的 API 文档和代码样例，开箱即用 仓库示例：https://github.com/mycpen/blog/tree/main/.github 个人示例 1. 新增 Workflow 文件 以我为例，新增 source/.github/workflows/refresh-dogecloud.yml 文件，内容如下： 123456789101112131415161718192021222324252627282930313233# This workflow will install Python dependencies, run tests and lint with a single version of Python# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-pythonname: Refresh dogecloud CDNon: push: branches: - main workflow_dispatch:jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: szenius/set-timezone@v1.0 # 设置执行环境的时区 with: timezoneLinux: &quot;Asia/Shanghai&quot; - name: Set up Python 3.10 uses: actions/setup-python@v3 with: python-version: &quot;3.10&quot; - name: Wait for 3 minutes run: sleep 180 # 等待 3 分钟，单位为秒 - name: Run refresh script env: ACCESS_KEY: $&#123;&#123; secrets.ACCESS_KEY &#125;&#125; SECRET_KEY: $&#123;&#123; secrets.SECRET_KEY &#125;&#125; run: | pip install requests python .github/refresh-dogecloud.py 2. 新增 PY 脚本：刷新缓存 以我为例，新增 source/.github/refresh-dogecloud.py 文件，内容如下： 脚本里的 url_list 为需要刷新的目录，需手动修改为自己的。代码来自多吉云 API 验证、刷新目录任务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from hashlib import sha1import hmacimport requestsimport jsonimport urllibimport osdef dogecloud_api(api_path, data=&#123;&#125;, json_mode=False): &quot;&quot;&quot; 调用多吉云API :param api_path: 调用的 API 接口地址，包含 URL 请求参数 QueryString，例如：/console/vfetch/add.json?url=xxx&amp;a=1&amp;b=2 :param data: POST 的数据，字典，例如 &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;，传递此参数表示不是 GET 请求而是 POST 请求 :param json_mode: 数据 data 是否以 JSON 格式请求，默认为 false 则使用表单形式（a=1&amp;b=2） :type api_path: string :type data: dict :type json_mode bool :return dict: 返回的数据 &quot;&quot;&quot; # 这里替换为你的多吉云永久 AccessKey 和 SecretKey，可在用户中心 - 密钥管理中查看 # 请勿在客户端暴露 AccessKey 和 SecretKey，否则恶意用户将获得账号完全控制权 access_key = os.environ[&quot;ACCESS_KEY&quot;] secret_key = os.environ[&quot;SECRET_KEY&quot;] body = &#x27;&#x27; mime = &#x27;&#x27; if json_mode: body = json.dumps(data) mime = &#x27;application/json&#x27; else: body = urllib.parse.urlencode(data) # Python 2 可以直接用 urllib.urlencode mime = &#x27;application/x-www-form-urlencoded&#x27; sign_str = api_path + &quot;\\n&quot; + body signed_data = hmac.new(secret_key.encode(&#x27;utf-8&#x27;), sign_str.encode(&#x27;utf-8&#x27;), sha1) sign = signed_data.digest().hex() authorization = &#x27;TOKEN &#x27; + access_key + &#x27;:&#x27; + sign response = requests.post(&#x27;https://api.dogecloud.com&#x27; + api_path, data=body, headers = &#123; &#x27;Authorization&#x27;: authorization, &#x27;Content-Type&#x27;: mime &#125;) return response.json()url_list = [ &quot;https://cpen.top/&quot;,]api = dogecloud_api(&#x27;/cdn/refresh/add.json&#x27;, &#123; &#x27;rtype&#x27;: &#x27;path&#x27;, &#x27;urls&#x27;: json.dumps(url_list)&#125;)if api[&#x27;code&#x27;] == 200: print(api[&#x27;data&#x27;][&#x27;task_id&#x27;])else: print(&quot;api failed: &quot; + api[&#x27;msg&#x27;]) # 失败 3. 新增 Secrets 变量 Actions 新增 2 个 Secrets 变量，ACCESS_KEY、SECRET_KEY，对应的值在 多吉云 用户中心 - 密钥管理 中查看。link 避免因权限问题导致工作流执行失败，也可以设置下 Actions 读写权限 4. 新增 JS 代码：复制 .github 前言：source/.github 这类 . 开头的隐藏文件默认是不会被 hexo generate 渲染生成到 public 目录下的。网上和 ChatGPT 给出的解决办法大多试了（如 skip_render），没有生效，打算直接用 JS 代码将 source/.github 目录复制到 public/.github 目录下。以下代码每次 hexo generate 之后能实现复制的效果 以我为例，新增 scripts/before_generate.js 文件，内容如下： 123456789101112131415161718192021222324252627const fs = require(&#x27;fs-extra&#x27;);const path = require(&#x27;path&#x27;);function copyFolder(source, target) &#123; // Create the target folder if it doesn&#x27;t exist fs.ensureDirSync(target); // Get the list of files in the source folder const files = fs.readdirSync(source); // Loop through each file and copy it to the target folder files.forEach((file) =&gt; &#123; const sourcePath = path.join(source, file); const targetPath = path.join(target, file); if (fs.statSync(sourcePath).isDirectory()) &#123; // Recursively copy subfolders copyFolder(sourcePath, targetPath); &#125; else &#123; // Copy the file fs.copyFileSync(sourcePath, targetPath); &#125; &#125;);&#125;copyFolder(&#x27;./source/.github&#x27;, &#x27;./public/.github&#x27;); 5. 更新 _config.yml 配置 当 hexo deploy 将渲染后的静态仓库推送到 Github 时，默认会取消推送 . 开头的隐藏文件，具体如下： 在 Hexo 配置文件 _config.yml 进行修改，新增 git 部署器 ignore_hidden 配置项，样例如下： 12345678910# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: - type: git repository: git@github.com:mycpen/blog.git branch: main commit: Site updated message: &quot;&#123;&#123; now(&#x27;YYYY/MM/DD&#x27;) &#125;&#125;&quot;+ ignore_hidden: false 参考链接 多吉云：API 验证机制（Python） 多吉云：SDK 文档 - 刷新预热 ChatGPT（deploy.ignore_hidden、js 代码 复制目录、sleep）","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://blog1.cpen.top/tags/GitHub/"}]},{"title":"08_Other-GitHub Actions 定时执行脚本，备份又拍云云存储","slug":"Other/08_Other-GithubAction同步又拍云图床","date":"2023-04-02T04:00:00.000Z","updated":"2023-04-02T05:00:00.000Z","comments":true,"path":"posts/acb8c062.html","permalink":"https://blog1.cpen.top/posts/acb8c062.html","excerpt":"","text":"前言 使用 GitHub Acitons，定时跑 Python FTP 脚本，达到 又拍云云存储 与 GitHub 仓库间的备份 仓库示例：https://github.com/mycpen/image_bed/tree/main/.github 个人示例 1. 新增 Workflow YML 文件 复制以下我的 yml 示例；或是按照 这篇文章，选择想要的 workflow 模板，再自定义修改内容（Actions =&gt; New workflow = Choose a workflow） 我的文件路径为 .github/workflows/python-app.yml，内容如下： 12345678910111213141516171819202122232425262728293031323334# This workflow will install Python dependencies, run tests and lint with a single version of Python# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-pythonname: Python applicationon: schedule: - cron: &quot;0 17 * * 5&quot; # 周六 1:00 workflow_dispatch:jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: szenius/set-timezone@v1.0 # 设置执行环境的时区 with: timezoneLinux: &quot;Asia/Shanghai&quot; - name: Set up Python 3.10 uses: actions/setup-python@v3 with: python-version: &quot;3.10&quot; - name: Run sync script env: UPYUNUSERNAME: $&#123;&#123; secrets.UPYUNUSERNAME &#125;&#125; UPYUNPASSWORD: $&#123;&#123; secrets.UPYUNPASSWORD &#125;&#125; run: | git config --global user.name $&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125; git config --global user.email $&#123;&#123; secrets.GITHUBEMAIL &#125;&#125; python .github/ftp.py bash git.sh 参数解释： cron：定义工作流的时间表（有延迟），为格林尼治时间（UTC），换算为北京时间需在该基础上增加 8 小时，参考：Actions 中的 cron 格式和设置、Actions 时区及缓存问题处理 UPYUNUSERNAME, UPYUNPASSWORD, GITHUBUSERNAME, GITHUBEMAIL，为自定义的 Secrets 变量 变量名 释义 UPYUNUSERNAME 又拍云 FTP 用户名，格式「操作员名/服务名」，参考 又拍云视频教程、又拍云文档 UPYUNPASSWORD 又拍云 FTP 密码，参考同上 GITHUBUSERNAME GitHub 账号，如 mycpen GITHUBEMAIL GitHub 账号绑定的主邮箱 ftp.py：Python 脚本，使用 FTP 同步云存储与仓库的文件内容 git.sh：将本地变更推送至远端的脚本，git add, git commit, git push 这类 2. 新增 Secrets 变量 新增 4 个 Secrets 变量，UPYUNUSERNAME、UPYUNPASSWORD、GITHUBUSERNAME、GITHUBEMAIL，具体含义同上 3. 授予 Workflow 读写权限 参考：https://blog.csdn.net/jj89929665/article/details/129817011 4. 新建 Python 同步脚本 脚本内容来自：Python实现的FTP上传和下载功能 脚本最后的 if 语句中声明了相关路径和参数 我的脚本路径为 .github/ftp.py，作用是同步仓库 image/ 目录与又拍云云存储 /image/ 目录，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294#!/usr/bin/python# -*- coding: UTF-8 -*-from cmath import logfrom ftplib import FTPimport osimport sysimport timeimport socketimport subprocessclass MyFTP: &quot;&quot;&quot; ftp自动下载、自动上传脚本，可以递归目录操作 作者：欧阳鹏 博客地址：http://blog.csdn.net/ouyang_peng/article/details/79271113 &quot;&quot;&quot; def __init__(self, host, port=21): &quot;&quot;&quot; 初始化 FTP 客户端 参数: host:ip地址 port:端口号 &quot;&quot;&quot; # print(&quot;__init__()---&gt; host = %s ,port = %s&quot; % (host, port)) self.host = host self.port = port self.ftp = FTP() # 重新设置下编码方式 #self.ftp.encoding = &#x27;gbk&#x27; self.ftp.encoding = &#x27;utf8&#x27; # 获取脚本路径 path = os.path.dirname(os.path.realpath(__file__)) # self.log_file = open(path + &quot;/log.txt&quot;, &quot;a&quot;, encoding=&#x27;utf-8&#x27;) self.file_list = [] def login(self, username, password): &quot;&quot;&quot; 初始化 FTP 客户端 参数: username: 用户名 password: 密码 &quot;&quot;&quot; try: timeout = 60 socket.setdefaulttimeout(timeout) # 0主动模式 1 #被动模式 self.ftp.set_pasv(True) # 打开调试级别2，显示详细信息 # self.ftp.set_debuglevel(2) self.debug_print(&#x27;开始尝试连接到 %s&#x27; % self.host) self.ftp.connect(self.host, self.port) self.debug_print(&#x27;成功连接到 %s&#x27; % self.host) self.debug_print(&#x27;开始尝试登录到 %s&#x27; % self.host) self.ftp.login(username, password) self.debug_print(&#x27;成功登录到 %s&#x27; % self.host) self.debug_print(self.ftp.welcome) except Exception as err: self.deal_error(&quot;FTP 连接或登录失败 ，错误描述为：%s&quot; % err) pass def is_same_size(self, local_file, remote_file): &quot;&quot;&quot;判断远程文件和本地文件大小是否一致 参数: local_file: 本地文件 remote_file: 远程文件 &quot;&quot;&quot; try: remote_file_size = self.ftp.size(remote_file) except Exception as err: # self.debug_print(&quot;is_same_size() 错误描述为：%s&quot; % err) remote_file_size = -1 try: local_file_size = os.path.getsize(local_file) except Exception as err: # self.debug_print(&quot;is_same_size() 错误描述为：%s&quot; % err) local_file_size = -1 self.debug_print(&#x27;local_file_size:%d , remote_file_size:%d&#x27; % (local_file_size, remote_file_size)) if remote_file_size == local_file_size: return 1 else: return 0 def download_file(self, local_file, remote_file): &quot;&quot;&quot;从ftp下载文件 参数: local_file: 本地文件 remote_file: 远程文件 &quot;&quot;&quot; self.debug_print(&quot;download_file()---&gt; local_path = %s ,remote_path = %s&quot; % (local_file, remote_file)) if self.is_same_size(local_file, remote_file): self.debug_print(&#x27;%s 文件大小相同，无需下载&#x27; % local_file) return else: try: self.debug_print(&#x27;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;下载文件 %s ... ...&#x27; % local_file) buf_size = 1024 file_handler = open(local_file, &#x27;wb&#x27;) self.ftp.retrbinary(&#x27;RETR %s&#x27; % remote_file, file_handler.write, buf_size) file_handler.close() except Exception as err: self.debug_print(&#x27;下载文件出错，出现异常：%s &#x27; % err) return def download_file_tree(self, local_path, remote_path): &quot;&quot;&quot;从远程目录下载多个文件到本地目录 参数: local_path: 本地路径 remote_path: 远程路径 &quot;&quot;&quot; print(&quot;download_file_tree()---&gt; local_path = %s ,remote_path = %s&quot; % (local_path, remote_path)) try: self.ftp.cwd(remote_path) except Exception as err: self.debug_print(&#x27;远程目录%s不存在，继续...&#x27; % remote_path + &quot; ,具体错误描述为：%s&quot; % err) return if not os.path.isdir(local_path): self.debug_print(&#x27;本地目录%s不存在，先创建本地目录&#x27; % local_path) os.makedirs(local_path) self.debug_print(&#x27;切换至目录: %s&#x27; % self.ftp.pwd()) self.file_list = [] # 方法回调 self.ftp.dir(self.get_file_list) remote_names = self.file_list self.debug_print(&#x27;远程目录 列表: %s&#x27; % remote_names) for item in remote_names: file_type = item[0] file_name = item[1] local = os.path.join(local_path, file_name) if file_type == &#x27;d&#x27;: print(&quot;download_file_tree()---&gt; 下载目录： %s&quot; % file_name) self.download_file_tree(local, file_name) elif file_type == &#x27;-&#x27;: print(&quot;download_file()---&gt; 下载文件： %s&quot; % file_name) self.download_file(local, file_name) self.ftp.cwd(&quot;..&quot;) self.debug_print(&#x27;返回上层目录 %s&#x27; % self.ftp.pwd()) return True def upload_file(self, local_file, remote_file): &quot;&quot;&quot;从本地上传文件到ftp 参数: local_path: 本地文件 remote_path: 远程文件 &quot;&quot;&quot; if not os.path.isfile(local_file): self.debug_print(&#x27;%s 不存在&#x27; % local_file) return if self.is_same_size(local_file, remote_file): self.debug_print(&#x27;跳过相等的文件: %s&#x27; % local_file) return buf_size = 1024 file_handler = open(local_file, &#x27;rb&#x27;) self.ftp.storbinary(&#x27;STOR %s&#x27; % remote_file, file_handler, buf_size) file_handler.close() self.debug_print(&#x27;上传: %s&#x27; % local_file + &quot;成功!&quot;) def upload_file_tree(self, local_path, remote_path): &quot;&quot;&quot;从本地上传目录下多个文件到ftp 参数: local_path: 本地路径 remote_path: 远程路径 &quot;&quot;&quot; if not os.path.isdir(local_path): self.debug_print(&#x27;本地目录 %s 不存在&#x27; % local_path) return self.ftp.cwd(remote_path) self.debug_print(&#x27;切换至远程目录: %s&#x27; % self.ftp.pwd()) local_name_list = os.listdir(local_path) for local_name in local_name_list: src = os.path.join(local_path, local_name) if os.path.isdir(src): try: self.ftp.mkd(local_name) except Exception as err: self.debug_print(&quot;目录已存在 %s ,具体错误描述为：%s&quot; % (local_name, err)) self.debug_print(&quot;upload_file_tree()---&gt; 上传目录： %s&quot; % local_name) self.upload_file_tree(src, local_name) else: self.debug_print(&quot;upload_file_tree()---&gt; 上传文件： %s&quot; % local_name) self.upload_file(src, local_name) self.ftp.cwd(&quot;..&quot;) def close(self): &quot;&quot;&quot; 退出ftp &quot;&quot;&quot; self.debug_print(&quot;close()---&gt; FTP退出&quot;) self.ftp.quit() # self.log_file.close() def debug_print(self, s): &quot;&quot;&quot; 打印日志 &quot;&quot;&quot; self.write_log(s) def deal_error(self, e): &quot;&quot;&quot; 处理错误异常 参数： e：异常 &quot;&quot;&quot; log_str = &#x27;发生错误: %s&#x27; % e self.write_log(log_str) sys.exit() def write_log(self, log_str): &quot;&quot;&quot; 记录日志 参数： log_str：日志 &quot;&quot;&quot; time_now = time.localtime() date_now = time.strftime(&#x27;%Y-%m-%d&#x27;, time_now) format_log_str = &quot;%s ---&gt; %s \\n &quot; % (date_now, log_str) print(format_log_str) # self.log_file.write(format_log_str) def get_file_list(self, line): &quot;&quot;&quot; 获取文件列表 参数： line： &quot;&quot;&quot; file_arr = self.get_file_name(line) # 去除 . 和 .. if file_arr[1] not in [&#x27;.&#x27;, &#x27;..&#x27;]: self.file_list.append(file_arr) def get_file_name(self, line): &quot;&quot;&quot; 获取文件名 参数： line： &quot;&quot;&quot; pos = line.rfind(&#x27;:&#x27;) while (line[pos] != &#x27; &#x27;): pos += 1 while (line[pos] == &#x27; &#x27;): pos += 1 file_arr = [line[0], line[pos:]] return file_arrif __name__ == &quot;__main__&quot;: # 清除日志 path = os.path.dirname(os.path.realpath(__file__)) # 脚本路径 # if os.path.exists(path + &#x27;/log.txt&#x27;): # log_file = path + &#x27;/log.txt &#x27;if os.sep == &quot;/&quot; else path + &#x27;\\\\&#x27; + &#x27;log.txt&#x27; # subprocess.Popen(f&#x27;rm -rf &#123;log_file&#125;&#x27;, shell=True) # time.sleep(1) # 获取 Actions Secrets 变量 upyunUsername = os.environ[&quot;UPYUNUSERNAME&quot;] upyunPassword = os.environ[&quot;UPYUNPASSWORD&quot;] my_ftp = MyFTP(&quot;v0.ftp.upyun.com&quot;) my_ftp.login(upyunUsername, upyunPassword) # 下载目录 # 又拍云云存储 → 本地 image/ if os.sep == &quot;\\\\&quot;: # Windows pass elif os.sep == &quot;/&quot;: # Unix my_ftp.download_file_tree(&quot;image/&quot;, &quot;/image/&quot;) # image/ 仓库目录; /image/ 又拍云云存储目录 # 上传目录 # 本地 image/ → 又拍云云存储 if os.sep == &quot;\\\\&quot;: pass elif os.sep == &quot;/&quot;: my_ftp.upload_file_tree(&quot;image/&quot;, &quot;/image/&quot;) # image/ 仓库目录; /image/ 又拍云云存储目录 my_ftp.close() 5. git.sh 推送变更 个人习惯将 push 命令写在一个文件里，放在仓库根目录下 123456789#!/usr/bin/bash# 远端同步至本地git pull# 推送变更git add .git commit -m &quot;$(date +&#x27;%Y/%m/%d&#x27;)&quot;git push 参考文章 * GitHub Actions 中 python 脚本获取仓库 secrets * 使用github仓库创建定时任务，定时签到等服务 * Python实现的FTP上传和下载功能 * 使用Github Action实现全自动部署 * 又拍云：如何使用 FTP、API 上传文件 * 又拍云：创建存储服务和使用 FTP 上传 * Github/Gitlab Actions 中的 cron 格式和设置方法 * Github Actions 执行Python定时任务（时区及缓存问题处理） * 运行Github Actions unable to access ‘https://github.com/x/‘: The requested URL returned error: 403 * workflow_dispatch 白嫖github的Action做定时任务 Github+Action实现自动定时推送 基于github中action服务的自动化打包部署 基于GITHUB ACTION的定时任务，真香！ GitHub Actions 定时运行代码：每天定时百度链接推送","categories":[{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/categories/Other/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog1.cpen.top/tags/GitHub/"},{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/tags/Other/"},{"name":"FTP","slug":"FTP","permalink":"https://blog1.cpen.top/tags/FTP/"}]},{"title":"07_Other-文章记录-sshpass","slug":"Other/07_Other-文章记录","date":"2023-04-01T04:00:00.000Z","updated":"2023-10-05T05:00:00.000Z","comments":true,"path":"posts/cee83196.html","permalink":"https://blog1.cpen.top/posts/cee83196.html","excerpt":"","text":"前言 记录一些小知识点、工具、文章收藏 01. 链接收藏 地址 MyFreeMP3 Typora入门 Typora页面美化 Microsoft Store 中文文案排版指北 Git常见用法总结 ProcessOn 牛客网-面经-运开资料 JavaScript日期格式化，不足两位数补0 Molunerfinn 大佬面经 Akilar：Github Action自动部署 AutoPlan.哔哩升级 Jetbrains 激活方法 公众号二维码.下载 GitHub: BiliBiliToolPro Snipaste JPG 截图格式 倚栏听风.2023计算机保研经历总结 Veen Zhao.南师大.考研 批量删除微博博文 chatgpt账号-key购买 Veen Zhao.南师大.复试 网易云.安卓.dolby_beta.教程、下载、github 其他： 03_Other-PC端环境记录 非技术： 地址 酷壳：别让自己“墙”了自己 云服务器： 阿里云 ECS 99/年，活动期内（活动时间： 2023年10月31日0点0分0秒至2026年3月31日23点59分59秒。）续费同价，新老用户同享：https://www.aliyun.com/lowcode/promotion/allinaliyun/99program 阿里云在校学生300无门券/合作高校3折券领取：https://university.aliyun.com/ 02. sshpass 非交互登录 ssh 不能在命令行中指定密码 sshpass： 用于非交互的 ssh 密码验证，允许用 -p 参数指定明文密码 支持密码从命令行，文件，环境变量中读取 Ubuntu 报错 E: Unable to locate package sshpass apt-get update ; sudo apt-get install sshpass 参考文章：ssh快捷登录 sshpass+alias 登录脚本（第一次需 SSH 登录） 12345678$ cat ali.sh#!/bin/bashsshpass -p 密码 ssh -o ServerAliveinterval=60 root@IP# sshpass -p 密码 ssh root@IP$ chmod +x ali.sh -o option =&gt; Can be used to give options in the format used in the configuration file. ServerAliveinterval=60 client每隔60秒发送一次请求给server，然后server响应，从而保持连接（防止连接空闲超时） 定义别名 alias 123$ cat ~/.bashrc# User specific aliases and functionsalias ali=&#x27;bash /home/peng/sh_file/ali.sh&#x27; 参考文章： Shell 脚本 ssh免密码 登录 远程服务器 sshpass用法示例 Shell脚本免密码登录远程服务器（方法一） ssh快捷登录 sshpass+alias Linux – 将自己的shell脚本设置成命令 配置SSH服务远程连接空闲超时退出时间（包括SSH无法登录、登录缓慢） 03. Xftp 显示隐藏文件 参考文章：Xftp显示隐藏文件的方法 04. Github 多账户 SSH 配置 1ssh-keygen -f ~/.ssh/id_rsa_gh -C user_gh@gmail.com -b：指定 key 的 bit 数，对于 RSA key 而言，默认是 3072 bits -f：指定 key 的文件名，若需要指定路径，则文件名需要和路径一直，如 ~/.ssh/id_rsa_gh -C：指定新的 comment，即公钥末尾的字符串，一般是邮箱地址，若不指定会是 “username@hostname” 的形式 -t：指定私钥类型，一般有 “dsa”, “ecdsa”, “ecdsa-sk”, “ed25519”, “ed25519-sk” 和 “rsa” 等几种，若指定为 rsa 还可以指定签名类型，默认为 “rsa-sha2-512” Github 不同账户，类似配置 12345678910111213141516171819202122232425$ cat ~/.ssh/configHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/user1_rsa User user1Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/user2_rsa User user2------Host user_gh.github.com HostName github.com User user_gh IdentityFile ~/.ssh/id_rsa_ghHost github-qileq.com HostName github.com User qileq IdentityFile ~/.ssh/id_rsa_qileqHost gitlab.com HostName gitlab.com User user_gl IdentityFile ~/.ssh/id_rsa_gl Host 类型昵称，可以简化登录的输入地址，比如Host ccl,则可以用ssh ccl直接连接 HostName 表示连接的远程主机地址 IdentityFile 表示指定私钥文件路径 Port 指定端口 User 指定用户名 修改仓库的 git 信息，将仓库配置 url 的 http://github.com 替换为 ssh config 中设置的 Host 值。 笔者以 java-roam-guide 为例，使用如下两种方式来修改仓库地址： 执行命令 git remote set-url origin git@github-qileq.com:qileq/java-roam-guid.git 将该仓库 .git/config 中的 url = git@github.com:qileq/java-roam-guide.git 修改为 url = git@github-qileq.com:qileq/java-roam-guide.git 修改完成后，执行 git remote -v 查看仓库地址是否正确。 123456789101112131415# 当使用&lt;user1.github.com&gt;替换&lt;github.com&gt;进行访问时，ssh会自动识别为user1# 配置用户1Host user1.github.com # 别名，可以随便写一个url。 Hostname github.com # 网站真实的域名，如果是GitHub就不用改了 PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_user1 # 指向user1的私钥路径，似乎只能在~/.ssh下，不要随便放 User user1 # 填写user1的Github用户名，不过似乎最后获取的还是真实的Github用户名# 配置用户2Host user1.github.com Hostname github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_user2 # 指向user2的私钥路径，似乎只能在~/.ssh下，不要随便放 User user2 # 填写user2的GitHub用户名，不过似乎最后获取的还是真实的Github用户名 如果是直接使用 git@github.com，那么ssh将自动识别为config列表的第一个用户，可以认为是单用户模式 由于是多用户，所以在第一次clone一个GitHub地址的时候，需要简单的修改一下对应的域名，此时SSH将可以识别使用哪个用户进行操作，并建立配置记录 123456# 原始要clone的仓库命令git clone git@github.com:oneflyingfish/WebServer_C.git# 对应修改一下&lt;github.com&gt;，user1修改为上面配置的&lt;user1.github.com&gt;即可git clone git@user1.github.com:oneflyingfish/WebServer_C.git 多用户共用情况下，如果提示设置用户名，一定要设置为局部信息，而不是global。命令应修改为 12345678# git默认提示的命令git config --global user.name &quot;your_name&quot;git config --global user.email &quot;your_eamil&quot;# 我们应该使用的命令git config user.name &quot;your_name&quot;git config user.email &quot;your_eamil&quot; 参考文章： * SSH 多账号的配置 ssh config多账户/多域名配置 SSH Config 使用 Mac上配置多个SSH * 配置SSH keys连接GitHub（支持多用户） 解决 Git 同时部署到 GitHub 和 Gitee 时，密钥 SSH 冲突问题 05. APICloud 打包网页 未成功 APICloud =&gt; Web App 创建 图标 https://cdn.iocdn.cc/npm/mycpen-image-bed@0.0.0-2023/image/202304061700919.png 启动页 https://cdn.iocdn.cc/npm/mycpen-image-bed@0.0.0-2023/image/202304061700867.png 安装后的 APP 因无法开启存储空间权限，未能成功（个人原因，Fomalhaut🥝 的 APP 能设置） 参考教程：将网站 / 博客打包成桌面 APP、Fomalhaut🥝.留言 06. Hexo 渲染脚注 下文采用 hexo-renderer-markdown-it 渲染器（渲染脚注效果一般，不打算用脚注了） 尽管标准 Markdown 不支持脚注，但很多 Markdown 变种都支持。一般来说，大多数 Markdown 方言和编辑器支持行内脚注和引用式脚注这两种方式，而后者使用更为普遍（原文：在 Markdown 中使用引用式链接和脚注） 12npm uninstall --save hexo-renderer-markednpm install --save hexo-renderer-markdown-it 123markdown: plugins: - markdown-it-footnote 原文：我的博客的诞生（二） 12345678Here is a footnote reference,[^1] and another.[^longnote][^1]: Here is the footnote.[^longnote]: Here&#x27;s one with multiple blocks. Subsequent paragraphs are indented to show that theybelong to the previous footnote. 123Here is an inline note.^[Inlines notes are easier to write, sinceyou don&#x27;t have to pick an identifier and move down to type thenote.] 来源：markdown-it/markdown-it-footnote 个人配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# https://butterfly.js.org/posts/ceeb73f/#Math-%E6%95%B8%E5%AD%B8# https://www.nickxu.top/2022/04/17/Hexo-Butterfly-建站指南（八）使用-KaTeX-数学公式/# https://github.com/hexojs/hexo-renderer-markdown-it# https://ezgx.tk/posts/65320/markdown: preset: &#x27;default&#x27; render: html: true xhtmlOut: false langPrefix: &#x27;language-&#x27; breaks: true linkify: true typographer: true quotes: &#x27;“”‘’&#x27; enable_rules: disable_rules: plugins: - markdown-it-abbr # installed external plugins also can be enabled - markdown-it-table-of-contents - markdown-it-attrs # - markdown-it-cjk-breaks - markdown-it-container - markdown-it-deflist - markdown-it-emoji+ - markdown-it-footnote - markdown-it-ins - markdown-it-mark - markdown-it-sub - markdown-it-sup - markdown-it-checkbox - markdown-it-imsize - markdown-it-expandable - markdown-it-merge-cells - &#x27;@renbaoshuo/markdown-it-katex&#x27; # - @iktakahiro/markdown-it-katex # - name: &#x27;@neilsustc/markdown-it-katex&#x27; # enable: true # options: # strict: false # - markdown-it-toc-and-anchor - name: markdown-it-container options: success - name: markdown-it-container options: tips - name: markdown-it-container options: warning - name: markdown-it-container options: danger anchors: level: 1 collisionSuffix: &#x27;&#x27; permalink: false permalinkClass: &#x27;header-anchor&#x27; permalinkSide: &#x27;left&#x27; permalinkSymbol: &#x27;¶&#x27; case: 0 separator: &#x27;-&#x27; images: lazyload: false prepend_root: false post_asset: false 参考文章： 在 Markdown 中使用引用式链接和脚注 Markdown 脚注 百里飞洋 Barry-Flynn（得知脚注） hexojs/hexo-renderer-markdown-it * markdown-it/markdown-it-footnote * 我的博客的诞生（二） 07. Base64 加密邮箱 解密 加密的邮箱地址，使用 base64 加密。在线加密：https://encode.chahuo.com/ 解密 javascript:decryptEmail(...)，代码示例：https://www.mycpen.cn/ 1&lt;a href=&quot;javascript:decryptEmail(&#x27;bXljcGVuQHFxLmNvbQ==&#x27;);&quot; title=&quot;email&quot;&gt;&lt;/a&gt; 08. Word 转 MD（Pandoc） 1pandoc -xxx.docx -o xxx.md 一、下载pandoc 建议使用msi直接安装，而不是下载安装包直接使用，msi的下载方法：安装方法。 二、pandoc转换 1、cmd进入文件夹 打开cmd。 转换到文件所在的路径中。d:进入D盘的路径下，CD D:\\Program Files\\OneDrive\\桌面\\temp 2、代码实现 1pandoc -xxx.docx -o xxx.md # docx 文件转换为 md 文件 参考文章：word文件转md文件 09. GitHub 删除历史记录 12git reset &lt;上一步复制到的字符串&gt;git push -f 参考文章：GITHUB删除历史记录 10. ChatGPT API Key 个人站 项目地址： https://github.com/Chanzhaoyu/chatgpt-web https://github.com/Yidadaa/ChatGPT-Next-Web 参考文章： 无服务器部署自己的chatGPT 11. 字符画 consolo.log() 推荐：http://patorjk.com/software/taag 文字生成字符画： http://patorjk.com/software/taag http://www.network-science.de/ascii/ 图片生成字符画： http://www.degraeve.com/img2txt.php http://life.chacuo.net/convertphoto2char 流程图生成字符画： http://asciiflow.com/ VSCode 插件： https://github.com/OBKoro1/koro1FileHeader 参考：https://blog.saop.cc/p/c9df/ 12. ERR_HTTP2_PROTOCOL_ERROR 关闭 HSTS 访问网站，偶然性报错：ERR_HTTP2_PROTOCOL_ERROR。试着关闭 HSTS CDN HTTPS 配置 关闭 HSTS，多吉云个人链接 以下内容来自 ChatGPT： 问：ERR_HTTP2_PROTOCOL_ERROR 和 HSTS 有什么联系 问：HSTS 会导致 ERR_HTTP2_PROTOCOL_ERROR 报错吗 13. Clash Parsers 设置 =&gt; 配置 =&gt; 配置文件预处理 12345678parsers: # array - url: https://xxx.xxx/xxx yaml: prepend-rules: - DOMAIN-SUFFIX,xxx.com,香港Az-优化3 - DOMAIN-SUFFIX,xxx.com,GLOBAL - DOMAIN-SUFFIX,xxx.com,DIRECT 参考链接： * Clash for Windows：配置文件预处理 * Clash利用parsers进行规则预处理 * Clash使用Parser添加自定义规则并防止更新覆盖 clash for windows自定义规则（不会被更新覆盖） clash for windows如何设置指定IP或者网站才走xx? 14. Replit 部署 Typecho.TimePlus 步骤：https://github.com/zhheo/TimePlus/wiki/ Demo：https://plog.zhheo.com/ 在 Typecho 后台导航栏点击【撰写】，在自定义字段中填写图片地址。并填写文章标题和内容，即对应为图片的标题和简介。 搭建步骤： Replit Create a Repl，环境选 SQLite；参照 @valetzx/typechonreplit 执行 git clone https://github.com/valetzx/typechonreplit &amp;&amp; mv -b typechonreplit/* ./ &amp;&amp; mv -b typechonreplit/.[^.]* ./ &amp;&amp; rm -rf *~ &amp;&amp; rm -rf typechonreplit；注释 main.sh butterfly 相关行，bash main.sh；Run 运行；设置 Typecho 时选择 SQLite 数据库 按照 TimePlus.Wiki 设置，将 Source code 解压上传 Replit Repl 对应路径，按步骤设置 图片仓库批量获取图片 URL ls ./bj |awk '&#123;print &quot;https://mycpen.gitee.io/cdn2/image/bj/&quot;$1&quot;&quot;&#125;' &gt; C:/Users/Administrator/Desktop/TimePlus.txt Replit Repl 绑自定义域名，需先 TXT 记录认证（因验证问题无法使用 https） 相关链接： https://github.com/zhheo/TimePlus/wiki/ https://github.com/zhheo/TimePlus https://github.com/valetzx/typechonreplit https://blog.zhheo.com/p/bed74f41.html Replit 阿里云.DNS 15. Git 修改提交信息 2023-12-13 更新 使用 git rebase -i HEAD~&lt;n&gt; 修改最近某一次的提交信息，以下来自 chatgpt 当您执行 git rebase -i HEAD~&lt;n&gt; 命令时，会打开一个交互式的编辑器界面，列出最近 &lt;n&gt; 个提交。下面是一个示例，假设您要修改最近的前三次提交的提交信息： 123pick 1a2b3c4 Commit message 1pick 5d6e7f8 Commit message 2pick 9g0h1i2 Commit message 3 要修改提交信息，将每个提交的行的开头的 pick 改为 reword 或 r，然后保存并关闭编辑器。修改后的示例如下： 123reword 1a2b3c4 Commit message 1reword 5d6e7f8 Commit message 2reword 9g0h1i2 Commit message 3 保存并关闭编辑器后，Git 会逐个应用这些提交，并在每个提交之前暂停并等待您编辑提交信息。对于每个提交，Git 会打开一个新的编辑器窗口，允许您修改提交信息。完成修改后，保存并关闭编辑器。 请注意，如果在 rebase 过程中出现冲突，您需要解决冲突并使用 git add 命令将解决后的文件标记为已解决。然后，继续进行 rebase，直到所有提交都被处理完毕。 完成 rebase 后，您可以使用 git log 命令验证提交信息是否已成功修改。 1$ git log 如果要将修改的提交信息推送到远程仓库，您需要使用 git push --force 命令，因为您已经修改了历史提交。 1$ git push --force 请确保在进行此操作之前备份您的代码，并与团队成员进行沟通，以免影响其他人的工作。 123git commit --amendgit push --force &lt;remote-name&gt; &lt;branch-name&gt; 1234git log --onelinegit commit --amend -m &quot;新的提交信息&quot;git push --force origin master 16. GitHub: BiliBiliToolPro 2024-12-11 更新至最新版本 V2.1.1 版本 2.1.1，上线时间 2024-05-13 地址：github 方式：本地部署-文档-linux 失效项： LiveLottery，天选时刻抽奖，issue LiveFansMedal，直播间挂机，issue 1234567891011$ pwd/root/sh_file/BiliBiliToolPro# 删除旧版文件$ rm -rf *$ wget https://github.com/RayWangQvQ/BiliBiliToolPro/releases/download/2.1.1/bilibili-tool-pro-v2.1.1-linux-x64.zip$ unzip bilibili-tool-pro-v2.1.1-linux-x64.zip$ cd ./linux-x64/$ ./Ray.BiliBiliTool.Console --runTasks=Login 1234567891011121314$ crontab -l# ================================================0 1 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=VipBigPoint &amp;&gt; /dev/null0 8 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=Daily &amp;&gt; /dev/null* */12 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=LiveLottery &amp;&gt; /dev/null0,20,40 16 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=UnfollowBatched &amp;&gt; /dev/null0,20,40 18 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=UnfollowBatched &amp;&gt; /dev/null0 20 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=LiveFansMedal &amp;&gt; /dev/null 地址：https://github.com/RayWangQvQ/BiliBiliToolPro 本地部署： 12345678$ pwd/root/sh_file/BiliBiliToolPro$ wget https://github.com/RayWangQvQ/BiliBiliToolPro/releases/download/1.0.3/bilibili-tool-pro-v1.0.3-linux-x64.zip$ unzip bilibili-tool-pro-v1.0.3-linux-x64.zip$ cd ./linux-x64/$ ./Ray.BiliBiliTool.Console --runTasks=Login 1234567$ crontab -l0 1 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=VipBigPoint0 8 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=Daily* */12 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=LiveLottery0 16 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=UnfollowBatched0 20 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=LiveFansMedal 17. GitHub Compare 原文：https://akilar.top/posts/bbf68ad4/ 示例：https://github.com/jerryc127/hexo-theme-butterfly/compare/4.8.5...4.9.0 18. new Date().getFullYear(); JavaScript 获取当前年份 12345// 要以自动方式获取明年的年份并将其用于创建日期对象，您可以按如下方式修改代码：const currentYear = new Date().getFullYear();const nextYear = currentYear + 1;const newYearTimestamp = new Date(`$&#123;nextYear&#125;-01-01 00:00:00`).getTime() / 1000; 19. JavaScript 解码 Base64 在线加密：https://encode.chahuo.com/ 以下来自 ChatGPT 在 JavaScript 中解码 Base64 编码的数据，你可以使用 atob() 函数。该函数可以将 Base64 编码的字符串解码为原始的文本数据。示例代码如下： 123const base64String = &quot;SGVsbG8gd29ybGQ=&quot;; // Base64 编码的字符串const decodedString = atob(base64String); // 解码console.log(decodedString); // 输出解码后的字符串 在这个例子中，base64String 你要解码Base64编码的字符串。使用atob()函数对它进行解码，然后你就可以处理解码后的原始字符串了。 20. JavaScript 取绝对值 来自 ChatGPT 在 JavaScript 中，你可以使用 Math.abs() 函数来获取一个数的绝对值，从而去除负号。例如： 12let num = -5;let absNum = Math.abs(num); // absNum将是5 这样，absNum 将会取得 num 的绝对值，而不考虑其正负。 21. JavaScript 三元运算 来自 ChatGPT 你可以使用条件运算符（三元运算符）来判断 e - now1 是否大于 0，然后决定是否执行 +1。下面是优化后的代码： 1let daysDifference = Math.floor(((e - now1) / 1e3 / 60 / 60 / 24) + (e - now1 &gt; 0 ? 1 : 0)); 这行代码首先计算 (e - now1) / 1e3 / 60 / 60 / 24 得到天数差，然后根据 (e - now1 &gt; 0) 条件判断天数差是否大于 0，如果是则加 1，否则加 0。最后使用 Math.floor 向下取整。 22. Snipaste 截图格式改 JPG 参考：https://jingyan.baidu.com/article/25648fc14b3276d091fd00c3.html 右键 → 首选项 → 输出 → 文件名.后缀 实测大大减少图片体积，500 KB (PNG) → 70KB (JPG) 仅适用于保存为本地文件，从剪贴板中粘贴到 typora 里还是 PNG 格式的 本人格式：image-$yyyyMMddHHmmsszzz$.jpg，目的 与 typora 剪贴板 上场时的 alt 命名保持一致 23. CSS 视口单位 dvh, svh, lvh 参考： https://blog.anheyu.com/posts/e644.html https://blog.csdn.net/LuckyWinty/article/details/128962918 24. CSS 旋转 rotate(90deg) 来自 ChatGPT rotate(90deg) 是CSS中的旋转变换指令，用于将元素顺时针旋转90度。这可以应用于任何HTML元素，使其在页面上以指定角度旋转。 逆时针旋转一个元素90度，rotate(-90deg) 123.about-page-chicken-soup details[open]&gt;summary:after &#123; transform: rotate(-90deg);&#125; 25. Markdown 折叠语法 参考：https://blog.csdn.net/ybb_ymm/article/details/128508243 1234&lt;details&gt; &lt;summary&gt;指示标题&lt;/summary&gt; 内容&lt;/details&gt; 123456&lt;details&gt; &lt;summary&gt;展开查看&lt;/summary&gt; &lt;pre&gt;&lt;code&gt; 此处为代码的块具体内容 &lt;/code&gt;&lt;/pre&gt; &lt;/details&gt; 26. PicGo 图片压缩插件 插件名：picgo-plugin-compress-tinypng NPM 包：picgo-plugin-tinypng TinyPNG 官网：https://tinify.cn/ 获取 Key 参考：https://bearcai.com/index.php/archives/44/ Key 限额 500 次/月：https://tinify.cn/dashboard/api 起因：picgo-plugin-compress 长久失修，picgo 2.3.1 报错 TypeError: req.end is not a function。 issue#64 获知此插件 27. JavaScript copy 事件 来自 ChatGPT 要检测用户是否复制内容，你可以使用JavaScript中的copy事件来捕获复制操作。你可以将事件监听器绑定到copy事件上，然后在该事件触发时执行相应的操作，以获知用户是否复制了内容。 1234document.addEventListener(&#x27;copy&#x27;, function(event) &#123; // 在这里执行你想要的操作，例如记录复制操作或发送数据到服务器 console.log(&#x27;用户复制了内容&#x27;);&#125;); 12345678910111213document.addEventListener(&#x27;copy&#x27;, function(event) &#123; // 获取复制的内容 var copiedText = window.getSelection().toString().trim(); // 检查复制的内容是否为空 if (copiedText.length &gt; 0) &#123; // 在这里执行你想要的操作，例如记录复制操作或发送数据到服务器 console.log(&#x27;用户复制了内容:&#x27;, copiedText); &#125; else &#123; // 复制的内容为空，可以选择不执行任何操作或者执行相应处理 console.log(&#x27;用户尝试复制空内容&#x27;); &#125;&#125;); 28. JavaScript window.onresize 来自：ChatGPT window.onresize 是 JavaScript 中的一个事件处理属性，它用于指定在浏览器窗口大小改变时要执行的函数。当用户调整浏览器窗口的大小时，就会触发 resize 事件，如果你将一个函数分配给 window.onresize，那么这个函数将在窗口大小改变时被调用。 例如，你可以使用以下方式监听窗口大小改变事件并执行相应的操作： 1234window.onresize = function() &#123; // 在窗口大小改变时执行的代码 console.log(&quot;窗口大小已改变&quot;);&#125;; 这对于创建响应式设计或根据窗口大小进行布局调整等任务非常有用。当窗口大小发生变化时，你可以根据需要更新页面内容、样式或执行其他自定义操作。 29. Git 指定远端 参考：http://www.mobiletrain.org/about/BBS/161969.html 12345git remote add origin &lt;远程仓库URL&gt;git push &lt;远程仓库别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;git push origin master:main 30. Git 删除文件历史提交记录 参考：ChatGPT 1234git filter-branch --force --index-filter &#x27;git rm -r --cached --ignore-unmatch node_modules&#x27; --prune-empty --tag-name-filter cat -- --allgit rm --cached node_modules -rgit reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive ChatGPT 还提供了 git filter-branch --tree-filter 'rm -rf node_modules' --prune-empty HEAD 命令删除，运行时间过长，不采用，给出的解释：命令1 使用了 --index-filter 和 --cached，这些参数可以更快地处理 Git 的索引而不需要检查和修改实际的工作树文件 git filter-branch --tree-filter 'rm -rf node_modules' --prune-empty HEAD: 使用 --tree-filter 参数，它会在每个提交上执行指定的 shell 命令。在这种情况下，它会执行 rm -rf node_modules 命令来删除 node_modules 目录。 使用 --prune-empty 选项以删除空提交。 只作用于当前分支 HEAD。 git filter-branch --force --index-filter 'git rm -r --cached --ignore-unmatch node_modules' --prune-empty --tag-name-filter cat -- --all: 使用 --index-filter 参数，它会在 Git 索引上执行指定的命令。在这种情况下，它会执行 git rm -r --cached --ignore-unmatch node_modules 命令，以将 node_modules 从索引中删除。 使用 --prune-empty 选项以删除空提交。 使用 --tag-name-filter cat 选项，以保留提交的标签（tags）。 使用 --all 来指定作用于所有分支。 之前上传 github 时提交了无需提交的 node_modules，如何缩小 .git 的大小 ChatGPT：要缩小.git目录的大小，可以采取以下步骤： 清理历史提交中的node_modules：首先，你需要清理历史提交中的不必要的node_modules目录。你可以使用git filter-branch命令或git filter-repo工具来重写历史提交以删除node_modules。确保在删除之前备份你的仓库，以防发生问题。 使用.gitignore：在项目根目录下创建一个名为.gitignore的文件，并将node_modules/添加到其中，以确保不再将该目录包括在提交中。 执行git rm --cached node_modules -r：这将删除当前暂存区中的node_modules目录，但不会删除物理文件。然后，提交这一变更。 执行git reflog expire --expire=now --all：这将清理Git的reflog，以确保不再保留对不必要历史提交的引用。 执行git gc --prune=now：这将触发垃圾收集，清理不必要的数据，从而缩小.git目录的大小。 推送到远程仓库：如果你使用远程仓库（如GitHub），确保将这些更改推送到远程仓库以同步它们。 请注意，这些步骤会修改你的Git历史，因此在执行它们之前务必小心，确保已备份你的仓库数据。 31. 洛雪音乐导入三方音源 官方源因 TX 警告而报废，详见 issue：https://github.com/lyswhut/lx-music-desktop/issues/1643 详见 issue：https://github.com/lyswhut/lx-music-desktop/issues/1649#issuecomment-1774536022 仓库：https://github.com/OneCodeMonkey/music-sources 32. Clash GUI 起因：Clash for Windows 删库 Clash Verge：https://github.com/zzzgydi/clash-verge/ Clash for Android 存档：https://github.com/Z-Siqi/Clash-for-Windows_Chinese/releases/tag/CFA Clash for Windows 存档：https://github.com/Z-Siqi/Clash-for-Windows_Chinese 33. GitHub SSH 超时 git pull 报超时、ping github.com 报超时 解决方案 12# git bash 终端vim ~/.ssh/config 内容如下，第一次 git pull 时输入 yes 1234# GitHub StartHost github.com Hostname ssh.github.com# GitHub End 参考 https://blog.ttiee.tech/posts/2024/71e1/ https://ww-rm.github.io/posts/2024/01/17/githubssh-timeout/ github Using SSH over the HTTPS port github About GitHub’s IP addresses 34. Hexo 隐藏文章 参考：JIeJaitt | Hexo隐藏文章 Front-Matter 配置 published 参数 1234---title: Foopublished: false--- 存为草稿 12# 路径 source/_drafts/hexo new draft &lt;title&gt; 插件，hexo-hide-posts 等 官方参考 https://hexo.io/docs/front-matter#Settings-Their-Default-Values https://hexo.io/zh-cn/docs/writing.html 35. GitHub 2FA GitHub 2FA 双因素认证 地址：https://github.com/settings/security Chrome插件：Authenticator 安卓应用：Microsoft Authenticator 参考：https://zhuanlan.zhihu.com/p/657035724 36. GitHub: B 站粉丝牌助手 用途：b站粉丝牌升级 版本：fdc626f，commits；Nov 11, 2024 地址：https://github.com/XiaoMiku01/fansMedalHelper 文档：https://xiaomiku01.github.io/fansMedalHelperVersion/ 服务器部署：https://xiaomiku01.github.io/fansMedalHelperVersion/guide/location.html 12345678$ pwd/root/sh_file$ git clone https://github.com/XiaoMiku01/fansMedalHelper.git$ cd fansMedalHelper# $ pip3 install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple$ pip3.8 install -r requirements.txt 123$ cp users.example.yaml users.yaml$ vim users.yaml 使用 B站access_key获取工具 管理员身份运行，获取 access_key 文件 users.yaml 修改项：access_key、SIGNINGROUP: 2 1234567# cat users.yamlUSERS: - access_key: xxxSIGNINGROUP: 2 # 应援团签到CD时间,单位秒,默认2秒,设置为0则不签到 删除不重要的粉丝牌，减少耗时，b站链接，参考自 issue 使用计划任务每日一点跑程序，参考自 文档 123456$ crontab -l# ================================================# B站粉丝牌助手# https://github.com/XiaoMiku01/fansMedalHelper0 1 * * * cd /root/sh_file/fansMedalHelper; python3.8 main.py &amp;&gt; /dev/null 37. 音乐播放器 吾爱破解：https://www.52pojie.cn/ 酷我音乐PC：蓝奏云 38. b站 硬核会员 b站 硬核会员答题 油猴脚本 参考 https://github.com/HCLonely/bili-senior-newbie-qa https://blog.hclonely.com/posts/c1ef618c/ 安装 安装Tampermonkey(建议)或其他脚本管理器； 点此安装搜题脚本。 使用 手机哔哩哔哩客户端进入答题； 浏览器登录哔哩哔哩(已登录可跳过此步骤)； 浏览器打开调试工具(F12), 将浏览器切换为移动设备(Ctrl+Shift+M)； 在地址栏输入https://www.bilibili.com/h5/senior-newbie/并回车，进入答题，等待网页加载完成； 启动脚本(Alt+N)； 加载题库(需要题目完全匹配)：可从本地加载题库(支持txt,doc,docx,xls,xlsx格式)，题库中搜索不到则使用搜索引擎搜索 直接运行：使用搜索引擎搜索(支持百度，搜狗，必应，谷歌) 点击题目即可进行搜索。 注意事项 使用此脚本时建议关闭其他插件/脚本，避免冲突； 建议选择文史，知识，音乐等答案比较好搜索判断的类型。 39. npm cdn https://cdn.jsdelivr.net/npm/ https://cdn.cbd.int/ https://cdn.iocdn.cc/npm/ https://open.lightxi.com/unpkg/ https://cdn.smartcis.cn/npm/ https://cdn.jsdmirror.com/npm/ https://s4.zstatic.net/npm/ 参考 https://blog.anheyu.com/posts/fe76.html https://blog.liushen.fun/posts/260f4f9a/#JSCDN 40. CentOS 配置 zsh 背景：2025/5/11 更换新云主机 CentOS Stream 9，迁移旧主机配置 参考 https://www.cnblogs.com/jie-fang/p/13437335.html 别名免密登录：mycpen 修改主机名 123456$ cat /etc/hostnameCentOS# 重启$ reboot 安装 zsh 和 oh-my-zsh，参考 博客园 查看当前 shell echo $SHELL 安装 zsh yum install -y zsh 查看系统中已经安装的 shell cat /etc/shells 切换 shell chsh -s /bin/zsh 安装 git yum install -y git 安装 oh-my-zsh 12sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 修改 oh-my-zsh 主题 12345$ vim ~/.zshrcZSH_THEME=&quot;ys&quot;$ source ~/.zshrc 其他配置 迁移计划任务 crontab 定时脚本 crontab -e 12345678910111213141516# ================================================# B站签到投币# https://github.com/RayWangQvQ/BiliBiliToolPro0 1 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=VipBigPoint &amp;&gt; /dev/null0 8 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=Daily &amp;&gt; /dev/null# * */12 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=LiveLottery &amp;&gt; /dev/null0,20,40 16 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=UnfollowBatched &amp;&gt; /dev/null0,20,40 18 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=UnfollowBatched &amp;&gt; /dev/null0 20 * * * cd /root/sh_file/BiliBiliToolPro/linux-x64; ./Ray.BiliBiliTool.Console --runTasks=LiveFansMedal &amp;&gt; /dev/null# ================================================# B站粉丝牌助手# https://github.com/XiaoMiku01/fansMedalHelper0 1 * * * cd /root/sh_file/fansMedalHelper; python3 main.py &amp;&gt; /dev/null BiliBiliToolPro 参考 https://github.com/RayWangQvQ/BiliBiliToolPro mycpen 本地部署：2025/5/11，V2.2.1 2025/5/23，V3.1.0，参考：github-linux 1234567891011$ pwd/root/sh_file/BiliBiliToolPro# 删除旧版文件$ rm -rf *$ wget https://github.com/RayWangQvQ/BiliBiliToolPro/releases/download/3.1.0/bilibili-tool-pro-v3.1.0-linux-x64.zip$ unzip bilibili-tool-pro-v3.1.0-linux-x64.zip$ cd ./linux-x64/$ ./Ray.BiliBiliTool.Console --runTasks=Login fansMedalHelper 参考 https://github.com/XiaoMiku01/fansMedalHelper mycpen 本地部署：2025/5/11，fdc626f Nov 11, 2024，参考：文档 12345678$ pwd/root/sh_file$ git clone https://github.com/XiaoMiku01/fansMedalHelper.git$ cd fansMedalHelper# $ pip3 install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple$ pip3 install -r requirements.txt 123$ cp users.example.yaml users.yaml$ vim users.yaml 使用 B站access_key获取工具 管理员身份运行，获取 access_key 文件 users.yaml 修改项：access_key、SIGNINGROUP: 2 1234567# cat users.yamlUSERS: - access_key: xxxSIGNINGROUP: 2 # 应援团签到CD时间,单位秒,默认2秒,设置为0则不签到 使用计划任务每日一点跑程序，参考自 文档 123456$ crontab -l# ================================================# B站粉丝牌助手# https://github.com/XiaoMiku01/fansMedalHelper0 1 * * * cd /root/sh_file/fansMedalHelper; python3 main.py &amp;&gt; /dev/null","categories":[{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/categories/Other/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog1.cpen.top/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"},{"name":"SSH","slug":"SSH","permalink":"https://blog1.cpen.top/tags/SSH/"},{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/tags/Other/"}]},{"title":"03_Error-问题记录-winpty-.gitignore","slug":"Error/03_Error-问题记录","date":"2023-03-01T04:00:00.000Z","updated":"2023-09-05T05:00:00.000Z","comments":true,"path":"posts/fe8dbc73.html","permalink":"https://blog1.cpen.top/posts/fe8dbc73.html","excerpt":"","text":"前言 记录一些遇到的问题 01. Python 中文乱码 (Git Bash) win终端正常运行但是在git bash 终端运行py文件中文乱码 在python命令前加 winpty 之后则可以正常显示中文 winpty：一个 Windows 软件包，提供类似于 Unix pty-master 的接口，用于与 Windows 控制台程序通信。 参考文章： 【python中文乱码】git bash终端运行python文件中文乱码的问题 https://github.com/rprichard/winpty 02. .gitignore 测试规则 .gitignore 配置 1234567891011121314151617181920212223242526272829303132333435363738*.a 表示忽略所有 .a 结尾的文件!lib.a 表示但lib.a除外doc/*.txt 表示会忽略doc/notes.txt但不包括 doc/server/arch.txt/TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObin/ 表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件**/foo: 表示忽略/foo,a/foo,a/b/foo等a/**/b: 表示忽略a/b, a/x/b,a/x/y/b等*.log: 表示忽略所有 .log 文件/mtk/ 表示过滤整个文件夹*.zip 表示过滤所有.zip文件--- 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下： ---!*.zip!/mtk/one.txt唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：/mtk/*!/mtk/one.txt假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！--- 还有一些规则如下： ---fd1/*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；/fd1/*说明：忽略根目录下的 /fd1/ 目录的全部内容；------/*!.gitignore!/fw/ /fw/*!/fw/bin/!/fw/sf/说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。 * .gitignor 忽略规则查看 有时候，确定为什么要忽略特定文件可能会很困难，尤其是当你使用多个.gitignore文件或复杂格式时。这是git check-ignore命令的用处，告诉git显示匹配模式的详细信息。 例如，要检查为什么忽略www/yarn.lock文件，可以运行： git check-ignore -v www/yarn.lock 显示所有被忽略的文件 带有–ignored选项的git status命令显示所有被忽略文件的列表： git status --ignored 参考文章： Git忽略提交规则 - .gitignore配置【学习】 如何使用.gitignore忽略Git中的文件和目录 03. Windows 显示&quot;无Internet&quot; 情况：网络显示 “无Internet”，但是可以上网。以下措施没根本解决，最终用微软诊断工具，重置了 以太网 网络（万能的重装大法）… 向 dns.msftncsi.com 发送 DNS 查找请求，DNS 解析为 131.107.255.255 请求 http://www.msftconnecttest.com/connecttest.txt，如果网络正常，则此文件是纯文本文件，仅包含文本 Microsoft Connect Test 如果过程1不正常，则提示“无法访问Internet”，如果1正常2不正常，则提示需要进行身份验证 以下措施没解决问题 估计 DHCP 分配的 DNS 服务器（指向网关）有问题，SwitchHosts 追加本地记录 12# Microsoftdns.msftncsi.com 131.107.255.255 开机自启 SwitchHosts（Win）： 快捷方式 复制到 =&gt; C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\ 设置 =&gt; 选项 =&gt; 启动时隐藏 √ 参考文章： 解决Windows有网络连接但是显示“无Internet”的问题 SwitchHosts/issues/646 04. Replit Repl ERR_SSL_PROTOCOL_ERROR 未解决，绑自定义域名后，未分配 SSL 证书 Replit 官方论坛： https://ask.replit.com/t/err-ssl-protocol-error-for-all-sites/27775 问题搜索：https://ask.replit.com/search?q=ERR_SSL_PROTOCOL_ERROR Replit 官方服务状态： SSL 证书问题 部署的新自定义域遇到 SSL 错误 临时方案： https://ask.replit.com/t/err-ssl-protocol-error-for-all-sites/27775/4 现在，更改“。” 在 url 中的 repl 名称和用户名之间添加到“–”就可以了。 例如，https://score-analyzer–enderparakeet.repl.co/ 3个作品。 教程： Replit 绑自定义域名（官方） 05. Terminal 报错: 4294967295 wsl2 报错: [已退出进程，代码为 4294967295 (0xffffffff)]，终端无法打开 1234# 管理员身份 PowerShellnetsh winsock reset# 重新打开 terminal，无效则尝试重启后再打开 参考：打开wsl，显示 [已退出进程，代码为 4294967295] 的解决方案 后记：未根本解决，根本错误 wsl Error: 0x80040326，如下 06. wsl2 Error: 0x80040326 无法打开终端，报错： Error: 0x80040326 Error code: Wsl/Service/0x80040326 解决方法：powershell 管理员模式：wsl --update 参考： https://blog.csdn.net/minibirder/article/details/129863725 https://blog.csdn.net/qq_37932051/article/details/129873314 07. crond 致 sendmail 大量进程 阿里云服务器监控显示 CPU 长期高负载，原因：定时任务 crond 引发大量 sendmail 进程 参考： https://blog.csdn.net/LQzhang_11/article/details/114323700 https://blog.51cto.com/ning235/2661806 处理方法： cron 后面添加 &amp;&gt; /dev/null 或 &gt; /dev/null 2&gt;&amp;1 禁止 cron 发用户邮件（未操作） 08. Netlify 自动转换小写 URI 现象：原 URI /tags/Error/ 转为 /tags/error/ 解决：配置中取消 Pretty URLs 美化 URL 的功能 Site configuration → Post processing → Pretty URLs → □ Enable Pretty URLs 示例：https://app.netlify.com/sites/mycpen-blog/configuration/deploys#pretty-urls 09. pip: command not found 前言：电脑上已装 Python，且在 PATH 内，无法找到 pip 命令 报错：pip: command not found 或 No module named pip 升级 pip：python -m pip install --upgrade pip 办法：执行 python -m ensurepip 来自 chatgpt 在 Windows 系统上，如果您在运行 python.exe 时遇到 No module named pip 错误，这通常表示在您的 Python 安装中缺少了 pip 模块。pip 是 Python 的包管理工具，通常会随 Python 一起安装。 您可以按照以下步骤来解决这个问题： 检查 Python 安装： 首先，请确保您已经正确安装 Python。您可以在命令提示符下运行以下命令来检查 Python 的版本： 1python --version 检查 pip 是否安装： 在较新版本的 Python 中，pip 已经随 Python 一起安装。您可以尝试运行以下命令来安装 Python 包： 1python -m ensurepip 这将安装 pip 模块。如果 pip 已经安装，您可能会看到一条消息指示 Requirement already satisfied. 添加 pip 到系统环境变量： 如果 pip 已正确安装，但仍然无法正常使用，可能是因为 pip 不在系统的环境变量中。您可以手动将 pip 所在的路径添加到系统的 PATH 环境变量中。 默认情况下，在 Windows 系统上，pip 通常安装在 Scripts 文件夹中。您可以找到该文件夹的路径，然后将其添加到系统的 PATH 环境变量中。 验证 pip 安装： 最后，您可以在命令提示符下运行以下命令来验证 pip 是否安装成功： 1pip --version 如果 pip 安装成功，您应该看到 pip 的版本信息，而不再出现 No module named pip 错误。 通过按照上述步骤操作，您应该能够解决 No module named pip 错误，并成功使用 pip 来管理 Python 包。 10. git fetch --unshallow github action 报错 ! [remote rejected] main -&gt; main (shallow update not allowed) 12345remote: Powered by GITEE.COM [GNK-6.4] To https://gitee.com/mycpen/image_bed.git ! [remote rejected] main -&gt; main (shallow update not allowed)error: failed to push some refs to &#x27;https://gitee.com/mycpen/image_bed.git&#x27;Error: Process completed with exit code 1. 解决：git fetch --unshallow，详见 link 来自 chatgpt 这个错误是因为在尝试将代码推送到 Gitee 仓库时，Gitee 不允许进行浅层更新（shallow update）。浅层更新是指仓库中只包含部分历史记录，而不是完整的历史记录。为了解决这个问题，你可以尝试以下方法： 完整克隆：首先，你可以通过完整克隆仓库的方式来获取完整的历史记录，然后再进行推送。在克隆仓库时，不要使用 --depth 参数，这样可以确保克隆完整的历史记录。 1git clone https://gitee.com/mycpen/CDN.git 移除浅层设置后重新克隆：如果你之前使用了浅层克隆，可以尝试移除浅层设置，然后重新克隆仓库。 12git fetch --unshallowgit clone https://gitee.com/mycpen/CDN.git 强制推送：如果你已经有本地完整的历史记录，可以尝试使用强制推送来覆盖远程仓库的内容。 1git push -f origin main 通过以上方法，你应该能够解决 Gitee 仓库不允许浅层更新的问题，并成功将代码推送到 Gitee 仓库中。如果你有任何其他问题或需要进一步帮助，请随时告诉我。","categories":[{"name":"Error","slug":"Error","permalink":"https://blog1.cpen.top/categories/Error/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://blog1.cpen.top/tags/Error/"},{"name":"Git","slug":"Git","permalink":"https://blog1.cpen.top/tags/Git/"}]},{"title":"02_转载-Replit 部署 Memos & Butterfly 基于 Memos 实现清单功能","slug":"转载/02_转载-Replit部署Memos","date":"2023-02-01T04:00:00.000Z","updated":"2023-03-28T05:00:00.000Z","comments":true,"path":"posts/10d5063.html","permalink":"https://blog1.cpen.top/posts/10d5063.html","excerpt":"","text":"2023/06/01 更新 最近 Replit 的 Repl 出现回档现象，导致最新变更操作丢失，正如 uptimekumaonreplit 仓库管理者提到的 Replit有点拉，似乎会回档，会导致数据库很多对不上。随便用用吧20220430，回档现象我暂未找到解决办法 参考链接 Atticus：replit免费部署memos（本文转载） Leonus：基于Memos实现说说和清单功能（本文转载 清单部分） Leonus：基于memos实现动态相册 Atticus B站视频：replit免费部署memos usememos/memos Atticus6/memos-on-replit 以下内容全文摘自 Atticus、Leonus 的文章 文章1. Atticus：replit免费部署memos 部署 使用默认项目名称 memos-on-replit，否则会无法部署 Run On Replit.io 备用地址：https://github.com/mycpen/memos-on-replit 语言必须为Go 许可 memos-replit 是在 AGPL-3.0 许可下许可的开源软件。 免责声明 本程序为免费开源项目，旨在分享网盘文件，方便下载以及学习golang，使用时请遵守相关法律法规，请勿滥用； 本程序通过调用官方sdk/接口实现，无破坏官方接口行为； 本程序仅做302重定向/流量转发，不拦截、存储、篡改任何用户数据； 在使用本程序之前，你应了解并承担相应的风险，包括但不限于账号被ban，下载限速等，与本程序无关； 如有侵权，请通过邮件与我联系，会及时处理。@博客 · @GitHub · @Telegram群 版权属于： atticus 本文链接： https://www.iweec.cn/30.htm 文章2. Leonus：基于Memos实现说说和清单功能 相关链接 Leonus：基于Memos实现说说和清单功能 Leonus：基于memos实现动态相册 以下内容全文摘自 Leonus：基于Memos实现说说和清单功能 清单功能 部分 清单功能 再次说明，这一切只是我定的规则而已，你可以随意修改代码来实现你想实现的效果。 实现 还是先使用hexo n page xxx创建页面。 然后粘贴如下代码并按照注释修改内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;style&gt;/* 页面初始化 */div#page &#123; background: none; border: 0; padding: 0;&#125;[data-theme=dark] #twikoo .tk-content,#twikoo .tk-content &#123; padding: 0; background: transparent;&#125;.tk-comments-container&gt;.tk-comment,.tk-submit:nth-child(1)&#123; background: var(--card-bg); border: 1px rgba(188, 188, 188, 0.8) solid; box-shadow: 0 5px 10px rgb(189 189 189 / 10%); transition: all .3s ease-in-out; border-radius: 12px;&#125;.tk-comments-container&gt;.tk-comment:hover,.tk-submit:nth-child(1):hover &#123; border-color: #6dc3fd;&#125;.tk-submit &#123; padding: 20px 10px 0;&#125;.tk-comments-container&gt;.tk-comment &#123; padding: 15px;&#125;/* 页面初始化结束 */div#todolist &#123; display: flex; flex-wrap: wrap; margin-top: 1rem;&#125;.list_item &#123; display: inline-block; width: calc(50% - .4rem); background: #ffe3dd; border-radius: 12px; padding: 10px 1rem 1.2rem; border: 2px dashed #f7a796; --todo-border: 1px solid #f7a796; margin-right: 1rem; margin-bottom: 1rem;&#125;.list_item h3 &#123; margin: 0; border-bottom: var(--todo-border);&#125;.list_item ul &#123; font-size: 17px; padding: 0 !important; margin: 0;&#125; .list_item li&#123; margin: 0 !important; border-bottom: var(--todo-border); &#125;.list_item li::marker &#123; content: none;&#125;li.achieve &#123; opacity: .8; text-decoration: line-through;&#125;@media screen and (max-width: 900px) &#123; div#todolist &#123; margin: 1rem 5px 0; &#125;&#125;@media screen and (max-width: 768px) &#123; .list_item&#123; width: 100%; &#125;&#125;&lt;/style&gt;&lt;div id=&quot;todolist&quot;&gt;&lt;/div&gt;&lt;script&gt;// 瀑布流函数，不用管function waterfall(t)&#123;function e(t,e)&#123;var n=window.getComputedStyle(e);return parseFloat(n[&quot;margin&quot;+t])||0&#125;function n(t)&#123;return t+&quot;px&quot;&#125;function r(t)&#123;return parseFloat(t.style.left)&#125;function o(t)&#123;return t.clientWidth&#125;function l(t)&#123;return function(t)&#123;return parseFloat(t.style.top)&#125;(t)+function(t)&#123;return t.clientHeight&#125;(t)+e(&quot;Bottom&quot;,t)&#125;function i(t)&#123;return r(t)+o(t)+e(&quot;Right&quot;,t)&#125;function u(t)&#123;t=t.sort((function(t,e)&#123;return l(t)===l(e)?r(e)-r(t):l(e)-l(t)&#125;))&#125;function a(e)&#123;o(t)!=h&amp;&amp;(e.target.removeEventListener(e.type,arguments.callee),waterfall(t))&#125;&quot;string&quot;==typeof t&amp;&amp;(t=document.querySelector(t));var s=[].map.call(t.children,(function(t)&#123;return t.style.position=&quot;absolute&quot;,t&#125;));t.style.position=&quot;relative&quot;;var f=[];s.length&amp;&amp;(s[0].style.top=&quot;0px&quot;,s[0].style.left=n(e(&quot;Left&quot;,s[0])),f.push(s[0]));for(var p=1;p&lt;s.length;p++)&#123;var c=s[p-1],y=s[p];if(!(i(c)+o(y)&lt;=o(t)))break;y.style.top=c.style.top,y.style.left=n(i(c)+e(&quot;Left&quot;,y)),f.push(y)&#125;for(;p&lt;s.length;p++)&#123;u(f);y=s[p];var d=f.pop();y.style.top=n(l(d)+e(&quot;Top&quot;,y)),y.style.left=n(r(d)),f.push(y)&#125;u(f);var v=f[0];t.style.height=n(l(v));var h=o(t);window.addEventListener?window.addEventListener(&quot;resize&quot;,a):document.body.onresize=a&#125;// 清单函数todolist();function todolist() &#123; fetch(&#x27;https://你的memos地址/api/memo?creatorId=1&amp;tag=清单&#x27;).then(res =&gt; res.json()).then(data =&gt; &#123; // 注意替换链接 // 获取并处理数据 data = data.data let box = document.getElementById(&#x27;todolist&#x27;) data.forEach(item =&gt; &#123; // 处理数据 let content = item.content, title = content.match(/\\[(.*?)\\]/g)[0].replace(/\\[(.*?)\\]/,&#x27;$1&#x27;); // 去掉多余内容，替换清单内容 content = content.replace(/#.*\\s/g, &#x27;&#x27;).replace(/(-\\s\\[\\s\\]\\s)(.*)/g, `&lt;li&gt;&lt;i style=&quot;margin-right: 5px;&quot; class=&quot;fa-regular fa-circle&quot;&gt;&lt;/i&gt;$2&lt;/li&gt;`).replace(/(-\\s\\[x\\]\\s)(.*)/g, `&lt;li class=&quot;achieve&quot;&gt;&lt;i style=&quot;margin-right: 5px;&quot; class=&quot;fa-regular fa-circle-check&quot;&gt;&lt;/i&gt;$2&lt;/li&gt;`); // 渲染数据 let div = document.createElement(&#x27;div&#x27;); div.className = &#x27;list_item&#x27;; div.innerHTML = `&lt;h3&gt;$&#123;title&#125;&lt;/h3&gt;&lt;ul&gt;$&#123;content&#125;&lt;/ul&gt;`; box.appendChild(div); &#125;); waterfall(&#x27;#todolist&#x27;); &#125;).catch()&#125;&lt;/script&gt; 使用 使用的格式如下： 123#清单 [想去的地方]- [ ] 轻笑的米奇妙妙屋(轻笑让我加的)- [x] 已完成的清单 注意，前面的#清单 是固定的。标题用中括号包起来。已完成的将括号内的空格改成x即可。 文章作者: Leonus 文章链接: https://blog.leonus.cn/2023/memeos.html","categories":[{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"Replit","slug":"Replit","permalink":"https://blog1.cpen.top/tags/Replit/"},{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"Memos","slug":"Memos","permalink":"https://blog1.cpen.top/tags/Memos/"}]},{"title":"09_Hexo-Replit 搭建 Uptime Kuma 监控服务","slug":"Hexo/09_Hexo-Replit搭建Uptime-Kuma","date":"2023-01-01T04:00:00.000Z","updated":"2023-10-01T05:00:00.000Z","comments":true,"path":"posts/27addd89.html","permalink":"https://blog1.cpen.top/posts/27addd89.html","excerpt":"","text":"2023/10/01 更新 Replit 上的 Repl 报错，重新搭建 Uptime Kuma 参考自 梦念逍遥：使用Replit平台免费搭建站点监控工具——Uptime-Kuma Replit 导入仓库 louislam/uptime-kuma，语言 Bash .replit 即首次配置弹出的输入框 Configure the Run Command 输入 node server/server.js Shell 终端输入 node，选择 nodejs-16_x.out Shell 终端输入以下内容，指定版本 1.21.3 123git fetch --allgit checkout 1.21.3 --forcenpm run setup 点击 Run 2023/06/01 更新 最近 Replit 的 Repl 出现回档现象，导致最新变更操作丢失，正如 uptimekumaonreplit 仓库管理者提到的 Replit有点拉，似乎会回档，会导致数据库很多对不上。随便用用吧20220430，回档现象我暂未找到解决办法 1. 前言 打算监控博客友链的存活情况（不太礼貌的行为），因 UptimeRobot 免费版有 50 monitors 的限制，转而使用 Uptime Kuma，官方 readme 介绍了 Docker、Non-Docker 两者安装方式 由 uptime-kuma/issues/1472 及 butterfly 魔改群 群友获知 Replit 可以搭建 Uptime Kuma；根据 issues #1472 给出的步骤并未顺利搭建（体质问题吧），进而继续百度 由 B站视频：Uptime Kuma…replit… 获知仓库 valetzx/uptimekumaonreplit（Replit 下搭建的很顺利） 由 B站视频：Replit…绑定…域名 获知 Replit 下服务绑定自定义域名 搭建效果见 Mycpenの友链检测 2. 搭建步骤 主要步骤：Replit 导入 valetzx/uptimekumaonreplit 项目 搭建步骤： 注册 Replit Replit 导入 valetzx/uptimekumaonreplit 仓库 按 valetzx/uptimekumaonreplit readme 操作： Replit 个人版：点击 Run on Replit 导入 Replit 当加载完 Loading Nix environment… 后点击绿色 ▶ Run Replit 服务绑定自定义域名 按 B站视频：Replit…绑定…域名 操作：在 Replit Webview 窗口右侧按钮下（如下图），绑定自定义域名，并按提示在域名服务商 DNS 控制台进行解析 至此，搭建结束。可以通过 自定义域名 前往 Uptime Kuma 仪表盘进行 注册、设置、新增状态页、添加监控项、状态页分组绑定监控项 3. 注意点 监控类型为 HTTP(s) 时，HTTP 选项 - 方法 选择 HEAD 验证存活（不要使用默认的 GET，GET 会对对应服务造成 大量无意义的流量） 心跳间隔 (检测频率) 建议拉长（不要使用默认的 60s，会对对应服务造成 大量无意义的流量）。以我为例，设置了 86400 秒（即 1 天监控 1 次） 以我为例 监控项 变动了 4 处值，如下图 若网站屏蔽了 Uptime Kuma 的 UA，例如此文 如何禁止 Uptime Kuma 监控网站，可以配置 请求头 来解决，参考自 张洪Heo.评论区 123&#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36&quot;&#125; 4. 参考链接 louislam/uptime-kuma * valetzx/uptimekumaonreplit louislam/uptime-kuma/issues/1472 B站视频：Uptime Kuma…replit… B站视频：Replit…绑定…域名 valetzx：在Replit中自建监控网站（未参考）（uptimekumaonreplit 仓库作者的文章，介绍了些监控报警通知。个人未配置）","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"},{"name":"Replit","slug":"Replit","permalink":"https://blog1.cpen.top/tags/Replit/"}]},{"title":"08_Hexo-博客引用 B站鸿蒙字体","slug":"Hexo/08_Hexo-引用B站鸿蒙字体","date":"2022-12-06T04:00:00.000Z","updated":"2023-01-03T05:00:00.000Z","comments":true,"path":"posts/df249111.html","permalink":"https://blog1.cpen.top/posts/df249111.html","excerpt":"","text":"2022/12/31 更新 在 butterfly.zhheo.com 上看到下面这篇文章，介绍了很多其他字体（包括本文B站鸿蒙字体），写的很好 免费引入**黑体字体系列整理及 CSS 字体 1. 前言 在 Eurkon 那发现了B站使用的 harmonyOS_Regular 字体，B站网页端 打开开发者工具能看到字体由 regular.css 引入 计划用一段时间该字体，如有明显限速再停止使用 2. 引用步骤 自定义css 引入 regular.css 内容 自定义css 追加使用该字体的 css，以我的站点为示例（Butterfly 主题可跳过，直接步骤 3） 1234/* 字体样式 */body &#123; font-family: HarmonyOS_Regular,-apple-system,BlinkMacSystemFont,&#x27;Segoe UI&#x27;,&#x27;Helvetica Neue&#x27;,Lato,Roboto,&#x27;PingFang SC&#x27;,&#x27;Microsoft YaHei&#x27;,sans-serif;&#125; Butterfly 主题内置了自定义字体的配置，参见 官方文档_自定义字体和字体大小 示例：修改主题配置文件，如 [Blogroot]/_config.butterfly.yml 1234567# Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)font: global-font-size: code-font-size:- font-family: + font-family: HarmonyOS_Regular,-apple-system,BlinkMacSystemFont,&#x27;Segoe UI&#x27;,&#x27;Helvetica Neue&#x27;,Lato,Roboto,&#x27;PingFang SC&#x27;,&#x27;Microsoft YaHei&#x27;,sans-serif code-font-family: 个人建议：代码字体不建议使用 HarmonyOS_Regular，主题原生的 consolas 字体更好看 3. 后记 手机上唯二浏览器之一的 某浏览器 出现站内跳转时，页面长时间加载不出来的情况，考虑到 B站 对外站限速的可能性（排除法，大概率浏览器问题，同机的另一个浏览器不会复现🤔），备用方案：字体放 Github 个人仓库中，通过 staticaly CDN 进行免费加速使用 该字体已同步至 个人仓库 由 Fomalhaut🥝 获知 staticaly CDN 的使用，引用内容如下 原文地址：https://www.fomal.cc/ 官网地址：https://www.staticaly.com 轻松地从GitHub / GitLab / Bitbucket等加载您的项目 没有流量限制或限制。 文件通过超快速全球CDN提供。 在URL（不是分支）中使用特定标记或提交哈希。 根据URL永久缓存文件。 除master分支外，文件在浏览器中缓存1年。 具体用法： 1234567891011121314151617181920# GitHub CDNhttps://cdn.staticaly.com/gh/:user/:repo/:tag/:filehttps://cdn.staticaly.com/gh/growvv/growvv.github.io/master/README.md# GitLab CDNhttps://cdn.staticaly.com/gl/:user/:repo/:tag/:file# Bitbucket CDNhttps://cdn.staticaly.com/bb/:user/:repo/:tag/:file# WordPress CDNhttps://cdn.staticaly.com/wp/c/:version/wp-includes/:file https://cdn.staticaly.com/wp/p/:plugin_name/:version/:file https://cdn.staticaly.com/wp/t/:theme_name/:version/:file# Imgpx CDNhttps://cdn.staticaly.com/img/:image_url# Favicons CDNhttps://cdn.staticaly.com/favicons/:favicon_url 总结：staticaly CDN 作为免费 CDN，速度勉强还行 4. 字体样式总结 相较于 Butterfly 主题原字体，harmonyOS_Regular 字体左右间距略变大，字母略变明显，汉字略细密 总结：感知不强，徒增功耗 😂 主题原字体（Segoe UI） harmonyOS_Regular 字体","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"},{"name":"字体","slug":"字体","permalink":"https://blog1.cpen.top/tags/%E5%AD%97%E4%BD%93/"}]},{"title":"07_Hexo-插件整理","slug":"Hexo/07_Hexo-插件整理","date":"2022-12-05T04:00:00.000Z","updated":"2022-12-05T05:00:00.000Z","comments":true,"path":"posts/4c16ee73.html","permalink":"https://blog1.cpen.top/posts/4c16ee73.html","excerpt":"","text":"目录3 为转载内容，原文：Justlovesmile_Hexo博客 | 插件推荐 1. 较为关注 1.1 hexo-blog-encrypt 博客文章加密，由 Justlovesmile文章 获知 Github地址 1.2 hexo-hide-posts 隐藏 Hexo 文章，由 Butterfly issue#1122、issue#1119 获知 Github地址 1.3 hexo-renderer-markdown-it 渲染引擎，由 Butterfly文档 获知，由 Echocbx 获知 plugins 配置项 Github地址 1.4 @upupming/hexo-renderer-markdown-it-plus 渲染引擎，由 Butterfly文档 获知 Github地址 1.5 hexo-renderer-markdown-it-katex 渲染引擎，由 Nick Xu 获知 Github地址 2. Butterfly主题 2.1 hexo-butterfly-swiper 轮播图，作者：Akilar；二创：安知鱼 2.2 hexo-butterfly-categories-card 分类磁铁，Akilar 2.3 hexo-circle-of-friends 友链朋友圈，https://fcircle-doc.js.cool/#/ 非插件 2.4 hexo-butterfly-article-double-row 文章双栏，小冰 2.5 hexo-butterfly-charts 统计图表，Guo Le 3. 以下内容摘自 Justlovesmile 原文：Justlovesmile_Hexo博客 | 插件推荐 插件 功能 文档链接 hexo-generator-index-pin-top 文章置顶 https://github.com/netcan/hexo-generator-index-pin-top hexo-wordcount 文章字数统计和阅读时长统计 https://github.com/willin/hexo-wordcount hexo-abbrlink 生成URL短链接 https://github.com/rozbo/hexo-abbrlink hexo-lazyload-image 图片懒加载 https://github.com/Troy-Yang/hexo-lazyload-image hexo-generator-baidu-sitemap 生成baidusitemap.xml https://github.com/coneycode/hexo-generator-baidu-sitemap hexo-generator-sitemap 生成sitemap.xml https://github.com/hexojs/hexo-generator-sitemap hexo-generator-feed 生成RSS文件 https://github.com/hexojs/hexo-generator-feed hexo-external-link 外链跳转 https://github.com/hvnobug/hexo-external-link hexo-autonofollow 自动对外部链接增加nofollow属性 https://github.com/liuzc/hexo-autonofollow hexo-filter-nofollow 为外链添加 rel=&quot;noopener external nofollow noreferrer&quot; https://github.com/hexojs/hexo-filter-nofollow hexo-prism-plugin 代码高亮 https://github.com/ele828/hexo-prism-plugin hexo-neat 博客压缩 https://github.com/rozbo/hexo-neat hexo-allminifier https://developer.aliyun.com/mirror/npm/package/hexo-all-minifier hexo-tag-aplayer aplayer音乐播放器 https://github.com/MoePlayer/hexo-tag-aplayer hexo-tag-dplayer dplayer视频播放器 https://github.com/MoePlayer/hexo-tag-dplayer hexo-douban 添加豆瓣读书，电影，游戏页面 https://github.com/mythsman/hexo-douban hexo-generator-searchdb 本地搜索,生成search.xml https://github.com/theme-next/hexo-generator-searchdb hexo-algoliasearch 搜索系统 https://github.com/LouisBarranqueiro/hexo-algoliasearch hexo-algolia https://github.com/oncletom/hexo-algolia hexo-generator-search 本地搜索系统 https://github.com/wzpan/hexo-generator-search hexo-baidu-url-submit 百度站长主动推送 https://github.com/huiwang/hexo-baidu-url-submit hexo-offline 开启PWA https://github.com/JLHwung/hexo-offline hexo-pwa https://github.com/lavas-project/hexo-pwa hexo-helper-live2d 看板娘 https://github.com/EYHN/hexo-helper-live2d hexo-addlink 文末添加当前文章链接和版权声明 https://github.com/acwong00/hexo-addlink hexo-blog-encrypt 博客文章加密 https://github.com/MikeCoder/hexo-blog-encrypt hexo-simple-mindmap 博客添加脑图 https://github.com/HunterXuan/hexo-simple-mindmap hexo-pdf 博客展示pdf https://github.com/superalsrk/hexo-pdf hexo-tag-echarts 博客添加图表 https://github.com/zhoulvjun/hexo-tag-echarts hexo-steam-games 添加Steam游戏界面 https://github.com/HCLonely/hexo-steam-games hexo-bilibili-bangumi 添加bilibili番剧页面 https://github.com/HCLonely/hexo-bilibili-bangumi hexo-generator-random 生成随机文章页面 https://github.com/Drew233/hexo-generator-random hexo-web-push-notification web推送插件 https://github.com/glazec/hexo-web-push-notification","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"},{"name":"插件","slug":"插件","permalink":"https://blog1.cpen.top/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"06_Other-Windows 图片批量压缩工具 ultra-tinypng","slug":"Other/06_Other-Win图片压缩-ultra-tinypng","date":"2022-12-04T04:00:00.000Z","updated":"2023-07-11T05:00:00.000Z","comments":true,"path":"posts/b7f58a40.html","permalink":"https://blog1.cpen.top/posts/b7f58a40.html","excerpt":"","text":"2023-07-11 作者更新 fix：修复了tinypng官方修改了校验策略导致批量上传会报错为问题，解决方法是降低频率到单线程5秒一次 详见issue：#1 引自：https://github.com/libudu/ultra-tinypng/releases/tag/v0.4 1. 前言 在 B站 上发现了这款 Win 平台图片压缩工具 优点： 作者：本项目基于super-tinypng，在原项目基础上加入了打包开箱即用、递归目录、线程池、重复跳过的功能。 项目的原理是程序化处理文件，调用tinypng的接口进行文件压缩。 遗憾点： 图片后缀需为 PNG或JPG 需小于5MB Windows 平台工具（exe） 2. 下载地址 视频介绍：B站：【开源工具】图片素材一键批量压缩 untra-tinypng 项目源码：Github 工具下载：Release 3. 相关及其他压缩工具 TinyPNG Imagine 4. 鸣谢 开发者：linpicio","categories":[{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/categories/Other/"}],"tags":[{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/tags/Other/"},{"name":"TinyPNG","slug":"TinyPNG","permalink":"https://blog1.cpen.top/tags/TinyPNG/"}]},{"title":"01_转载-图床搭建 Backblaze B2 + Cloudflare CDN","slug":"转载/01_转载-图床搭建-BackblazeB2-CloudflareCDN","date":"2022-12-03T04:00:00.000Z","updated":"2023-06-16T05:00:00.000Z","comments":true,"path":"posts/16589f92.html","permalink":"https://blog1.cpen.top/posts/16589f92.html","excerpt":"","text":"相关链接 BlazeB2 - 基于 BackBlazeB2 和 Cloudflare 的图床工具（未使用） 转载文章 Backblaze B2 + Cloudflare CDN可自定义域名的10G高速免费外链图床 使用Backblaze B2 + Cloudflare CDN + PicGo实现可自定义域名的10G免费图床解决方案 使用Backblaze B2和Cloudflare作为免费图床 感谢 ReCreyed 的分享。以下内容全文摘自上面 3 篇文章 文章1：Backblaze B2 + Cloudflare CDN 本博客其他文章使用的都是github图床，无意中发现了B2+CF+ShareX的自建图床方案，而且还可以自定义域名，所以就有了这篇文章，本文所有图片全部来自这种方法的图床。 图床指的就是储存图片的服务器，网站管理员为了方便维护和管理，会将图片存放在专门的服务器集群里，通常还会在外层套层 CDN 做分发。市面上的公开图床很多，例如 imgur、sm.ms、imgbox 等等，这些图床都开放了 API 方便开发者调用。不过由于运营成本问题，也有不少图床相继倒闭或者转入收费。 怎么自建图床？如果是有VPS主机服务器，安装个Chevereto 开源图床网站程序即可。但这是VPS单纯用来做图床给博客外链图片用，有点浪费且不易长久。图片存储最好是放在大公司的云服务平台上， Backblaze B2 是一个云存储解决方案，类似于Amazon AWS S3, 但是价格稍微便宜一些. Backblaze的云存储每个注册用户拥有10G免费空间以及每天1G的下载流量，上传流量不限。超过免费额度后的价格以及与其他几家主流商家的对比见下图。 在backblaze存储1T的内容也仅需$5/月，不过流量费还是比较贵的 ，上传流量不限。 由于 Bandwidth Alliance(带宽联盟)，Backblaze 到 Cloudflare 之间的出口是完全免费的， 所以Backblaze B2可以配合cloudflare CDN来使用达到无限免费下载流量。 Backblaze宣布与Cloudflare合作，免除掉Backblaze到Cloudflare的流量费用。 因此我们得到如下网盘/图床产品： 10G存储空间免费， 全球最可靠的云存储服务 上行免费 下行免费 可自定义域名 全球最强CDN加速 搭建自定义域名图床教程开始 首先，你需要有一个域名，选择一个子域名作为图床的域名。 关于图床的二级域名命名，一般有以下几种： img images assets static （不仅存放图片，还有存放 css、js） 然后，创建 Backblaze B2 Bucket(存储桶) 。 在Backblaze’s B2 storage 注册一个账号，注册好了后，在后台面板选择 “Buckets”（存储桶），然后点击 “Create a Bucket”，创建一个存储桶。选Public，以便所有人可访问。 然后，回到 “Buckets(存储桶)” , 在你刚刚创建的存储桶上，点击 “Upload/Download(上传/下载)”. 上传一个临时的测试文件到存储桶中，然后在你刚上传的文件处，点击 “i(information，信息)”. 这是为了获取下一步需要的信息，你的存储桶处于哪台服务器上. 在上面的截图中，可以看到，我的文件是放在 https://f000.backblazeb2.com/ – 记住这个域名 最后，获取到地址之后就登录cloudflare，给你的域名添加一个子域名，并新增一条cname记录，指向文件地址中的域名，例如将img.coca.cc通过cname到f000.backblazeb2.com，效果便是https://img.coca.cc/file/imgsgj/img.jpg 指向 https://f001.backblazeb2.com/file/imgsgj/img.jpg 根据上面截图中的记录, 我使用这个子域名 img.coca.cc作为图床的域名, 并且指向 f000.backblazeb2.com. 确保 Cloudflare 橙色保护盾是开启的状态, 这代表请求是通过了 Cloudflare 的 CDN 代理层. Cloudflare 默认的 TTL 将被设置为 auto(自动). 虽然启用了CloudFlare CDN，但发现缓存永远不能命中（MISS），我们需要对添加一个缓存指令（默认是不缓存），打开存储桶设置，桶信息设置为{“cache-control”:“max-age=43200”}，其中43200单位为秒(s)，意思就是说43200秒内CF不会去从源站重新获取资源。 Cloudfalre的ssl设置需要使用full，因为backblaze仅提供https访问地址。 当然你如果觉得文件链接不好看太长了，你也可以使用cloudflare自带的页面规则301 ，缩短链接地址，比如通过 https://img.coca.cc/img.jpg 直接访问 https://f001.backblazeb2.com/file/imgsgj/img.jpg 。 例: 匹配规则 https://img.coca.cc/* 重定向网址到 https://f001.backblazeb2.com/file/imgsgj/$1 加一条页面缓存规则 最后，请注意：Backblaze B2 流出到 Cloudflare 的流量是免费的，也就是说就算 CF 回源 B2 也没有 $0.01/GB 的流出流量费，相当于免费无限流量。不过这并不能阻止坏蛋直接用 B2 的域名（而不是套了 CF 的域名）刷流量。 最后修改：2021 年 03 月 01 日 文章2：Backblaze B2 + Cloudflare CDN + PicGo 前言 近期，由于服务器需要扩展功能，以及阿里云推送日志时有所不便决定重新购买服务器并部署相关网站和服务。决定趁此机会对图片存储进行规范，由于网站未备案，国内的阿里云OSS+阿里云CDN、又拍云、七牛云等厂家提供的服务无法享受，只能将目光转向国外。 原本使用Github+JSDelivr是一个很好的免费图床解决方案，且网上教程也很多，但2020年8月9日JSDelivr发布的新使用政策中第四条引起讨论 123456789101112131415161718194. Prohibited UseThe following behavior is prohibited: 1. Hosting or accessing content that: - contains malware or harmful code in any form, - violates proprietary rights of others, - is sexually explicit, - is potentially illegal in the EU or the USA. 2. Abusing the service and its resources, or using jsDelivr as a general-purpose file or media hosting service. This includes, for example: - running an image hosting website and using jsDelivr as a storage for all uploaded images, - hosting videos, file backups, or other files in large quantities. We recognize that there are legitimate projects that consist of a large number of files, and these are not considered abuse. For example: icons packs, apps, or games with a large number of assets.Copy running an image hosting website and using jsDelivr as a storage for all uploaded images这句话有所歧义，因为无法判断个人博客和文章上传的图片数量和访问量是否会被判定为图片存储站，导致封禁或删除数据，只能寻求其余解决方案。 此时发现Cloudflare Bandwidth Alliance宽带联盟宽带联盟中包含Backblaze，Backblaze到Cloudflare的所有出口流量完全免费。再加上Backblaze对个人用户提供10G的免费存储额度，每天1G的下载量与无限上传量。我们可以同时使用两者达到10G免费额度与不限量上传下载。 在超过免费存储额度之后，相比其他几家国外主流OSS服务提供商，Backblaze的价格也较为低廉，唯一的缺点是目前只支持信用卡支付。 前置条件 一个域名~ 最好是一级域名，即xxx.xxx这种类型的。搜索任意域名供应商即可购买，比较推荐NameSlio，支持支付宝付款，免费的Whois隐私保护，同时价格便宜。.com域名每年仅需要9.95美金，如果不是很在乎可以买其他后缀只买首年，2美金一年。免费域名也有一些可以申请，比较出名的就是freenom的域名了，不过听说今年Cloudflare的免费服务不再支持免费域名，所以只能自己试试是否能够成功。 Backblaze OSS部分 从此处进入，创建Backblaze账号并完善相关信息，直接从首页进入可能没有Sing Up选项 从此处进入控制台，创建Buckets存储桶存储桶 给存储桶起一个名字方便识别且不易被猜测即可，无需在意生成的图片链接长短，后续可以进行重定向方便识别且不易被猜测即可，无需在意生成的图片链接长短，后续可以进行301重定向，并将Files in Bucket are修改为Public 注意：给存储桶起名时尽量起不易被别人猜测的名字，可在其中增加部分随机字符，如c42rx71-example-winer-website，因为在存储桶的模式为Public时，别人只需知道你的OSS服务提供商+存储桶名称+其中一个文件名，即可拼凑出文件真实链接，从而绕过CDN刷空你的免费流量，如果有绑定支付方式还会扣费。 点击Upload/Download上传一张图片或临时文件，用于后续获取存储桶所在的服务器地址 从左侧菜单栏的Browse Files进入刚刚的存储桶并找到上传的文件，点击查看详细信息，记住Friendly URL行的链接内容 从Friendly URL的链接可以看到我们的存储桶位于https://f002.backblazeb2.com/，而/file/example-winer-website则是存放文件目录的相对路径，记住这两个值后登陆Cloudflare进行设置。 Cloudflare部分 打开Cloudflare官网并进行注册 根据提示前往域名注册商修改DNS解析服务器到Cloudflare提供给你的服务器地址不同用户地址不同不同用户地址不同，个人使用选择免费计划即可 添加一条CNAME记录到你刚刚得到的存储桶服务器，二级域名可以根据喜好选择，但一般使用这几种 12345ossimgimagesassetsstatic(不仅存放图片，还存放网站加载时的css、js文件) 此时等待DNS解析完成后我们就完成了通过Cloudflare访问Backblaze的设置，可以使用浏览器的开发者工具，访问二级域名下对应网址来查看是否命中CDN缓存。cf-cache-status行HIT代表命中缓存，MISS代表没有命中CDN缓存，回源到Backblaze，此时会消耗下载流量。 为了避免无法命中缓存或回源次数过多导致加载速度低下，我们需要回到Backblaze进行桶信息设置，添加&#123;&quot;cache-control&quot;:&quot;max-age=86400&quot;&#125;，意味86400秒内Cloudflare不再返回源站重新获取信息。 注意，回源时为CDN节点回源站重新拉去数据，然后再传递给用户，并不是将源站地址直接转给用户，所以无需担心回源过多导致的免费流量配额消耗完毕。max-age可以不用太长，太长的话若源文件发生更改，且站点没有主动推送到CDN节点时会导致用户不能及时得到最新版本。（书写本文时发现BackBlaze也存在免费请求次数显示，B类C类请求每天各2500次，暂时未确定Cloudflare访问是否计算请求次数，故也不建议太短） 可选可选不建议使用的重定向方式不建议使用的重定向方式通过cloudflare自带的页面规则301，对于文件连接进行重定向缩短链接地址。按照下图选项根据喜好进行创建即可，*用于匹配所有的图片路径及名称，$1代表使用星号部分的内容对网址进行补全。 注意： 1.匹配URL时，地址中的/img是必须的否则被转发过的URL会再次匹配到转发规则，造成重定向次数过多或其他位置错误，但是/img可以替换为任意不为/file/example-winer-website(你的存储桶名)的字符串 2.经过测试后发现，使用该方式进行的重定向在开发者工具Network页面可以抓取到重定向后的链接直接新标签打开图片也可以获取直接新标签打开图片也可以获取，从而得到你的存储桶名称以及真是文件名，配合服务器提供商即可拼凑真实地址进行恶意刷流量攻击。故建议使用第8步的第二种创建方式。 可选可选在查找资料时，见到有些地方建议在进行URL重定向后增加一条页面缓存规则来防止缓存失效。按照下图进行配置即可。但是在我进行测试时发现不增加这条内容，也可以命中Cloudflare的CDN缓存，故暂时未添加。也可以在此处增加安全级别选项，并设置为本质上为关，来保证主站被攻击在CDN环节增加验证时，写在本地的Markdown文档能够正常加载图片。 猜测存在此步骤的可能原因是将缓存级别设置无查询字符串时仅在图片后不跟随参数时使用缓存的内容，部分OSS供应商提供追加参数对图片进行处理（如压缩、剪裁、缩放）后发送的功能，若主站缓存级别设置为标准，此处修改部分内容设置后就可以使用那些功能。但Backblaze的免费服务并不包含这些，所以暂时用不到。若以后发现在问题或真正的原因会进行补充说明。 8.可选可选建议使用的重定向方式建议使用的重定向方式由于不使用链接重定向和使用页面规则重定向均会暴露桶名称，我们选择通过重写的方式进行解决。这种方式可以在链接不变的情况下改写其中的内容。这次我们使用规则中的转换规则进行页面重写。匹配主机名用于确定请求来源需要进行重写，且再次匹配完整URI确认不包含已经重写过的链接，避免出现反复重写的错误。重写路径的concat含义为将两字符串拼接，在请求的文件路径前添加存储桶路径，而主机名example.winer.website在使用concat函数时无需书写，会自动添加为传入请求的主机名。（如一定要在concat函数内添加主机名，请不要带http://或https://开头，而是在前面添加/进行替代，例如concat(&quot;/example.winer.website/file/example-winer-website&quot;, http.request.uri.path)） 注：如果页面规则剩余不足或不想使用本方法，也可以参考本文创建私有存储桶并使用Cloudflare Workers来进行访问。鉴于Workers访问方法已存在很久，且有众多其他博主教程，不再进行书写。但Workers同样有免费限额，请注意。 搭配PicGo更好的进行图床食用 首先恭喜你，至此你已经完成了图床基本搭建工作！下面是拓展部分 图床搭建完毕后，若不进行其他操作，每次上传图片都需要打开Backblaze的网站并在完成身份验证后进入桶设置页面进行上传，即不便捷也不友好。因此介绍一款跨平台且同时支持命令行与可视化界面的图片上传工具——PicGo 主要功能即为上传图片到你指定的位置，并获取图片链接，搭配typora编辑器可以直接在粘贴图片时就自动上传并将链接写入Markdown文档，避免图片在其它网站或放在本地后移动文档导致的图片丢失。 进入项目主页，下载并安装PicGo 选择插件设置，搜索s3或进入插件项目主页下载并安装该插件 安装完毕后左侧的图床设置会多出“Amazon S3”，对于所有与S3 API兼容的云存储均可使用 打开的Backblaze官网的AppKeys设置页面，添加一个新的Key建议不要使用建议不要使用MasterApplicationKey，按照如下格式设置并申请Key 注意：Key的最长有效时间为1000天，即86400000秒，过期后请重新申请 记录得到的Key ID、applicationKey、桶名称、桶的Endpoint地址分别填写到对应位置。同时将301跳转或页面重写的网址填写到自定义域名。其余设置无需变更。保存后即可上传图片，也可以修改文件的命名方式或通过修改配置文件进行设置，详见此页面。 注意事项 到此为止所有工作都已完成，但是有一点需要注意： 通过这种方式上传文件，文件路径中如果包含空格，在Backblaze存储时会将空格换为加号，所以路径中包含空格的文件PicGo上传后生成的链接并不正确。 通过此方法搭建的图床或书写的教程，切记不要泄露存储桶名称，避免刷流量，且建议给所有上传文件的命名规则添加哈希值，使其不可猜测，避免存储桶名称暴露时获取其他文件。 同时本文内建立的存储桶并未使用，教程书写完毕后立刻删除，并创建了及其难以猜测的存储桶名称更改了相关地址，无需尝试使用文中或图中的信息进行访问测试。 最后修改：2022 年 08 月 28 日 10 : 37 AM 评论区 刚下飞机的道士 May 24th, 2022 at 11:48 am 感谢大佬文章，现在cloudflare提供了transform rules，可以不用worker进行路径重写了。 sakuya April 9th, 2022 at 02:44 pm 友情提示： 第8步的concat&quot;/example.winer.website/file/example−winer−website&quot;,http.requrst.uri.paht)，似乎多了个括号，以及request、path写错了 winer August 28th, 2022 at 10:36 am @sakuya 谢谢提醒，括号多的那个其实是因为外面有个中文的括号，只看有代码标记的里面就行 不过request和path确实是打错了hhhhh图片里还没错，这就改掉 文章3：Backblaze B2 + Cloudflare B2是Backblaze提供的一个OSS存储服务，有着10G的免费容量以及每天1G的免费流量。而且他还是Cloudflare带宽联盟的成员，通过Cloudflare传输Backblaze中的内容是完全免费的。即使在超出免费额度的情况下，$0.005 GB/Mo的的容量和$0.01 GB/Mo的流量价格比起其他存储服务的价格也十分便宜。 有许多其他文章也介绍了如何使用B2和CF作为免费图床，但现在CF有了新的转换规则功能，和其他文章使用的Worker和页面规则比起来，转换规则提供了更多的免费条目，也更易于使用。 当然用来作为网盘也可以，不过10G就不太够用了。 要求 首先需要注册Backblaze B2和Cloudflare的账号，其次需要一个域名，现在Cloudflare就提供域名购买，也可以从namesilo或者其他地方购买后给Cloudflare解析。Backblaze注册之后需要进行邮箱验证，不然无法创建公开存储桶。 创建存储桶 进入Backblaze的用户管理界面，选择B2云存储下面的桶选项，然后点击创建存储桶，创建时需要输入桶的名称，这个名称会包含在URL中，所以不能与其他人的桶活着自己的其他桶有同样的名字。创建时需要选中公众选项，将其设置为公开的，其他选项不需要修改。 在创建完成后可以在里面上传一张图片，点击上传后的图片，其中友好URL就是要使用的地址，接下来记录下友好URL的主机名，例如f00x.backblaze2.com。 刚创建的存储桶默认不会被Cloudflare缓存，而是每次都要回源，对于图床来说，缓存下来才更方便。点击桶选项，回到刚才创建存储桶的地方，可以看到已经创建好的存储桶，点击桶设定，将桶信息修改为&#123;&quot;cache-control&quot;:&quot;max-age=43200&quot;&#125;，其中max-age=后面的数字为Cloudflare的缓存时长，单位为秒。 配置Cloudflare 在Cloudflare中为图床要使用的子域名创建一个CNAME记录，将其指向刚才记录下的主机名f00x.bckblze2.com，由于要使用Cloudflare的CDN进行缓存，所以要将代理状态设置为已代理。 在创建CNAME记录之后，将友好URL的主机名换成刚创建的域名就可以访问文件了。如果测试时Cloudflare提示错误522，这是因为Backblaze只允许使用Https访问，需要在Cloudflare的SSL/TLS中改成完全（严格）。此外，如果是Cloudflare的Pro付费用户的话，还需要关闭自动签名交换(SXG)，他在速度-优化选项中。 直接使用CNAME域名修改URL的话的话会暴露存储桶的名称，也显得URL十分啰嗦，这时候就需要使用Cloudflare的转换规则来将URL缩短。 选择规则-转换规则，然后点击创建转换规则-重写URL创建一个重写URL的规则，首先为规则取一个名字。如果使用单独的子域名作为专用的图床域名的话，可以直接在字段中选择主机名，在运算符中选择等于，然后在值当中输入子域名。 如果图床并不是使用专门的子域名，需要点击编写表达式，并参照Cloudflare文档来编写如何匹配图床的URL地址。 匹配表达式配置完成后，在下面的重写-路径中选择重写到，在选项中选择Dynamic，如果只想在URL中删去/file/存储桶名称的话，在后面填写concat(&quot;/file/存储桶名称&quot;, http.request.uri.path)，如果有其他要求，也可以参照上面的Cloudflare文档来修改。设置完成后点击部署即可启用该规则。现在输入https://img.example.com/桶中的文件路径或是自定义的地址即可加载存储桶中的图片。 以下是用这种方式上传的图片，另外如果有人认得作者是谁可以在评论里回复一下。 图片略… 参考 Free Image Hosting With Cloudflare Transform Rules and Backblaze B2 Backblaze B2 + Cloudflare CDN可自定义域名的10G高速免费外链图床 Backblaze+CloudFlare实现0成本简单图床","categories":[{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"图床","slug":"图床","permalink":"https://blog1.cpen.top/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"05_Other-使用 Python open 函数批量替换文件内容","slug":"Other/05_Other-Python-open函数批量替换文件内容","date":"2022-12-02T04:00:00.000Z","updated":"2023-02-06T05:00:00.000Z","comments":true,"path":"posts/3ffec809.html","permalink":"https://blog1.cpen.top/posts/3ffec809.html","excerpt":"","text":"2023/02/06 更新 VSCode 集成了 某路径下的文件批量替换指定内容 的功能，更方便 1. 前言 在 jsd 失效之后，博主使用了新的图床方案，需将文章的原 jsd 图片链接替换为新的图片地址 这类脚本在网上有很多，都很推荐，如 批量修改文件内容（Python版） 张洪Heo：用 Python 批量替换 md 文件内容 Justlovesmile：如何自动下载、压缩并批量替换文章中的外链图片 2. 脚本内容 源码来自：批量修改文件内容（Python版） 脚本采用递归的方式，遍历 43~46 行 目录下的所有文件，进行批量替换 说明： 根据自身情况修改 43~46 行 需遍历的目录；修改 47、48 行 需要替换的内容 脚本第 24 行 限制了只筛选出 Markdown 类型的文本文件进行修改，如需修改其他类型的文本文件 需自行更改后缀进行匹配 执行前请先备份源文件，以防出错后无法还原 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/python# -*- coding: UTF-8 -*-# 源码参考 https://blog.csdn.net/qq_38150250/article/details/118026219import osimport re# 文件查找 find . -name file_name -type f# 查找函数：search_path 查找根路径 # 获取文章路径def search(search_path, search_result): # 获取当前路径下地所有文件 all_file = os.listdir(search_path) # 对于每一个文件 for each_file in all_file: # 若文件为一个文件夹 if os.path.isdir(search_path + each_file): # 递归查找 search(search_path + each_file + &#x27;/&#x27;, search_result) # 如果是需要被查找的文件 else: if re.findall(&#x27;.*\\.md$&#x27;, each_file) == [each_file]: # 输出路径 search_result.append(search_path + each_file)# 替换 sed -i &#x27;s/old_str/new_str/&#x27;# 文本替换 replace_file_name 需要替换的文件路径，replace_old_str 要替换的字符，replace_new_str 替换的字符def replace(replace_file_name, replace_old_str, replace_new_str): with open(replace_file_name, &quot;r&quot;, encoding = &quot;UTF-8&quot;) as f1: content = f1.read() f1.close() t = content.replace(replace_old_str, replace_new_str) with open(replace_file_name, &quot;w&quot;, encoding = &quot;UTF-8&quot;) as f2: f2.write(t) f2.close()# 需要改的地方#path = &#x27;E:/code_zone/.history/20220831_blog/source/_posts/&#x27;path_list = [ &#x27;E:/code_zone/hexo-source/source/_posts/&#x27;, &#x27;E:/code_zone/hexo-source-butterfly/source/_posts/&#x27;,]old_str = &#x27;https://cdn.iocdn.cc/npm/mycpen-image-bed@0.0.0-elcfumuvhm/image/&#x27;new_str = &#x27;https://cdn.iocdn.cc/npm/mycpen-image-bed@0.0.0-elcfumuvhm/image/&#x27;search_result = []if __name__ == &#x27;__main__&#x27;: result = [] # 存放文件路径 # 默认当前目录 # path = os.getcwd() for path in path_list: search(path, result) # 获取文章路径 count = 0 for file_name in result: replace(file_name, old_str, new_str) count += 1 print(&quot;&#123;&#125; done &#123;&#125;&quot;.format(file_name, count))# 命令# python E:/code_zone/tools/python-replace/replace.py 3. 参考文章 源码来自：批量修改文件内容（Python版）","categories":[{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/categories/Other/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/tags/Other/"},{"name":"Open","slug":"Open","permalink":"https://blog1.cpen.top/tags/Open/"}]},{"title":"04_Other-使用 Python ftplib 模块同步又拍云云存储数据至本地","slug":"Other/04_Other-Python-ftplib模块同步又拍云云存储至本地","date":"2022-12-01T04:00:00.000Z","updated":"2022-12-01T05:00:00.000Z","comments":true,"path":"posts/4f5c6419.html","permalink":"https://blog1.cpen.top/posts/4f5c6419.html","excerpt":"","text":"1. 前言 在 jsd 失效之后，博主将图床资源从 github 迁移至又拍云云存储上 qiniuClient 是我所知的 云存储管理客户端，有需要的朋友可以下载使用 目前的图床方案是写文章时利用 picgo 上传图片，再通过 Python 脚本同步又拍云上的图片至本地，再将本地图片 push 到 github，通过云服务器（CentOS）计划任务 每天凌晨1点执行以上备份操作 2. 脚本内容 源码来自：https://blog.csdn.net/ouyang_peng/article/details/79271113 又拍云官方教程：创建存储服务和使用 FTP 上传 说明： 脚本执行顺序是先下载云存储资源至本地，再将本地资源上传至云存储，所以云存储上的资源优先级更大，当本地出现同名资源时 会被覆盖 根据自身情况修改 273、274 行 路线、操作员/服务名、token（参考 创建存储服务和使用 FTP 上传），和 290~297 行本地、云存储的资源路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#!/usr/bin/python# -*- coding: UTF-8 -*-from cmath import logfrom ftplib import FTPimport osimport sysimport timeimport socketimport subprocessclass MyFTP: &quot;&quot;&quot; ftp自动下载、自动上传脚本，可以递归目录操作 作者：欧阳鹏 博客地址：http://blog.csdn.net/ouyang_peng/article/details/79271113 &quot;&quot;&quot; def __init__(self, host, port=21): &quot;&quot;&quot; 初始化 FTP 客户端 参数: host:ip地址 port:端口号 &quot;&quot;&quot; # print(&quot;__init__()---&gt; host = %s ,port = %s&quot; % (host, port)) self.host = host self.port = port self.ftp = FTP() # 重新设置下编码方式 #self.ftp.encoding = &#x27;gbk&#x27; self.ftp.encoding = &#x27;utf8&#x27; # 获取脚本路径 path = os.path.dirname(os.path.realpath(__file__)) self.log_file = open(path + &quot;/log.txt&quot;, &quot;a&quot;, encoding=&#x27;utf-8&#x27;) self.file_list = [] def login(self, username, password): &quot;&quot;&quot; 初始化 FTP 客户端 参数: username: 用户名 password: 密码 &quot;&quot;&quot; try: timeout = 60 socket.setdefaulttimeout(timeout) # 0主动模式 1 #被动模式 self.ftp.set_pasv(True) # 打开调试级别2，显示详细信息 # self.ftp.set_debuglevel(2) self.debug_print(&#x27;开始尝试连接到 %s&#x27; % self.host) self.ftp.connect(self.host, self.port) self.debug_print(&#x27;成功连接到 %s&#x27; % self.host) self.debug_print(&#x27;开始尝试登录到 %s&#x27; % self.host) self.ftp.login(username, password) self.debug_print(&#x27;成功登录到 %s&#x27; % self.host) self.debug_print(self.ftp.welcome) except Exception as err: self.deal_error(&quot;FTP 连接或登录失败 ，错误描述为：%s&quot; % err) pass def is_same_size(self, local_file, remote_file): &quot;&quot;&quot;判断远程文件和本地文件大小是否一致 参数: local_file: 本地文件 remote_file: 远程文件 &quot;&quot;&quot; try: remote_file_size = self.ftp.size(remote_file) except Exception as err: # self.debug_print(&quot;is_same_size() 错误描述为：%s&quot; % err) remote_file_size = -1 try: local_file_size = os.path.getsize(local_file) except Exception as err: # self.debug_print(&quot;is_same_size() 错误描述为：%s&quot; % err) local_file_size = -1 self.debug_print(&#x27;local_file_size:%d , remote_file_size:%d&#x27; % (local_file_size, remote_file_size)) if remote_file_size == local_file_size: return 1 else: return 0 def download_file(self, local_file, remote_file): &quot;&quot;&quot;从ftp下载文件 参数: local_file: 本地文件 remote_file: 远程文件 &quot;&quot;&quot; self.debug_print(&quot;download_file()---&gt; local_path = %s ,remote_path = %s&quot; % (local_file, remote_file)) if self.is_same_size(local_file, remote_file): self.debug_print(&#x27;%s 文件大小相同，无需下载&#x27; % local_file) return else: try: self.debug_print(&#x27;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;下载文件 %s ... ...&#x27; % local_file) buf_size = 1024 file_handler = open(local_file, &#x27;wb&#x27;) self.ftp.retrbinary(&#x27;RETR %s&#x27; % remote_file, file_handler.write, buf_size) file_handler.close() except Exception as err: self.debug_print(&#x27;下载文件出错，出现异常：%s &#x27; % err) return def download_file_tree(self, local_path, remote_path): &quot;&quot;&quot;从远程目录下载多个文件到本地目录 参数: local_path: 本地路径 remote_path: 远程路径 &quot;&quot;&quot; print(&quot;download_file_tree()---&gt; local_path = %s ,remote_path = %s&quot; % (local_path, remote_path)) try: self.ftp.cwd(remote_path) except Exception as err: self.debug_print(&#x27;远程目录%s不存在，继续...&#x27; % remote_path + &quot; ,具体错误描述为：%s&quot; % err) return if not os.path.isdir(local_path): self.debug_print(&#x27;本地目录%s不存在，先创建本地目录&#x27; % local_path) os.makedirs(local_path) self.debug_print(&#x27;切换至目录: %s&#x27; % self.ftp.pwd()) self.file_list = [] # 方法回调 self.ftp.dir(self.get_file_list) remote_names = self.file_list self.debug_print(&#x27;远程目录 列表: %s&#x27; % remote_names) for item in remote_names: file_type = item[0] file_name = item[1] local = os.path.join(local_path, file_name) if file_type == &#x27;d&#x27;: print(&quot;download_file_tree()---&gt; 下载目录： %s&quot; % file_name) self.download_file_tree(local, file_name) elif file_type == &#x27;-&#x27;: print(&quot;download_file()---&gt; 下载文件： %s&quot; % file_name) self.download_file(local, file_name) self.ftp.cwd(&quot;..&quot;) self.debug_print(&#x27;返回上层目录 %s&#x27; % self.ftp.pwd()) return True def upload_file(self, local_file, remote_file): &quot;&quot;&quot;从本地上传文件到ftp 参数: local_path: 本地文件 remote_path: 远程文件 &quot;&quot;&quot; if not os.path.isfile(local_file): self.debug_print(&#x27;%s 不存在&#x27; % local_file) return if self.is_same_size(local_file, remote_file): self.debug_print(&#x27;跳过相等的文件: %s&#x27; % local_file) return buf_size = 1024 file_handler = open(local_file, &#x27;rb&#x27;) self.ftp.storbinary(&#x27;STOR %s&#x27; % remote_file, file_handler, buf_size) file_handler.close() self.debug_print(&#x27;上传: %s&#x27; % local_file + &quot;成功!&quot;) def upload_file_tree(self, local_path, remote_path): &quot;&quot;&quot;从本地上传目录下多个文件到ftp 参数: local_path: 本地路径 remote_path: 远程路径 &quot;&quot;&quot; if not os.path.isdir(local_path): self.debug_print(&#x27;本地目录 %s 不存在&#x27; % local_path) return self.ftp.cwd(remote_path) self.debug_print(&#x27;切换至远程目录: %s&#x27; % self.ftp.pwd()) local_name_list = os.listdir(local_path) for local_name in local_name_list: src = os.path.join(local_path, local_name) if os.path.isdir(src): try: self.ftp.mkd(local_name) except Exception as err: self.debug_print(&quot;目录已存在 %s ,具体错误描述为：%s&quot; % (local_name, err)) self.debug_print(&quot;upload_file_tree()---&gt; 上传目录： %s&quot; % local_name) self.upload_file_tree(src, local_name) else: self.debug_print(&quot;upload_file_tree()---&gt; 上传文件： %s&quot; % local_name) self.upload_file(src, local_name) self.ftp.cwd(&quot;..&quot;) def close(self): &quot;&quot;&quot; 退出ftp &quot;&quot;&quot; self.debug_print(&quot;close()---&gt; FTP退出&quot;) self.ftp.quit() self.log_file.close() def debug_print(self, s): &quot;&quot;&quot; 打印日志 &quot;&quot;&quot; self.write_log(s) def deal_error(self, e): &quot;&quot;&quot; 处理错误异常 参数： e：异常 &quot;&quot;&quot; log_str = &#x27;发生错误: %s&#x27; % e self.write_log(log_str) sys.exit() def write_log(self, log_str): &quot;&quot;&quot; 记录日志 参数： log_str：日志 &quot;&quot;&quot; time_now = time.localtime() date_now = time.strftime(&#x27;%Y-%m-%d&#x27;, time_now) format_log_str = &quot;%s ---&gt; %s \\n &quot; % (date_now, log_str) print(format_log_str) self.log_file.write(format_log_str) def get_file_list(self, line): &quot;&quot;&quot; 获取文件列表 参数： line： &quot;&quot;&quot; file_arr = self.get_file_name(line) # 去除 . 和 .. if file_arr[1] not in [&#x27;.&#x27;, &#x27;..&#x27;]: self.file_list.append(file_arr) def get_file_name(self, line): &quot;&quot;&quot; 获取文件名 参数： line： &quot;&quot;&quot; pos = line.rfind(&#x27;:&#x27;) while (line[pos] != &#x27; &#x27;): pos += 1 while (line[pos] == &#x27; &#x27;): pos += 1 file_arr = [line[0], line[pos:]] return file_arrif __name__ == &quot;__main__&quot;: # 清除日志 path = os.path.dirname(os.path.realpath(__file__)) # 脚本路径 if os.path.exists(path + &#x27;/log.txt&#x27;): log_file = path + &#x27;/log.txt &#x27;if os.sep == &quot;/&quot; else path + &#x27;\\\\&#x27; + &#x27;log.txt&#x27; subprocess.Popen(f&#x27;rm -rf &#123;log_file&#125;&#x27;, shell=True) time.sleep(1) my_ftp = MyFTP(&quot;v0.ftp.upyun.com&quot;) my_ftp.login(&quot;xxx/xxx&quot;, &quot;tokenxxxxxxxxx&quot;) # 下载单个文件 # my_ftp.download_file(&quot;E:/code_zone/image_bed/image/wallpaper/1.jpg&quot;, &quot;/image/wallpaper/1.jpg&quot;) # 上传单个文件 # my_ftp.upload_file(&quot;G:/ftp_test/Release/XTCLauncher.apk&quot;, &quot;/App/AutoUpload/ouyangpeng/I12/Release/XTCLauncher.apk&quot;) # 下载目录 # image.cpen.top/image/ → 本地 E:/code_zone/image_bed/image/ (本地图床目录, 又拍云路径) if os.sep == &quot;\\\\&quot;: my_ftp.download_file_tree(&quot;E:/code_zone/image_bed/image/&quot;, &quot;/image/&quot;) elif os.sep == &quot;/&quot;: # aliyun my_ftp.download_file_tree(&quot;/root/code_zone/image_bed/image/&quot;, &quot;/image/&quot;) # 上传目录 # 本地 E:/code_zone/image_bed/image/ → image.cpen.top/image/ (本地图床目录, 又拍云路径) if os.sep == &quot;\\\\&quot;: # Windows my_ftp.upload_file_tree(&quot;E:/code_zone/image_bed/image/&quot;, &quot;/image/&quot;) my_ftp.close() elif os.sep == &quot;/&quot;: # aliyun my_ftp.upload_file_tree(&quot;/root/code_zone/image_bed/image/&quot;, &quot;/image/&quot;) my_ftp.close()# 命令# python E:/code_zone/tools/python-ftp/ftp.py# python3 /root/code_zone/tools/python-ftp/ftp.py 执行命令 12345# Windows 终端python E:/code_zone/tools/python-ftp/ftp.py# 类 Unix 终端python3 /root/code_zone/tools/python-ftp/ftp.py 3. 参考文章 源码来自：Python实现的FTP上传和下载功能 又拍云官方教程：创建存储服务和使用 FTP 上传","categories":[{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/categories/Other/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/tags/Other/"},{"name":"FTP","slug":"FTP","permalink":"https://blog1.cpen.top/tags/FTP/"}]},{"title":"03_Other-PC端环境记录","slug":"Other/03_Other-PC环境记录","date":"2022-11-01T04:00:00.000Z","updated":"2023-03-11T05:00:00.000Z","comments":true,"path":"posts/583c5c34.html","permalink":"https://blog1.cpen.top/posts/583c5c34.html","excerpt":"","text":"前言 记录个人电脑环境 更新时间：2023.03.10 Windows 202303 系统重置记录 软件 联想电脑管家 联想应用商店 QQ Clash for Windows Typora WeGame Google Chrome Microsoft Edge Firefox Logitech G HUB 搜狗输入法 网易邮箱大师 网易有道词典 滴答清单 微信 腾讯会议 百度网盘 阿里云盘 哔哩哔哩 PotPlayer Sublime Text Sublime Text 汉化教程 Sublime Text WPS Office 腾讯文档 XMind ZEN（本地安装包） XMind 8 WinRAR Git Windows Terminal WSL 2 VMware Workstation Pro CentOS、安装教程 Xshell、Xftp Visual Studio Code SwitchHosts PicGo、教程、密钥 uTools Snipaste Python PyCharm Navicat Node.js 联想软件：关闭Win10系统自动更新 联想软件：网络图标叹号修复工具 Listen 1 LX Music Telegram、汉化 赛尔号 Tai GitHub image_bed ultra-tinypng tools hexo-source-butterfly hexo-source hexo-source-diary nav dino VSCode 简中插件 GitLens Material Icon Theme Git History WakaTime 参考教程 本文 GIT SSH 密钥认证教程 PyCharm 汉化 果壳剥壳 vscode 配置 gitbash 终端 Hexo 官网 npm 淘宝源 Typora 页面美化 PicGo安装插件compress 安装 Node.js 202211 第三方分享网站：果壳剥壳 name description 联想电脑管家、联想应用商店、Legion Zone、Logitech G HUB、小米云服务、金山打字通、搜狗输入法、网易邮箱大师、网易有道词典、滴答清单 腾讯QQ、微信、腾讯会议、向日葵 网易云音乐、酷我音乐、QQ音乐 百度网盘、阿里云盘、迅雷 网盘 哔哩、哔哩哔哩 UWP 哔哩哔哩uwp draw.io 流程拓扑图 PotPlayer 64 bit 视频播放 Typora、Sublime Text、WPS Office、XMind 8、XMind 2021、腾讯文档、MarkdownPad 2 文本编辑 WSA Toolbox WSA Chrome、Firefox、Edge 浏览器 Windows Terminal、PowerShell 7、Git bash 终端 WSL2、Ubuntu 20.04 LTS、WSA 虚拟机 VMware Workstation Pro、Xshell 7、Xftp 7 Clash for Windows、Steam++ 代理客户端 PyCharm、Visual Studio Code、HBuilder X、CodeBlocks、Visual C++ 6.0 开发工具 Postman 接口调试 SwitchHosts 本地解析 Navicat Premium 15、SQLyog、QuickRedis、Another Redis Desktop Manager 数据库客户端 PicGo 图片上传 uTools、Everything 剪贴板，取色 Snipaste 截图 mycpen/ultra-tinypng 图片压缩。原地址：libudu/ultra-tinypng mycpen/tools 私有仓库。ftp图床同步、内容替换 软件备份 bilibili下载助手 (谷歌插件) 引导页：csser.top、docs.qq.com crx文件备份 (v3.0.0)：gitee.com/mycpen/cdn3","categories":[{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/categories/Other/"}],"tags":[{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/tags/Other/"},{"name":"工具","slug":"工具","permalink":"https://blog1.cpen.top/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"06_Hexo-elemecdn 加速 Butterfly 第三方资源","slug":"Hexo/06_Hexo-elemecdn加速Butterfly第三方资源","date":"2022-10-25T04:00:00.000Z","updated":"2023-04-13T05:00:00.000Z","comments":true,"path":"posts/9b5a2768.html","permalink":"https://blog1.cpen.top/posts/9b5a2768.html","excerpt":"","text":"2023/01/09 更新 今天发现 Butterfly 文档 有介绍自定义 CDN 的配置项，只需简单配置即可完成需求，所以之前写的东西 属于是 画蛇添足，参考价值不高 官方样例中的 cdn.staticfile.org CDN 加速由七牛云提供，技术社区掘金支持，可以直接填入使用 个人示例如下（主题配置文件） 12345678910111213141516171819202122# CDN# Don&#x27;t modify the following settings unless you know how they work# 非必要請不要修改CDN: # The CDN provider of internal scripts (主題內部 js 的 cdn 配置) # option: local/jsdelivr/unpkg/cdnjs/custom # Dev version can only choose. ( dev版的主題只能設置為 local ) internal_provider: local # The CDN provider of third party scripts (第三方 js 的 cdn 配置) # option: local/jsdelivr/unpkg/cdnjs/custom # when set it to local, you need to install hexo-butterfly-extjs # third_party_provider: jsdelivr third_party_provider: custom # Add version number to CDN, true or false version: false # Custom format # For example: https://cdn.staticfile.org/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;min_cdnjs_file&#125; custom_format: https://cdn.staticfile.org/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;min_cdnjs_file&#125; 想用 elemecdn 的话，custom_format 配置项该怎么写 我也不清楚。尝试写 https://npm.elemecdn.com/$&#123;name&#125;$&#123;verType&#125;/$&#123;file&#125; 或 https://npm.elemecdn.com/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;min_cdnjs_file&#125; 都失败了 想用 elemecdn 的话，Butterfly 文档 给出了格式： 以下步骤已过时 前言 博客异常加载，f12发现 https://unpkg.com/swiper/swiper-bundle.min.js （主因）和 https://unpkg.com/@fancyapps/ui/dist/fancybox.umd.js 报 520（520，当源站服务器向 CDN 返回空白、未知或意外响应时，会发生 520 错误），日常都返的 200 基于此有了换 cdn 的想法。butterfly 官方教程 介绍了 local/jsdelivr/unpkg/cdnjs/custom 这些选择，都不是想要的，看到别人用的 Element cdn，学习一下 步骤 参考文章：butterfly官方教程#CDN、安知鱼 - 可用cdn整理、张洪 Heo - Butterfly CDN链接更改指南 修改源码： 修改 themes/butterfly/scripts/events/cdn.js，新增 elemecdn 字段 1elemecdn: `https://npm.elemecdn.com/$&#123;name&#125;$&#123;verType&#125;/$&#123;file&#125;`, 修改 _config.butterfly.yml，CDN.third_party_provider f12 看了下 网络，替换后没异常 根据 张洪Heo：Butterfly CDN链接更改指南 按需替换 cdn链接（需注意变量名，比如butterfly v4.4.0 fontawesome 写成 fontawesomeV6 似乎才会生效 Butterfly v4.8.0 变量名已改为 fontawesome） 12345678910111213141516171819202122232425262728293031323334CDN: option: # 张洪Heo https://blog.zhheo.com/p/790087d9.html jquery: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js pjax: https://npm.elemecdn.com/pjax@latest/pjax.min.js sharejs: https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js sharejs_css: https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css gitalk: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.js gitalk_css: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.css valine: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.16/Valine.min.js disqusjs: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/disqusjs/1.3.0/disqus.js disqusjs_css: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/disqusjs/1.3.0/disqusjs.css waline: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/waline/1.5.4/Waline.min.js lazyload: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js instantpage: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js typed: https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/typed.js/2.0.12/typed.min.js # fancybox_css: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css # fancybox: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js medium_zoom: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/medium-zoom/1.0.6/medium-zoom.min.js snackbar_css: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css snackbar: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js fontawesome: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css # fontawesomeV6: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css # translate: https://npm.elemecdn.com/js-heo@1.0.6/translate/tw_cn.js # 与主题原文件不符 aplayer_css: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css aplayer_js: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js meting_js: https://npm.elemecdn.com/js-heo@1.0.12/metingjs/Meting.min.js prismjs_js: https://npm.elemecdn.com/prismjs@1.1.0/prism.js prismjs_lineNumber_js: https://npm.elemecdn.com/prismjs/plugins/line-numbers/prism-line-numbers.min.js prismjs_autoloader: https://npm.elemecdn.com/prismjs/plugins/autoloader/prism-autoloader.min.js justifiedGallery_js: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js justifiedGallery_css: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/justifiedGallery/3.8.1/css/justifiedGallery.min.css #twikoo: https://npm.elemecdn.com/twikoo@1.6.8/dist/twikoo.all.min.js","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"},{"name":"Element","slug":"Element","permalink":"https://blog1.cpen.top/tags/Element/"}]},{"title":"05_Hexo-twikoo数据从MongoDB导出-js适配pjax","slug":"Hexo/05_Hexo-twikoo数据从MongoDB导出-js适配pjax","date":"2022-10-24T04:00:00.000Z","updated":"2022-10-24T05:00:00.000Z","comments":true,"path":"posts/51a9ee30.html","permalink":"https://blog1.cpen.top/posts/51a9ee30.html","excerpt":"","text":"一. Twikoo数据从MongoDB导出 前言 参考文章 iMaeGoo、张时贰 记录 twikoo 由 vercel + mongodb 改为 私有部署，数据导出过程 Win 下使用 mongoexport 和客户端工具 失败（个人原因，作者的样例 是成功的），转而用云主机（CentOS 8.2）导出数据 步骤 参考自 iMaeGoo、张时贰 MongoDB官网下载 Database Tools，解压安装 12345# 登录 Vercel 管理后台，点开 Twikoo 的环境，点击上方的 Settings，点击左侧的 Environment Variables，在页面下方找到 MONGODB_URI，点击对应的小眼睛图标，会出现数据库连接地址，点击以复制这串地址；# 如果地址中包含参数，请先删去参数，参数即 “?” 和 “?” 后面的部分，例如 ?journal=true&amp;w=majority；# 打开一个命令行窗口，粘贴以下命令：mongoexport --uri 这里换成刚才复制的地址 --collection comment --type json --out twikoo-comments.json 二. js文件适配 PJAX 参考文章： 张洪Hexo - pjax无法生效解决办法，butterfly主题维护你的pjax Leonus - 评论区 心流 - 记录一次因为pjax导致js无法生效以及解决方案 butterfly主题下 butterfly的话就使用data-pjax属性来让js文件重载，因为这个是butterfly中写好的规则： 1&lt;script src=&quot;https://cdn.zhheo.com/JS-Heo/bb/showbb_in_index.js&quot; data-pjax=&quot;&quot; defer=&quot;&quot;&gt;&lt;/script&gt; 在自定义js文件按照下面这样写即可，可以把代码弄成一个函数，然后把函数名放在下面的函数里面 1234567function whenDOMReady() &#123; //此处填写需要执行的代码，如: //leonus.demo()&#125;whenDOMReady() //打开网站之后先执行一次函数document.addEventListener(&quot;pjax:complete&quot;, whenDOMReady) //pjax加载完成之后执行上面函数","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"},{"name":"Twikoo","slug":"Twikoo","permalink":"https://blog1.cpen.top/tags/Twikoo/"},{"name":"PJAX","slug":"PJAX","permalink":"https://blog1.cpen.top/tags/PJAX/"}]},{"title":"04_Hexo-多平台部署-云服务器-GitHub-Gitee","slug":"Hexo/04_Hexo-多平台部署","date":"2022-10-23T04:00:00.000Z","updated":"2022-10-23T05:00:00.000Z","comments":true,"path":"posts/38874.html","permalink":"https://blog1.cpen.top/posts/38874.html","excerpt":"","text":"一. 开篇词 1.1 前言 官方文档介绍了 Hexo 可以同时一键部署到多个平台，只需要同时使用多个 deployer。 中文官方文档 Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 1$ hexo deploy 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12deploy: type: git 您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。 12345deploy:- type: git repo:- type: heroku repo: 1.2. 说明 使用 Git Hooks 同步 Hexo 生成的静态文件。（后期我弃用 git，改用 rsync 了） 二. 步骤 2.1 云服务器创建 Git 仓库 123456789101112131415161718$ cd /opt/git/$ git init --bare hexo.git # 创建 Hexo 远程仓库 git init --bare 仓库名.git$ cd /opt/git/hexo.git/hooks/ $ vim post-receive #!/bin/bashgit --work-tree=/opt/www/hexo --git-dir=/opt/git/hexo.git checkout -f# --work-tree=/opt/www/hexo 设置工作树的路径# --git-dir=/opt/git/hexo.git 设置存储库的路径$ chmod +x post-receive # 给钩子文件添加执行权限$ mkdir /opt/www/hexo # 创建工作树路径$ chmod -R 777 /opt/www/hexo # 授权，否则到后面访问报 403 2.1.2 deployer 使用 rsync 进行部署 前言：后面发现使用 git 上传至云服务器速度太慢了（不清楚啥原因），改用 rsync。 git 上传速度如下图 使 git bash 支持 rsync（Windows） 参考 https://blog.csdn.net/m0_48613893/article/details/124104757 https://blog.csdn.net/qq_38689395/article/details/125758842 如果文件重复，就跳过 如果出错就修改文件名 .\\usr\\bin\\msys-xxhash-0.8.0.dll → msys-xxhash-0.dll ./_config.yml 文件 123456789deploy:- type: rsync host: IP地址 user: 使用者名称 root: 远程主机的根目录 port: 22 delete: true verbose: true ignore_errors: false 参考 https://hexo.io/zh-cn/docs/one-command-deployment#Rsync 在传大文件（也就10M）时依旧很慢，但比前者速度快些。 2.2 配置本地Hexo _config.yml ./_config.yml 文件，同步部署 GitHub、Gitee、云服务器 123456789101112131415161718# Deployment - 部署## Docs: https://hexo.io/zh-cn/docs/one-command-deployment.htmldeploy:- type: git repository: root@IP地址:/opt/git/hexo.git branch: master commit: Site updated message: hexo &#123;&#123; now(&#x27;YYYYMMDD&#x27;) &#125;&#125;- type: git repository: git@github.com:mycpen/mycpen.github.io.git branch: main commit: Site updated message: hexo &#123;&#123; now(&#x27;YYYYMMDD&#x27;) &#125;&#125; # message为自定义提交信息，默认为 Site updated: YYYY-MM-DD HH:mm:ss- type: git repository: git@gitee.com:mycpen/mycpen.gitee.io.git branch: master commit: Site updated message: hexo &#123;&#123; now(&#x27;YYYYMMDD&#x27;) &#125;&#125; 2.3 配置 SSH 免密登录 本地 SSH 公钥 如~/.ssh/id_rsa.pub 内容添加至云服务器 ~/.ssh/authorized_keys 中 2.4 部署 本地 Hexo 源文件项目下敲 1hexo clean ; hexo g ; hexo d 2.5 使用 NGINX 做 Web 服务器 新增虚拟主机配置 12345678910111213141516171819202122$ cat /usr/local/nginx/conf/conf.d/blog.cpen.top.confserver &#123; listen 80; listen 443 ssl; server_name blog.cpen.top; error_page 404 /404.html; # 强制HTTPS跳转 if ($scheme = &quot;http&quot;) &#123; return 307 https://$host$request_uri; &#125; root /opt/www/hexo; ssl_certificate /usr/local/nginx/ssl/blog.cpen.top.pem; ssl_certificate_key /usr/local/nginx/ssl/blog.cpen.top.key; access_log /data/service_logs/nginx/blog.cpen.top_access.log misc; error_log /data/service_logs/nginx/blog.cpen.top_error.log;&#125; 最后浏览器访问 https://blog.cpen.top/ 三. 注意点 配置 SSH 免密； 存储目录授权； 给工作树路径 /opt/www/hexo 777 权限，~~一开始没授权 访问报 403，环境为 CentOS 8.2；~~原因找到了，第 5 点。 开放端口。注意是否需要在云服务器新增安全组策略，80、443 端口需要打开； SELinux 等原因。 403 权限问题 后面查询发现了 403 的原因，Nginx 编译安装时我指定了启动用户为 普通用户（默认为 nobody），导致起的工作进程权限不够。而 Hexo 上传的新的静态文件权限不为 777。 所以修改 Nginx 的启动用户为 root。 1234$ vim /usr/local/nginx/conf/nginx.confuser root;$ nginx -s reload 四. 参考文章 官方文档 一键部署 * 使用 Git Hooks 部署至云服务器 使用 Git Hooks 部署至云服务器 使用 Git Hooks 部署至云服务器 新增 git 用户、授权目录 * 访问403 修改 Nginx 启动用户为 root * 访问403 授权 777 目录 访问 403 CentOS 8 环境 访问 403 SELinux 未关闭","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://blog1.cpen.top/tags/Troubleshooting/"},{"name":"Git","slug":"Git","permalink":"https://blog1.cpen.top/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"}]},{"title":"03_Hexo-Github Pages 个人博客源文件备份迁移","slug":"Hexo/03_Hexo-Github-Pages-个人博客源文件备份","date":"2022-10-22T04:00:00.000Z","updated":"2022-10-22T05:00:00.000Z","comments":true,"path":"posts/43907.html","permalink":"https://blog1.cpen.top/posts/43907.html","excerpt":"","text":"Github Pages 个人博客源文件 1. 起因 源文件保存问题：Hexo 搭建的个人博客，其远程仓库只保存 Hexo 发布后的 Html 静态文件，博客的源 Markdown 文件、主题配置等资源还在本地； 源文件隐私：考虑到源文件的隐秘性，放弃了新建分支存放源文件，而采用新建项目来存放。 2. 作用 源文件备份； 博客的可移植性。 3. 注意点 删除 themes 文件下 clone 的主题文件下的 .git 文件； node-modules/ 中，自定义了一些配置，改动了源码，需要同步，.gitignore 中不写入； .gitignore 配置如下 12345.DS_Storedb.json*.logpublic/.deploy*/ 4. 配置步骤 将仓库克隆至本地； 安装 Node.js 和 GIt；官方中文文档 安装 Hexo； 1$ npm install -g hexo-cli 如之前未配置 Git 信息，则需配置下； 12git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 执行 Hexo 命令，生成静态文件、部署网站等。例如： 1hexo clean ; hexo g ; hexo d ; hexo s 过程顺利。 提交本地源文件变更。 1git pull ; git add . ; git commit -m &#x27;backup&#x27; ; git push 命令组合 git pull ; hexo clean ; hexo g ; hexo d ; git add . ; git commit -m 'backup' ; git push 5. 参考文章 Hexo 和博客源文件之间的关系 官方文档分支示例为 gh-pages 新建仓库样例1 新建仓库样例2 新建仓库样例3 新建分支样例1 新建分支样例2","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"}]},{"title":"02_Hexo-出错排查-Nunjucks Error","slug":"Hexo/02_Hexo-出错排查","date":"2022-10-21T04:00:00.000Z","updated":"2022-10-21T05:00:00.000Z","comments":true,"path":"posts/5162.html","permalink":"https://blog1.cpen.top/posts/5162.html","excerpt":"","text":"Hexo 出错排查 一. Nunjucks Error 现象描述 Unhandled rejection Nunjucks Error: _posts/xxx.md [Line 84, Column 13] unknown block tag: 标签 解决办法 参考 https://hexo.io/docs/troubleshooting.html#Escape-Contents https://blog.csdn.net/Calvin_zhou/article/details/109303640 泄露（Escape）内容 Hexo 使用 Nunjucks 来解析文章（旧版本使用 Swig，两者语法类似），内容若包含 &#123;&#123; &#125;&#125; 或 &#123;% %&#125; 可能导致解析错误，您可以用 raw 标签包裹，single backtick &#123;&#123; &#125;&#125; 或 triple backtick 来避免潜在问题发生。 Alternatively, Nunjucks tags can be disabled through the renderer’s option (if supported), API or front-matter. 123&#123;% raw %&#125;Hello &#123;&#123; world &#125;&#125;&#123;% endraw %&#125; 123```Hello &#123;&#123; world &#125;&#125;```","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://blog1.cpen.top/tags/Troubleshooting/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"}]},{"title":"02_Error-记 Win下 Git 忘加入 PATH","slug":"Error/02_Error-Win下Git未加入PATH","date":"2022-10-20T04:00:00.000Z","updated":"2022-10-20T05:00:00.000Z","comments":true,"path":"posts/cb0ae693.html","permalink":"https://blog1.cpen.top/posts/cb0ae693.html","excerpt":"","text":"1. 问题描述 右键 vscode 打开项目，使用 git bash 作为终端 敲命令，有些仓库出现 bash: xxx: command not found 原因：git 下的 bin 目录未加入环境变量，基础命令找不到 2. 加入环境变量 xxx/git/bin 加入 PATH 变量 参考自：https://blog.csdn.net/u012724595/article/details/114740935 后话：xxx/bin/cmd 应该是安装 git 的时候选勾加上的。直接右键 git bash 是能查找到命令的，先前 用 vscode 打开经常用的仓库也能找到命令（为啥没报 not found 不确定原因）","categories":[{"name":"Error","slug":"Error","permalink":"https://blog1.cpen.top/categories/Error/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://blog1.cpen.top/tags/Error/"},{"name":"Git","slug":"Git","permalink":"https://blog1.cpen.top/tags/Git/"}]},{"title":"02_Other-AList 搭建云盘","slug":"Other/02_Other-AList 搭建云盘","date":"2022-10-19T04:00:00.000Z","updated":"2022-10-19T05:00:00.000Z","comments":true,"path":"posts/6a2caa19.html","permalink":"https://blog1.cpen.top/posts/6a2caa19.html","excerpt":"","text":"1. 参考链接 作者 Xhofe AList 官方文档 官方文档.指南 官方文档.指南.添加存储 官方文档.配置 Github 地址 Special sponsors 找资源 - 阿里云盘资源搜索引擎 KinhDown 百度云盘不限速下载！永久免费！已稳定运行3年！非常可靠! AList：🗂️ 一个支持多种存储的文件列表程序，使用 Gin 和 Solidjs。 1234567891011121314151617181920212223使用简单AList 从一开始就设计为易于安装，并且可以在所有平台上使用。多种存储AList 支持多个存储提供商，包括本地存储、阿里云盘、OneDrive、Google Drive 等，且易于拓展。支持 WebDAVAList 支持所有 WebDAV 存储，这是一种用于访问文件的标准。黑暗模式自由切换明暗模式受保护的路由为特定路径添加密码保护和身份验证文件预览支持视频、音频、文档、PDF、图片预览等，甚至支持 ipa 安装打包下载使用浏览器的 stream api 支持打包下载，无需使用服务器更多新功能包括文本编辑器、README/HTML 渲染、文件永久链接、Cloudflare Workers 代理等 123# 一键脚本curl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s install 12345678910111213# 反向代理location / &#123; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Range $http_range; proxy_set_header If-Range $http_if_range; proxy_redirect off; proxy_pass http://127.0.0.1:5244; # the max size of file to upload client_max_body_size 20000m;&#125; 1234567891011121314# 命令启动: systemctl start alist关闭: systemctl stop alist配置开机自启: systemctl enable alist取消开机自启: systemctl disable alist状态: systemctl status alist重启: systemctl restart alistcd /opt/alist# 运行程序./alist server# 获得管理员信息./alist admin 2. 个人样例 反向代理 1234567891011121314151617181920212223242526272829303132333435# root @ CentOS in /usr/local/nginx/conf/conf.d$ cat cpen.top.conf...# AList 个人云盘# https://github.com/alist-org/alist/blob/main/README_cn.mdserver &#123; listen 8004 ssl; server_name cpen.top; location / &#123; proxy_pass http://127.0.0.1:5244; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Range $http_range; proxy_set_header If-Range $http_if_range; proxy_redirect off; # the max size of file to upload client_max_body_size 20000m; proxy_connect_timeout 120; # 加大120 proxy_send_timeout 120; # 加大120 proxy_read_timeout 120; # 加大120 proxy_http_version 1.1; # 开启后端，长连接 proxy_set_header Connection &quot;&quot;; # 开启后端，长连接 &#125; ssl_certificate /usr/local/nginx/ssl/cpen.top.pem; ssl_certificate_key /usr/local/nginx/ssl/cpen.top.key; access_log /data/service_logs/nginx/cpen.top_access.log misc; error_log /data/service_logs/nginx/cpen.top_error.log;&#125; 设置.全局.自定义内容 12&lt;div style=&quot;display: flex; flex-direction: column; align-items: center;&quot;&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; class=&quot;chakra-link line1 css-f4h6uy&quot; href=&quot;http://beian.miit.gov.cn&quot; style=&quot;&quot;&gt;苏ICP备xxx号&lt;/a&gt;&lt;/div&gt;","categories":[{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/categories/Other/"}],"tags":[{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/tags/Other/"},{"name":"AList","slug":"AList","permalink":"https://blog1.cpen.top/tags/AList/"}]},{"title":"30_Linux基础-shell编程-sed","slug":"Linux_基础/30_linux基础-shell编程-sed","date":"2022-10-18T04:00:00.000Z","updated":"2022-10-18T05:00:00.000Z","comments":true,"path":"posts/4cb758ea.html","permalink":"https://blog1.cpen.top/posts/4cb758ea.html","excerpt":"","text":"一. sed的整行替换 c 1234567#示例：sed的整行替换 c[root@cPen_A 10]# cp /etc/sysconfig/selinux .[root@cPen_A 10]# sed -i &#x27;/^SELINUX=/c SELINUX=disabled&#x27; selinux [root@cPen_A 10]# cp /etc/ssh/sshd_config .[root@cPen_A 10]# sed -i &#x27;/^#Port/c Port 2233&#x27; sshd_config [root@cPen_A 10]# cat sshd_config |grep PortPort 2233 123456789101112131415161718#注：对文件的修改 用sed比较好[root@cPen_A 10]# cp /etc/sysconfig/network-scripts/ifcfg-ens33 . #注：网卡配置文件[root@cPen_A 10]# vim ifcfg-ens33 BOOTPROTO=&quot;none&quot; #注：none 静态配置ip地址 dhcp动态获得ipNAME=&quot;ens33&quot; #注：网卡连接的名字UUID=&quot;831f1350-14c2-46db-bf53-1937c5feb8f5&quot; #注：网卡的设备编号的唯一值DEVICE=&quot;ens33&quot; #注：网卡设备的名字ONBOOT=&quot;yes&quot; #注：开机的时候是否激活 yes表示激活启动 no禁用IPADDR=&quot;192.168.0.38&quot; #注：ip地址NETMASK=255.255.255.0 #注：子网掩码GATEWAY=192.168.0.1 #注：默认网关 路由器的接口地址DNS1=192.168.0.1 #注：首选dns服务器DNS2=114.114.114.114 #注：备用dns服务器#示例：将ip地址替换，使用sed 整行替换#注：光猫/调制解调器（modem） 需求分析： read或者位置变量 修改配置文件 sed （整行替换 或 局部替换） ip合法判断 --&gt; 正则 二. sed的w命令 写入文件 12345678sed的w命令 写入文件#示例：把以#开头的行 不写到文件里[root@cPen_A 10]# sed &#x27;/^#/!w a.txt&#x27; selinux [root@cPen_A 10]# cat selinux |sed &#x27;/^#/!w abc.txt&#x27;[root@cPen_A 10]# cat a.txt SELINUX=disabledSELINUXTYPE=targeted 三. sed的替换 --&gt;核心功能 12345678910111213141516171819202122232425[root@cPen_A 10]# sed -i &#x27;s/xiaomi/redmi/&#x27; phone.txt #注：替换每一行的第1个xiaomi替换为redmi[root@cPen_A 10]# sed -i &#x27;s/vivo/nokia/2&#x27; phone.txt #注：替换每一行的第2个vivo替换为nokia[root@cPen_A 10]# sed -i &#x27;s/oppo/meizu/g&#x27; phone.txt #注：每一行所有的oppo替换为meizu[root@cPen_A 10]# sed -i &#x27;s/xiaomi/redmi/2g&#x27; phone.txt #注：替换每一行的第2个后所有xiaomi全部替换为redmi[root@cPen_A 10]# sed -i &#x27;/^ONBOOT/ s/yes/no/&#x27; ifcfg-ens33 #注：查找替换 （局部替换）[root@cPen_A 10]# sed -i &#x27;8 s/192.168.0.1/192.168.0.2/&#x27; ifcfg-ens33 #注：根据 行号替换 （局部替换）[root@cPen_A 10]# sed -i &#x27;8 s/GATEWAY.*/GATEWAY=192.168.0.2/&#x27; ifcfg-ens33 #注：整行替换#示例：把所有apple删除 --&gt; 删除部分字符串[root@cPen_A 10]# sed -i &#x27;s/apple//g&#x27; phone.txt #注：拿空的去替换它\\n 换行\\t tab[root@cPen_A 10]# sed -i &#x27;s/s/\\t/g&#x27; phone.txt ---------------------------------------------------------[root@cPen_A 10]# sed -i &#x27;1c sanchuang&#x27; /etc/hostname [root@cPen_A 10]# sed -i &#x27;3,5s/^/#/&#x27; phone.txt #注：3-5行加注释[root@cPen_A 10]# sed -i &#x27;3,5s/$/ sanchuang/&#x27; phone.txt #注：3-5行 末尾加sanchuang[root@cPen_A 10]# sed -i &#x27;/^DNS2/ s/^/#/&#x27; ifcfg-ens33 #注：注释#DNS2=114.114.114.114 12#示例：[root@cPen_A 10]# sed -i &#x27;s#/sbin/nologin#/bin/bash#&#x27; passwd 1234567891011121314151617#示例：[root@cPen_A 10]# cat c.txt 0.0.0.01.1.1.12.2.2.2[root@cPen_A 10]# cat c.txt|sed -n &#x27;s/$/:80/;H;$&#123;x;s/\\n/,/2g;p&#125;&#x27;0.0.0.0:80,1.1.1.1:80,2.2.2.2:80 h H Copy/append pattern space to hold space. g G Copy/append hold space to pattern space. x Exchange the contents of the hold and pattern spaces.---------------------------------------------------------------------[root@localhost 10]# cat c.txt |tr &#x27;\\n&#x27; &#x27;,&#x27;|sed -n &#x27;s/,/:80&amp;/g;p&#x27;|awk -F, &#x27;OFS=&quot;,&quot;&#123;print $1,$2,$3&#125;&#x27;0.0.0.0:80,1.1.1.1:80,2.2.2.2:80 12sed的命令中&amp;的用法&amp;用于表示替换命令中的匹配模式 (正则) --》对应一个标签–》分组 从左到右 1开始 \\3 引用第3个分组（标签） 123示例：[root@cPen_A 10]# echo aaa bbb 123456 ccc | sed -r &#x27;s/([a-z]+) ([a-z]+) ([0-9]+) ([a-z]+)/\\3/&#x27;123456 四. 模式空间(pattern space)和暂存空间（hold space）相关的命令 模式空间(pattern space)和暂存空间（hold space）相关的命令： n 输出模式空间行，读取下一行替换当前模式空间的行，执行下一条处理命令而非第一条命令。 N 读入下一行，追加到模式空间行后面，此时模式空间有两行。 h 把模式空间里的行拷贝到暂存空间。 H 把模式空间里的行追加到暂存空间。 g 用暂存空间的内容替换模式空间的行。 G 把暂存空间的内容追加到模式空间的行后。 x 将暂存空间的内容于模式空间里的当前行互换。 ！ 对所选行以外的所有行应用命令。 http://blog.csdn.net/itsenlin/article/details/21129405 五. 练习 12345678910111213141516171819202122232425262728293031323334353637练习：1.编写一个修改ip地址的脚本提醒用户输入ip、子网掩码、网关、dns服务器地址直接修改网卡配置文件，然后刷新服务让输入的ip地址信息生效需要检查输入ip地址是否合法，不能输入空的内容或者字母，如果ip地址不合法或者输入空内容、字母都给予提醒提醒：空的内容包括回车和空格，可以是多个空格需求分析： 1.read或者位置变量 2.修改配置文件 sed 3.ip合法判断--》正则2.请将所有的非root用户的uid后面加一个0，gid前面加一个1 复制/etc/passwd 到当前目录下操作3给下列含有大写字母的行，在数字后追加sanchuang --》sed abcd6Sdd9dde islHishbxld goBke8fji daa5nshXxge4.自己编辑一个文件test.txt，内容如下： 0.0.0.0 1.1.1.1 2.2.2.2 输出以下形式： 0.0.0.0:80,1.1.1.1:80,2.2.2.2:805.sed取出/etc/passwd文件的第一列6.sed将PATH环境变量中的冒号换成换行7.sed将PATH环境变量斜杠/换成斜杠\\8.sed修改SELINUX配置文件从开启(enforcing)变成禁用(disabled)/etc/sysconfig/selinux9.去掉/etc/passwd文件中第二个字段的x10.将/etc/sysconfig/network-scripts/ifcfg-ens33里的ONBOOT=no修改为yes或者修改下IPADDR后面的ip地址只显示ip add的ip地址11.复制/etc/ssh/sshd_config 到当前目录，然后操作。将sshd_config里的端口号修改为8899","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://blog1.cpen.top/tags/Shell/"},{"name":"Sed","slug":"Sed","permalink":"https://blog1.cpen.top/tags/Sed/"}]},{"title":"29_Linux基础-shell编程-awk-sed","slug":"Linux_基础/29_Linux基础-shell编程-awk-sed","date":"2022-10-17T04:00:00.000Z","updated":"2022-10-17T05:00:00.000Z","comments":true,"path":"posts/3ae7567f.html","permalink":"https://blog1.cpen.top/posts/3ae7567f.html","excerpt":"","text":"awk 输入分隔符（-F、FS）、输出分隔符（OFS） awk里引用shell变量 一. awk和shell变量交换的问题 awk和shell变量交换的问题 1、使用 -v选项 2、使用双引号，但是awk内部的$0 1等1等1等符号前需要使用\\转义 3、使用单引号，将变量引起来，然后前面加一个$符号再次引用变量的值，相当于取2次值 123456789101112131415161718192021222324252627282930313233#示例：使用 -v选项[root@cPen_A ~]# sg=&quot;panjinhao&quot;[root@cPen_A ~]# echo $sgpanjinhao[root@cPen_A ~]# echo|awk &#x27;&#123;print $sg&#125;&#x27;[root@cPen_A ~]# echo|awk -v bsg=$sg &#x27;&#123;print bsg&#125;&#x27;panjinhao[root@cPen_A ~]# ls|awk -v bsg=$sg &#x27;&#123;print bsg&#125;&#x27;panjinhao #注：ls 输出多行panjinhao……panjinhao[root@cPen_A lianxi]# vim test2.sh awk -v var=$1 -F: &#x27;$1==var&#123;print NR,$0&#125;&#x27; /etc/passwd[root@cPen_A lianxi]# bash test2.sh root1 root:x:0:0:root:/root:/bin/bash[root@cPen_A lianxi]# bash test2.sh sanchuang21 sanchuang:x:1000:1000::/home/sanchuang:/bin/bash#注：第1个$1 位置变量，第2个$1 第1个字段#示例：使用双引号，但是awk内部的$0 $1等$符号前需要使用\\转义[root@cPen_A lianxi]# mv=&quot;zhangjie&quot;[root@cPen_A lianxi]# useradd zhangjie_123[root@cPen_A lianxi]# cat /etc/passwd|awk -F: &quot;/^$mv/&#123;print \\$1,\\$3&#125;&quot;zhangjie_123 12358#示例：使用单引号，将变量引起来，然后前面加一个$符号再次引用变量的值，相当于取2次值[root@cPen_A lianxi]# sg=3[root@cPen_A lianxi]# awk -F: &#x27;/root/&#123;print $1,$&#x27;$sg&#x27;&#125;&#x27; /etc/passwdroot 0operator 11 二. 进程和进程之间通信的方式 1、共享内存 2、信号量 3、信号 4、管道 5、队列 6、Socket 1234567[root@cPen_A lianxi]# cat /etc/shadow第2个字段：密码字段*操作系统自带的，没有密码的!!用户建的，没有密码的提示：密码字段为*、!!表示没有设置密码；密码字段为空说明密码被清除。#示例：没有设置密码的用户[root@cPen_A lianxi]# cat /etc/shadow|awk -F: &#x27;BEGIN&#123;i=0&#125;length($2)&lt;=2&#123;print $1,&quot;没有设置密码&quot;;i++&#125;END&#123;print &quot;一共有&quot;i&quot;个用户&quot;&#125;&#x27; 三. awk内置函数 awk内置的函数： ​ length() ​ int() ​ sqrt() ​ system() String Functions ​ sub() ​ index() ​ length() ​ split() Numeric Functions yum install python3 安装python3 12345678#示例：生成0-1之间随机数[root@cPen_A lianxi]# echo |awk &#x27;&#123;print rand()&#125;&#x27;0.237788#示例：产生0-100之间随机数[root@cPen_A lianxi]# echo |awk &#x27;&#123;print rand()*100&#125;&#x27;23.7788[root@cPen_A lianxi]# echo |awk &#x27;&#123;print int(rand()*100)&#125;&#x27;23 四. 流控 流控：流程控制 control flow for while case if 1234567891011if语句单分支[root@cPen_A lianxi]# awk -F: &#x27;&#123;if($1 ~ /\\&lt;...\\&gt;/)print $0&#125;&#x27; /etc/passwdbin:x:1:1:bin:/bin:/sbin/nologin[root@cPen_A lianxi]# awk -F: &#x27;$1 ~ /\\&lt;.&#123;3&#125;\\&gt;/&#123;print $0&#125;&#x27; /etc/passwdbin:x:1:1:bin:/bin:/sbin/nologin双分支[root@cPen_A lianxi]# awk -F: &#x27;&#123;if($1 ~ /\\&lt;...\\&gt;/)print $0;else print &quot;不符合要求&quot;&#125;&#x27; /etc/passwd不符合要求bin:x:1:1:bin:/bin:/sbin/nologin 12345678910111213#练习/etc/passwd$3是uid 用户的编号如果用户的编号是0 --&gt; 管理员1~999 --&gt; 程序用户大于1000 --&gt; 普通用户最后统计出有多少管理员，多少程序用户，多少普通用户？-----------------------------------------------------[root@cPen_A ~]# awk -F: &#x27;BEGIN&#123;x=0;y=0;z=0&#125;&#123;if($3==&quot;0&quot;) &#123;print $1,&quot;管理员&quot;;x++&#125; else if($3&gt;=1 &amp;&amp; $3&lt;=999) &#123;print $1,&quot;程序用户&quot;;y++&#125; else &#123;print $1,&quot;普通用户&quot;;z++&#125;&#125;END&#123;print &quot;管理员&quot;x,&quot;程序用户&quot;y,&quot;普通用户&quot;z&#125;&#x27; /etc/passwdroot 管理员bin 程序用户……管理员1 程序用户25 普通用户40 五. awk的for循环、数组 awk难点： 正则表达 if 内置函数 内置变量 for，数组array 六. sed sed是什么？what --&gt; text stream editor 有什么用？where how --&gt; 修改和替换文本 --&gt; modify and substitute sed是一种支持正则表达式的非交互式流编工具（stream editor） ​ 脚本中修改文本或者文本替换的最佳工具 交互式：一问一答。比如python3里敲命令 2个空间 pattern space --&gt; 处理数据的地方 --&gt; 处理一行数据后，模式空间会清空 hold space --&gt; 临时存放数据的地方 把pattern space放到hold space 命令：h、H 把hold space放到pattern space 命令：g、G #注：性能意识，sed在内存里运行，比磁盘速度快 #注：容量意识 1234#示例：-i选项 直接在文件里进行修改，不输出到屏幕[root@cPen_A lianxi]# sed -i &#x27;s/xiaomi/redmi/g&#x27; test.txt #示例：通过管道传过来[root@cPen_A lianxi]# cat chen |sed &#x27;s/xiaomi/redmi/g&#x27; 123456789101112131415[root@cPen_A lianxi]# cat -n /etc/passwd|head |tail -6 5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin 6 sync:x:5:0:sync:/sbin:/bin/sync 7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 8 halt:x:7:0:halt:/sbin:/sbin/halt 9 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin 10 operator:x:11:0:operator:/root:/sbin/nologin#示例：-n选项 值显示匹配处理的行 （否则会输出所有）[root@cPen_A lianxi]# cat -n /etc/passwd|sed -n &#x27;5,10p&#x27; 5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin 6 sync:x:5:0:sync:/sbin:/bin/sync 7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 8 halt:x:7:0:halt:/sbin:/sbin/halt 9 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin 10 operator:x:11:0:operator:/root:/sbin/nologin sed的p命令示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119= :输出行号p命令输出的时候：连续的行[root@localhost lianxi]# cat /etc/passwd|sed -n &#x27;1,5p&#x27;不连续的行[root@localhost lianxi]# cat /etc/passwd|sed -n &#x27;10p;20p&#x27;示例：sed的p命令示例sed -n ‘行号1,行号2p’ 输出文件[root@localhost lianxi]# cat /etc/passwd|sed -n &#x27;1,5p&#x27; #注：连续用,号root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin[root@localhost lianxi]# cat /etc/passwd|sed -n &#x27;=;1,5p&#x27; #注：=；输出行号1root:x:0:0:root:/root:/bin/bash2bin:x:1:1:bin:/bin:/sbin/nologin3daemon:x:2:2:daemon:/sbin:/sbin/nologin4adm:x:3:4:adm:/var/adm:/sbin/nologin5lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin67……14[root@localhost lianxi]# cat -n /etc/passwd|sed -n &#x27;1,$p&#x27; #注：$p最后一行[root@localhost lianxi]# cat -n /etc/passwd|sed -n &#x27;5,+5p&#x27; #注：第5行开始 往后加5行 5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin 6 sync:x:5:0:sync:/sbin:/bin/sync 7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 8 halt:x:7:0:halt:/sbin:/sbin/halt 9 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin 10 operator:x:11:0:operator:/root:/sbin/nologin[root@localhost lianxi]# cat -n /etc/passwd|sed -n &#x27;5,100!p&#x27; #注：取反，取1到4行 1 root:x:0:0:root:/root:/bin/bash 2 bin:x:1:1:bin:/bin:/sbin/nologin 3 daemon:x:2:2:daemon:/sbin:/sbin/nologin 4 adm:x:3:4:adm:/var/adm:/sbin/nologin#示例：步长值 # cat -n /etc/passwd|sed -n &#x27;1~2p&#x27; # cat -n /etc/passwd|sed -n &#x27;2~2p&#x27;[root@localhost lianxi]# cat -n /etc/passwd|sed -n &#x27;1~2p&#x27; #注：单数行，1开始每次往后2行 1 root:x:0:0:root:/root:/bin/bash 3 daemon:x:2:2:daemon:/sbin:/sbin/nologin 5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin 7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 9 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin 11 games:x:12:100:games:/usr/games:/sbin/nologin 13 nobody:x:99:99:Nobody:/:/sbin/nologin 15 dbus:x:81:81:System message bus:/:/sbin/nologin 17 sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin 19 chrony:x:998:996::/var/lib/chrony:/sbin/nologin 21 chenpeng:x:1001:1001::/home/chenpeng:/bin/bash 23 nginx:x:996:994:Nginx web server:/var/lib/nginx:/sbin/nologin[root@localhost lianxi]# cat -n /etc/passwd|sed -n &#x27;2~2p&#x27; #注：双数行 2 bin:x:1:1:bin:/bin:/sbin/nologin 4 adm:x:3:4:adm:/var/adm:/sbin/nologin 6 sync:x:5:0:sync:/sbin:/bin/sync 8 halt:x:7:0:halt:/sbin:/sbin/halt 10 operator:x:11:0:operator:/root:/sbin/nologin 12 ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin 14 systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin 16 polkitd:x:999:998:User for polkitd:/:/sbin/nologin 18 postfix:x:89:89::/var/spool/postfix:/sbin/nologin 20 mysql:x:1000:1000::/home/mysql:/sbin/nologin 22 redis:x:997:995:Redis Database Server:/var/lib/redis:/sbin/nologin#示例：shell变量传到sed里#双引号 推荐[root@localhost lianxi]# num1=6[root@localhost lianxi]# num2=10[root@localhost lianxi]# cat -n /etc/passwd|sed -n &quot;$&#123;num1&#125;,$&#123;num2&#125;p&quot; 6 sync:x:5:0:sync:/sbin:/bin/sync 7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 8 halt:x:7:0:halt:/sbin:/sbin/halt 9 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin 10 operator:x:11:0:operator:/root:/sbin/nologin#单引号[root@localhost lianxi]# cat -n /etc/passwd|sed -n &#x27;&#x27;$&#123;num1&#125;,$&#123;num2&#125;&#x27;p&#x27; 6 sync:x:5:0:sync:/sbin:/bin/sync 7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 8 halt:x:7:0:halt:/sbin:/sbin/halt 9 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin 10 operator:x:11:0:operator:/root:/sbin/nologin----------------------------------------------------------#示例：显示包含bash的行[root@localhost lianxi]# cat /etc/passwd|sed -n &#x27;/bash/p&#x27;root:x:0:0:root:/root:/bin/bashchenpeng:x:1001:1001::/home/chenpeng:/bin/bash[root@localhost lianxi]# cat /etc/passwd|egrep &quot;bash&quot;root:x:0:0:root:/root:/bin/bashchenpeng:x:1001:1001::/home/chenpeng:/bin/bash[root@localhost lianxi]# cat /etc/passwd|awk &#x27;/bash/&#x27;root:x:0:0:root:/root:/bin/bashchenpeng:x:1001:1001::/home/chenpeng:/bin/bash#示例：输出#号开头的行[root@localhost lianxi]# cat /etc/ssh/ssh_config |sed -n &#x27;/^#/p&#x27;#示例：输出不是#号开头的行[root@localhost lianxi]# cat /etc/ssh/ssh_config |sed -n &#x27;/^#/!p&#x27;#示例：显示 不是#号和!号开头的行[root@localhost lianxi]# cat /etc/ssh/ssh_config |sed -r -n &#x27;/^#|^$/!p&#x27; #注：-r支持更多正则[root@localhost lianxi]# cat /etc/ssh/ssh_config |egrep -v &#x27;^#|^$&#x27;#示例：显示 以/结尾的行[root@localhost lianxi]# df -h|egrep &quot;/$&quot;/dev/mapper/centos-root 17G 9.9G 7.2G 58% /[root@localhost lianxi]# df -h|sed -n &#x27;/\\/$/p&#x27;/dev/mapper/centos-root 17G 9.9G 7.2G 58% /#示例：以a-Z开头的行[root@localhost lianxi]# cat /etc/passwd|sed -n &#x27;/^[a-Z]/p&#x27;#示例：不以a-Z开头的行[root@localhost lianxi]# cat /etc/passwd|sed -n &#x27;/^[^a-Z]/p&#x27; 123456789101112131415161718192021222324252627282930题目：截取nginx的access.log文件里3月18号15:30:00 -- 16:48:10时间段内的所有访问日志[root@cPen_A lianxi]# service firewalld stop #注：立马停止firewalld服务[root@cPen_A lianxi]# systemctl disable firewalld #注：设置firewalld服务开机不启动--&gt;下次重启机器的时候不启动[root@cPen_A nginx]# tail -f access.log #注：动态监控最后一行192.168.0.17 - - [09/Jan/2021:16:36:03 +0800] &quot;GET /favicon.ico HTTP/1.1&quot; 404 3650 &quot;http://192.168.0.118/&quot; &quot;Mozilla/5.0 (Linux; Android 10; PCT-AL10; HMSCore 5.1.0.300; GMSCore 20.26.14) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 HuaweiBrowser/11.0.5.304 Mobile Safari/537.36&quot; &quot;-&quot;[root@cPen_A nginx]# pwd/var/log/nginx #注：nginx的日志文件的路径[root@cPen_A nginx]# lsaccess.log access.log-20201202.gz error.log error.log-20201202.gz#注：access.log是nginx的访问日志文件，记录访问过我们的网站的信息[root@cPen_A nginx]# cat access.log | awk -F&#x27;[()]&#x27; &#x27;&#123;print $2&#125;&#x27;|sort|uniq -c|sort -nr 13 Windows NT 10.0; WOW64 #注：排序去重 再降序排序 显示数量 4 Linux; Android 10; PCT-AL10; HMSCore 5.1.0.300; GMSCore 20.26.14---------------------------------------------------------------------------[09/Jan/2021:16:32:46 +0800] --&gt; 09/Jan/2021:16:32:46[09/Jan/2021:16:33:07 +0800] --&gt; 09/Jan/2021:16:32:46#示例：查找该时间段的所有访问日志[root@cPen_A nginx]# cat access.log|sed -n &#x27;/09\\/Jan\\/2021:16:32:46/,/09\\/Jan\\/2021:16:33:07/p&#x27;#示例：正则写法[root@cPen_A nginx]# cat access.log|sed -r -n &#x27;/09\\/Jan\\/2021:16:(3[789]|4[0-9]|5[01]):(0[1-9]|[1-5][0-9])/p&#x27;#注：分钟的范围37~51 秒的范围01~59#37~51#37~39#40~49#50~51#01~590[1-9]|[1-5][0-9] sed的d命令示例 1234567891011121314151617181920212223242526272829303132sed的d命令示例删除操作可以根据行号和匹配模式进行操作#示例：删除有denghui的行[root@cPen_A nginx]# cat /etc/passwd|sed &#x27;/denghui/d&#x27;#示例：-i动原文件 删除有redmi这行[root@cPen_A lianxi]# sed -i &#x27;/redmi/d&#x27; test.txt #示例：根据行删除[root@cPen_A lianxi]# sed -i &#x27;2d&#x27; test.txt #注：删除第2行sed查找方式: 1、根据行号 2、根据模式 --&gt;正则表达式=字符+特殊符号 3、根据字符串#示例：在第4行后面追加huawei[root@cPen_A lianxi]# sed -i &#x27;4a huawei&#x27; test.txt #示例：在第4行前面插入apple[root@cPen_A lianxi]# sed -i &#x27;4i apple&#x27; test.txt #示例：在VIVO这行前一行插入OPPO[root@cPen_A lianxi]# sed -i &#x27;/VIVO/i OPPO&#x27; test.txt #示例：在VIVO同行后面添加APPLE.&amp;表示前面全部[root@cPen_A lianxi]# sed -i &#x27;s/VIVO/&amp; APPLE/&#x27; test.txt #示例：将所有为huawei都替换成sanchuang[root@cPen_A lianxi]# sed -i &#x27;s/huawei/sanchuang/g&#x27; test.txt sed的命令： p d a i s c r w","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://blog1.cpen.top/tags/Shell/"},{"name":"Awk","slug":"Awk","permalink":"https://blog1.cpen.top/tags/Awk/"},{"name":"Sed","slug":"Sed","permalink":"https://blog1.cpen.top/tags/Sed/"}]},{"title":"28_Linux基础-shell编程-awk","slug":"Linux_基础/28_Linux基础-shell编程-awk","date":"2022-10-16T04:00:00.000Z","updated":"2022-10-16T05:00:00.000Z","comments":true,"path":"posts/29e2641c.html","permalink":"https://blog1.cpen.top/posts/29e2641c.html","excerpt":"","text":"/bin下面放二进制文件 lib 放系统的公共模块、公共库、公共工具 /dev设备文件 #标准输入、标准输出 /usr 安装的命令安装的模块 编译安装、rpm安装的程序 /boot 系统启动会到这里来找 /proc 保留正在运行的程序 /proc/sys 正在运行的内核参数进行修改 /etc/sysctl.conf 永久修改 [root@localhost net]# sysctl -p 生效 /run 保存pid文件 /var/log 系统日志 一. 脚本调试 -x 12345678#示例：脚本的调试 -x[root@cPen_A lianxi]# bash -x test.sh + lsaaa2 aaa.py d.md5 mod1.py __pycache__ test_class2.py test_class.py test.sh + echo okok+ echo errerr 二. 小数计算 1234567#示例：小数计算[root@cPen_A lianxi]# echo &quot;scale=2;5/3&quot; |bc1.66[root@cPen_A lianxi]# echo &quot;5 3&quot; |awk &#x27;&#123;print $1/$2&#125;&#x27;1.66667[root@cPen_A lianxi]# echo &quot;5 3&quot; |awk &#x27;&#123;printf &quot;%.2f&quot;,$1/$2&#125;&#x27;1.67 三. 打印奇数 1234#示例：打印奇数[root@cPen_A lianxi]# for i in `seq 1 2 100` ;do echo $i;done#注：或者类似C语言for循环写法 四. 合并文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445#示例：合并文件把用户名字和用户金额统一在一起#注：把2个文件按照列合并[root@cPen_A shell_test]# cat user.txt 100 cp1200 cp2300 cp3[root@cPen_A shell_test]# cat money.txt 100 $500300 $600200 $400-----------------------------------------------------[root@cPen_A shell_test]# cat money.txt |sort -t &quot; &quot; -n &gt;money2.txt[root@cPen_A shell_test]# cat user.txt |sort -t &quot; &quot; -n &gt;user2.txt [root@cPen_A shell_test]# cat user2.txt 100 cp1200 cp2300 cp3[root@cPen_A shell_test]# cat money2.txt 100 $500200 $400300 $600[root@cPen_A shell_test]# join user2.txt money2.txt 100 cp1 $500200 cp2 $400300 cp3 $600[root@cPen_A shell_test]# paste user2.txt money2.txt 100 cp1 100 $500200 cp2 200 $400300 cp3 300 $600-----------------------------------------------------while read user_id user_namedo while read user_id2 user_money do if [[ $user_id == $user_id2 ]] then echo $user_id $user_name $user_money &gt;&gt; user_money.txt fi done &lt; money.txtdone &lt; user.txt sed处理文本 vim替换文本，用替换模式 按r sed在文本外部操作文本里面的内容。做更新替换和删除（比如修改一键化安装脚本 配置文件 用sed去修改） http://c.biancheng.net/linux/sed.html 123456789101112131415161718192021[root@cPen_A shell_test]# vim test.txtaabbccabcdef[root@cPen_A shell_test]# sed &#x27;/a/d&#x27; test.txt bbccdef[root@cPen_A shell_test]# cat test.txt aabbccabcdef[root@cPen_A shell_test]# sed -i &#x27;/a/d&#x27; test.txt #注：真正删除成功[root@cPen_A shell_test]# cat test.txt bbccdef 五. 文本处理 1.文本处理（请使用shell脚本让其满足下列特性）： （1）给下列含有大写字母的行，在大写字母后追加数字2020 --》sed abcdSdddde islHishbxld goBkefji daanshXxge 123456sed -i‘s/oldword/newword/g’ c.txt#注：s substitute替换&amp;代表前面匹配的oldword[root@cPen_A ~]# cat c.txt |sed &#x27;s/[A-Z]/&amp;2020/g&#x27;[root@cPen_A ~]# sed -i &#x27;s/[A-Z]/&amp;2020/g&#x27; c.txt #注：对源文件做修改 123456789101112131415161718192021222324252627282930313233（2）请取出下列以逗号分割符最后一个字段不为0的行,并对最后一个字段以100为最小单位取整取正 000001,2,115 000002,2,1,0 000002,2,1,-200 awk，tr[root@cPen_A ~]# vim c.txt? ?000001,2,115? ?000002,2,1,0? ?000002,2,1,-200[root@cPen_A ~]# cat c.txt |tail -3|awk -F, &#x27;$NF != 0&#123;print $1,int($NF/100)&#125;&#x27;? ?000001 1? ?000002 -2[root@cPen_A ~]# cat c.txt |tail -3|awk -F, &#x27;$NF != 0&#123;print $0,int($NF/100)&#125;&#x27;|tr -d &quot;-&quot;? ?000001,2,115 1? ?000002,2,1,200 2[root@cPen_A ~]# cat c.txt |tail -3|awk -F, &#x27;$NF != 0&#123;print $0,sqrt(int($NF/100)*int($NF/100))&#125;&#x27;? ?000001,2,115 1? ?000002,2,1,-200 2[root@cPen_A ~]# cat c.txt |tail -3|awk -F, &#x27;$NF != 0&#123;print $0,sqrt(int($NF/100)*int($NF/100)),length($1)&#125;&#x27;? ?000001,2,115 1 9? ?000002,2,1,-200 2 9#注：$NF != 0 最后一项不为0#注：$0 指全部。sqrt开平方AWK 里有很多的内置函数int()sqrt() 开根号length()[root@cPen_A ~]# a=-488[root@cPen_A ~]# echo $&#123;a#-&#125; #注：删除-号488 六. awk awk 是什么？ ​ awk是linux里的一个文本处理的命令（工具） --&gt; 程序 --&gt; c语言 unix --&gt; awk ​ 为什么要使用awk? ​ 截取内容 bc进行小数运算 awk也可以 字段：field --&gt; 列 column name age sex grade cali 18 M 70 rose 19 F 90 #注：CSV文件 以,作为分割的文件 $0 存储的是整行数据 每个数据存入$1-$7中 AWK 默认的分隔符是空白（空格、tab） 输入分隔符 ​ -F 输出分隔符 ​ , 1234[root@cPen_A lianxi]# cat /etc/passwd|awk -F&quot;:&quot; &#x27;&#123;print $1$3$7&#125;&#x27;root0/bin/bash[root@cPen_A lianxi]# cat /etc/passwd|awk -F&quot;:&quot; &#x27;&#123;print $1,$3,$7&#125;&#x27;root 0 /bin/bash 123456789101112131415[root@cPen_A lianxi]# cat /etc/passwd|awk -F: &#x27;BEGIN&#123;print &quot;######start######&quot;&#125; /bash$/&#123;print $1,$7&#125;END&#123;print &quot;######end######&quot;&#125;&#x27;######start######root /bin/bashsanchuang /bin/bash……chen223344 /bin/bash######end#######注：/bash$ 以bash结尾的行#示例：统计有多少行[root@cPen_A lianxi]# cat /etc/passwd|awk -F: &#x27;BEGIN&#123;i=0&#125; &#123;i++&#125; END&#123;print i&#125;&#x27;65#注：不需要用$，因为引用的不是变量#注：多条命令使用，在&#123;花括号&#125;里放;号#注：~波浪符号 模糊匹配 ~/feng/； || 或；&amp;&amp; 且 AWK内置变量 AWK内置变量 NR 代表行号 number of record --&gt; record 记录 --&gt; 行 NF 代表一行的字段数量 number of field NF表示最后一个字段；NF 表示最后一个字段；NF表示最后一个字段；(NF-1)倒数第一个字段 1234567891011121314151617181920212223242526272829303132[root@cPen_A lianxi]# cat /etc/passwd |awk -F: &#x27;BEGIN&#123;num=0;print &quot;开始统计/etc/passwd文件&quot;&#125; $1 ~ /feng/ || $3 &gt; 1005 &#123;print NR,NF,$1,length($1),$(NF-1),$NF,$3;num++&#125;END&#123;print &quot;统计结束&quot;,num&#125;&#x27;开始统计/etc/passwd文件24 7 chenpeng1 9 /home/chenpeng1 /bin/bash 110025 7 chenpeng2 9 /home/chenpeng2 /bin/bash 1200……65 7 nfsnobody 9 /var/lib/nfs /sbin/nologin 65534统计结束 37-------------------------------------------------------------------#示例：AWK过滤功能[root@cPen_A lianxi]# cat /etc/passwd|awk -F: &#x27;/xiexy/&#x27;[root@cPen_A lianxi]# cat /etc/passwd|egrep &quot;xiexy&quot;#示例：AWK截取功能[root@cPen_A lianxi]# who |awk &#x27;&#123;print $2&#125;&#x27;tty1pts/2[root@cPen_A lianxi]# who |awk &#x27;&#123;print $2,$4&#125;&#x27;tty1 11:23pts/2 09:38#示例：自定义的字符串和字段拼接[root@cPen_A lianxi]# who |awk &#x27;&#123;print &quot;time:&quot;$4,&quot;name:&quot;$2&#125;&#x27;time:11:23 name:tty1time:09:38 name:pts/2-------------------------------------------------------------------#示例：/^[^abcdefg]/ 不是以abcdefg开头的行[root@cPen_A lianxi]# cat /etc/passwd|awk -F: &#x27;/^[^abcdefg]/&#123;print $1,$7&#125;&#x27;#示例：/^[^A-z]/ 不是A-z字母开头的行[root@cPen_A lianxi]# cat /etc/passwd|awk -F: &#x27;/^[^A-z]/&#123;print $1,$7&#125;&#x27;#示例：指定2个分割符[root@cPen_A lianxi]# cat /etc/passwd|tail -1|awk -F[:/] &#x27;&#123;print $8&#125;&#x27;lib awk命令的操作符 awk命令的操作符 比较操作符：匹配符号 ~ !~ 12345678#示例：[root@cPen_A lianxi]# whoroot tty1 2020-12-23 11:23root pts/2 2021-01-08 09:38 (192.168.0.119)[root@cPen_A lianxi]# who|awk &#x27;$2 ~ /pts/&#123;print $0&#125;&#x27;root pts/2 2021-01-08 09:38 (192.168.0.119)[root@cPen_A lianxi]# cat /etc/passwd|awk -F: &#x27;$1 ~/deng/ &amp;&amp; $3&gt;1058 &amp;&amp; $NF ~/bash$/&#x27; 文本数据表达式 文本数据表达式: == 精确匹配 ~ 模糊匹配 123456789101112[root@cPen_A lianxi]# awk -F: &#x27;$3 ~ /\\&lt;...\\&gt;/ &#123;print $1,$3&#125;&#x27; /etc/passwdsystemd-network 192polkitd 999chrony 998nginx 997[root@cPen_A lianxi]# awk -F: &#x27;$3 ~ /\\&lt;.&#123;3&#125;\\&gt;/ &#123;print $1,$3&#125;&#x27; /etc/passwdsystemd-network 192polkitd 999chrony 998nginx 997[root@cPen_A lianxi]# cat /etc/passwd|awk -F: &#x27;$1 ~ /deng/ &#123;print $1&#125;&#x27; awk 内置变量和函数 awk 内置变量和函数？ NF 每行$0的字段数 NR 当前处理的行号 FS 当前的输入分隔符，默认是空白字符（空格和tab） field separator OFS 当前的输出分隔符，默认是空格字符（空格） output field separator 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768示例：[root@cPen_A lianxi]# cat /etc/passwd|awk -F: &#x27;&#123;print NR,$0&#125;&#x27;1 root:x:0:0:root:/root:/bin/bash #注：NR行号2 bin:x:1:1:bin:/bin:/sbin/nologin[root@cPen_A lianxi]# cat /etc/passwd|awk -F: &#x27;&#123;print NR,$0,NF&#125;&#x27;1 root:x:0:0:root:/root:/bin/bash 72 bin:x:1:1:bin:/bin:/sbin/nologin 7[root@cPen_A lianxi]# cat /etc/passwd|awk -F: &#x27;&#123;print NR,$0,$NF&#125;&#x27;1 root:x:0:0:root:/root:/bin/bash /bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologin /sbin/nologin[root@cPen_A lianxi]# cat /etc/passwd|awk &#x27;FS=&quot;:&quot;;OFS=&quot;#&quot;&#123;print NR,$0,$NF&#125;&#x27;root:x:0:0:root:/root:/bin/bash1#root:x:0:0:root:/root:/bin/bash#root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologin2#bin:x:1:1:bin:/bin:/sbin/nologin#/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologin#推荐使用-F指定输入分隔符===========================================================================================使用NF变量显示passwd文件倒数第二列的内容[root@cPen_A ~]# cat /etc/passwd|awk -F: &#x27;&#123;print $(NF-1)&#125;&#x27;----------------------------------------------------------显示passwd文件中第5到第10行的用户名[root@cPen_A ~]# cat /etc/passwd|awk -F: &#x27;NR &gt;= 5 &amp;&amp; NR &lt;= 10 &#123;print $1&#125;&#x27;[root@cPen_A ~]# cat /etc/passwd|awk -F: &#x27;NR &gt;= 5 &amp;&amp; NR &lt;= 10 &#123;print NR,$1&#125;&#x27;----------------------------------------------------------显示passwd文件中第7列不是bash的用户名[root@cPen_A ~]# cat /etc/passwd|awk -F: &#x27;$7 ~ /bash/ &#123;print NR,$1&#125;&#x27;----------------------------------------------------------显示passwd文件中行号是5结尾的行号和行[root@cPen_A ~]# cat /etc/passwd|awk -F: &#x27;NR ~ /5$/ &#123;print NR,$1&#125;&#x27;----------------------------------------------------------用ip add只显示ip(不能使用tr或者cut命令)[root@cPen_A ~]# ip add|awk &#x27;$NF ~ /ens33/ &#123;print $0&#125;&#x27; inet 192.168.0.118/24 brd 192.168.0.255 scope global noprefixroute dynamic ens33[root@cPen_A ~]# ip add|awk &#x27;$NF ~ /ens33/ &#123;print $2&#125;&#x27;192.168.0.118/24[root@cPen_A ~]# ip add|awk &#x27;$NF ~ /ens33/ &#123;print $2&#125;&#x27;|awk -F/ &#x27;&#123;print $1&#125;&#x27;192.168.0.118----------------------------------------------------------[root@localhost lianxi]# yum install net-tools -y先使用ifconfig，使用awk显示eth0的入站流量和出站流量(字节)[root@cPen_A ~]# ifconfig|head -8|awk &#x27;$1 ~ /RX/ &amp;&amp; $4 ~ /bytes/ || $1 ~ /TX/ &amp;&amp; $4 ~ /bytes/ &#123;print $0&#125;&#x27; RX packets 494598 bytes 38344433 (36.5 MiB) TX packets 17025 bytes 1718505 (1.6 MiB)[root@cPen_A ~]# ifconfig|head -8|awk &#x27;$1 ~ /RX/ &amp;&amp; $4 ~ /bytes/ || $1 ~ /TX/ &amp;&amp; $4 ~ /bytes/ &#123;print $5&#125;&#x27;383726691719743[root@cPen_A ~]# ifconfig|head -8|awk &#x27;$0 ~ /RX.*bytes|TX.*bytes/ &#123;print $5&#125;&#x27;384768661744541#注：当有&amp;&amp;或者||，&amp;&amp;（and）的优先级高----------------------------------------------------------使用awk命令统计以r开头的用户数目，显示如下效果[root@cPen_A ~]# cat /etc/passwd|awk -F: &#x27;BEGIN&#123;i=0&#125; $1 ~ /^r/ &#123;print $1;i++&#125; END&#123;print i&#125;&#x27;rootrpcrpcuser3","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://blog1.cpen.top/tags/Shell/"},{"name":"Awk","slug":"Awk","permalink":"https://blog1.cpen.top/tags/Awk/"}]},{"title":"27_Linux基础-nginx","slug":"Linux_基础/27_Linux基础-nginx","date":"2022-10-15T04:00:00.000Z","updated":"2022-10-15T05:00:00.000Z","comments":true,"path":"posts/45562d6f.html","permalink":"https://blog1.cpen.top/posts/45562d6f.html","excerpt":"","text":"web方向 ​ 经典提问： ​ 在浏览器里输入一个www.baidu.com回车，到显示出内容，背后发生哪些事情？ ​ 应用层 --&gt; 传输层 --&gt; 网络层 --&gt; 数据链路层 --&gt; 物理层 ​ nginx --&gt; 详细的使用 ​ flask --&gt; web服务器 --&gt; python写的 --&gt; 自己写的web服务器软件 ​ mvc, usgi等 ​ nginx --&gt; web服务器 --&gt; C语言 ​ go语言 --&gt; bingo ​ http/https协议 nginx ​ 1.安装 --&gt; 最新版本 --&gt; 编写脚本 --&gt; 一键安装 ​ 2.nginx的配置文件深入讲解 --&gt; 经典的功能实现 ​ 3.一定要使用一个云服务器 --&gt; 购买域名 --&gt; 备案 --&gt; 上线 ​ 4.http协议 1. nginx是什么？ nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by Igor Sysoev. ​ http://nginx.org/ ​ http是什么？ ​ HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写 ​ 工作：应用层 ​ www --&gt; World Wide Web 万维网 ​ 协议：其实就规矩，方便双方沟通使用 ​ http协议是：浏览器和web服务器之间使用的 ​ 谁能读懂http协议？ ​ 所有的浏览器，所有web服务器，爬虫库（requests）等其他 2. nginx的安装 centos8.2 nginx-1.19.5 nginx最新的 nginx-1.19.5 123456789101112131415161718[root@cPen ~]# cat /etc/centos-release #注：查看版本CentOS Linux release 7.6.1810 (Core) 1.下载 mkdir -p /nginx cd /nginx curl -O http://nginx.org/download/nginx-1.19.5.tar.gz 2.解压 [root@cPen_B nginx]# tar xf nginx-1.19.5.tar.gz [root@cPen_B nginx]# cd nginx-1.19.5 [root@cPen_B nginx-1.19.5]# 编译安装经典3步： 1.编译前的配置：配置安装到哪里，启用哪些功能等 ./configure 2.编译，将c的代码编译成二进制文件 make 3.编译安装，将编译好的二进制文件复制到第一步里我们指定的路径 make install 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[root@cPen_B nginx-1.19.5]# ./configure --help 查看哪些功能可以开启，哪些功能可以禁用prefix 前缀--prefix=/usr/local/nginx 指定安装路径--with-select_module 启用，默认没有启用--without-select_module 禁用，默认是启用--with-http_ssl_module 启用https功能--with-http_realip_module --》修改http协议，里面增加一个字段realip--&gt;nginx服务器做反向代理服务器的时候使用============解决依赖关系yum -y install zlib zlib-devel openssl openssl-devel pcre pcre-devel gcc gcc-c++ autoconf automake make 编译前的配置[root@cPen_B nginx-1.19.5]# ./configure --prefix=/usr/local/nginx --user=cPen_nginx --group=cPen_nginx --build=scweb_server --with-threads --with-file-aio --with-http_v2_module --with-http_ssl_module --with-stream编译make -j 2编译安装make install启动nginx[root@cPen_B nginx-1.19.5]# cd /usr/local/nginx[root@cPen_B nginx]# lsconf html logs sbinconf 存放配置文件html 存放网页文件logs 存放日志sbin 存放启动nginx的程序[root@cPen_B nginx]# cd sbin/[root@cPen_B sbin]# lsnginx[root@cPen_B sbin]# ./nginx[root@cPen_B sbin]# lsof -i:80COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnginx 23548 root 9u IPv4 66009 0t0 TCP *:http (LISTEN)nginx 23549 cPen_nginx 9u IPv4 66009 0t0 TCP *:http (LISTEN)[root@cPen_B sbin]# ps aux|grep nginxroot 23548 0.0 0.0 41072 836 ? Ss 19:09 0:00 nginx: master process ./nginxcPen_ng+ 23549 0.0 0.2 74636 4852 ? S 19:09 0:00 nginx: worker process#注：master是领导，worker真正干活的master process 父进程：管理进程worker process 子进程：被管理的进程#注：pstree 查看进程树 -p选项看到进程号#修改PATH变量，方便启动nginx和停止nginx[root@cPen_B sbin]# PATH=/usr/local/nginx/sbin/:$PATH[root@cPen_B sbin]# echo $PATH/usr/local/nginx/sbin/:/lianxi/sc:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/nginx/sbin:/root/bin:/usr/local/nginx5/sbin:/root/bin#关闭防火墙和selinux[root@cPen nginx]# service firewalld stop #注：立马关闭防火墙Redirecting to /bin/systemctl stop firewalld.service[root@cPen nginx]# systemctl disable firewalld #注：设置防火墙开机不要启动#关闭selinuxsetenforce 0 #临时关闭sed -i &#x27;/^SELINUX/ s/enforcing/disabled/&#x27; /etc/sysconfig/selinuxsed -i &#x27;/^SELINUX/ s/enforcing/disabled/&#x27; /etc/selinux/config 12345678910111213141516开机启动nginx的问题 脚本的方式 思考：如何让编译安装的nginx开机启动？ 1./etc/rc.local [root@sc-nginx sbin]# echo &quot;/usr/local/nginx/sbin/nginx&quot; &gt;&gt;/etc/rc.local [root@sc-nginx sbin]# chmod +x /etc/rc.d/rc.local # Please note that you must run &#x27;chmod +x /etc/rc.d/rc.local&#x27; to ensure ------------------------------------------------------------------------ [root@cPen_B ~]# chmod +x /etc/rc.d/rc.local #注：这是给源文件可执行权限 [root@cPen_B ~]# chmod +x /usr/local/nginx/sbin/nginx [root@cPen_B ~]# vim /etc/rc.local #注：启动的时候会执行这个文件里的脚本 #注：添加 /usr/local/nginx/sbin/nginx （最好是绝对路径）#on bootecho &quot;/usr/local/nginx/sbin/nginx&quot; &gt;&gt;/etc/rc.localchmod +x /etc/rc.d/rc.local 配置文件 ​ 路径 /usr/local/nginx/conf/ ​ nginx.conf #注：主配置文件 面试：请你说说nginx配置文件里有哪些常见的配置 （讲它的结构） ​ 日志 ​ access.log 记录正常的访问 ​ error.log 访问出错的信息 ​ listen 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121[root@cPen conf]# cat nginx.conf#user nobody; #注：指定启动nginx的用户worker_processes 1; #注：工作进程的数量 需要和cpu核心的数量一致#error_log logs/error.log; #注：日志文件放在哪里，日志级别#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid; #注：块 &#123;&#125;events &#123; worker_connections 1024; #注：表示nginx可以同时支持的并发数，同时支持多少人访问，具体需要考虑机器的cpu，内存，磁盘IO，网络带宽 --》压力测试&#125;http &#123; #注：与http协议相关的 include mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; #注：提供http服务的，一个server对应一个网站 #listen 80; #注：监听的端口 listen 8080; #server_name localhost; #注：为哪个网站(域名)提供网站的 server_name www.cpen.top; #charset koi8-r; charset utf-8; #access_log logs/host.access.log main; location / &#123; #注：访问网页的根 root html; #注：存放网页的位置 index index.html index.htm; #注：指定首页，其他页面通过链接过去 &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; #注：和路由相关的 # root html; # index index.html index.htm; # &#125; #&#125;&#125; 配置文件里相关配置 防火墙 1iptables -A INPUT -p tcp --dport 8099 -j ACCEPT nginx的首页文件 [root@cPen html]# cd /usr/local/nginx/html/ [root@cPen html]# vim index.html #注：修改首页 #注：修改内容自己定义 #注：修改网页内容不需要刷新nginx服务 ​ 只有修改nginx的配置文件才需要刷新nginx服务 使用域名访问： ​ 阿里云：没有备案的域名不允许访问 ​ 腾讯云：没有备案的域名不允许访问 购买域名–》绑定公网ip–》搞一个首页–》去备案 3. shell编程语法 shell编程语法 12345678910\\ 续行cmd1 &amp;&amp; cmd2cmd1 || cmd2cmd1 &amp;&amp; cmd2 || cmd3test -d &#x27;/usr/local/nginx8/logs&#x27;[ -d /usr/local/nginx8/logs ] 判断/usr/local/nginx8/logs这个目录是否存在test -f &#x27;/usr/local/nginx8/conf/nginx.conf&#x27; [ -f /usr/local/nginx8/conf/nginx.conf ] 判断/usr/local/nginx8/conf/nginx.conf这个文件是否存在 12345[root@sc-nginx nginx-1.19.5]# which killall/usr/bin/killall[root@sc-nginx nginx-1.19.5]# rpm -qf /usr/bin/killall psmisc-23.1-5.el8.x86_64#注：killall -9 nginx 杀死所有nginx进程 12#注：vim编辑器 全部替换:%s/nginx8/nginx18/ 4. web 12345678910111213nginx 官方网站 http://nginx.org/en/ http://nginx.org/en/docs/ 安装 编译 网站 静态页面 纯html,css,js（没有和数据库交互） nginx的强项是解析静态页面 动态页面 需要使用动态编程语言：python，go，java，c#，php等 和数据库交互 --&gt; 读写数据 图解 12345678910111213141516171819模块 --with-http_realip_module --with-http_ssl_module --with-stream 让nginx具有负载均衡，支持4层 enables building the stream module for generic TCP/UDP proxying and load balancing.启动nginx ./nginx 启动 ./nginx -s stop 停止 nginx -s reload 重启 kill killall pstree yum install psmisc lsof -i:80 netstat -anplut PATH变量的修改 PATH=/usr/local/nginx/sbin/:$PATH 临时修改 永久修改 vim /etc/profile 在末尾添加 PATH=/usr/local/nginx/sbin:$PATH http协议 ​ 1.0 ​ 1.1 ​ 2.0 ​ http2.0比http1.1好在哪里？ ​ http和https的区别 设置xshell小键盘可用 #注：属性 --》 终端 --》 VT模式 --》 设置为普通 –with-http_realip_module --》修改http协议，里面增加一个字段realip–&gt;nginx服务器做反向代理服务器的时候使用 5. nginx安装脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[root@cPen nginx]# cat onekey_install_nginx.sh #!/bin/bash#time:2020-12-12#author: cPen#company: cPen#mail:1533431376@qq.com#新建用户，用来启动nginxuseradd -s /sbin/nologin cPen_nginx#解决依赖关系yum -y install zlib zlib-devel openssl openssl-devel pcre pcre-devel gcc gcc-c++ autoconf automake make psmisc lsof net-tools vim#download filemkdir -p /nginxcd /nginxcurl -O http://nginx.org/download/nginx-1.19.5.tar.gz#解压文件tar xf nginx-1.19.5.tar.gzcd nginx-1.19.5#编译前的配置./configure --prefix=/usr/local/nginx --user=cPen_nginx --group=cPen_nginx --build=scweb_server --with-threads --with-file-aio --with-http_v2_module --with-http_ssl_module --with-stream#编译，-j 2 启动2个进程去编译，需要你有2个核心的cpumake -j 2#编译安装make install#修改PATH变量PATH=/usr/local/nginx/sbin:$PATHecho &#x27;PATH=/usr/local/nginx/sbin:$PATH&#x27; &gt;&gt;/etc/profile#关闭防火墙service firewalld stopsystemctl disable firewalld#关闭selinuxsetenforce 0 #临时关闭sed -i &#x27;/^SELINUX/ s/enforcing/disabled/&#x27; /etc/sysconfig/selinuxsed -i &#x27;/^SELINUX/ s/enforcing/disabled/&#x27; /etc/selinux/config#启动nginxnginx#on bootecho &quot;/usr/local/nginx/sbin/nginx&quot; &gt;&gt;/etc/rc.localchmod +x /etc/rc.d/rc.local","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog1.cpen.top/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"}]},{"title":"26_Linux基础-项目轮廓-回顾ansible-dns-nfs-nginx","slug":"Linux_基础/26_Linux基础-项目轮廓-回顾ansible-dns-nfs-nginx","date":"2022-10-14T04:00:00.000Z","updated":"2022-10-14T05:00:00.000Z","comments":true,"path":"posts/dd4b1092.html","permalink":"https://blog1.cpen.top/posts/dd4b1092.html","excerpt":"","text":"一. ansible ansible ​ 是什么？由哪些组成？ ​ 有什么作用？ ​ paramiko --&gt; 这个库/模块 ansible实现ssh功能 是什么？ ansible是一个自动化运维工具的名称 由哪些组成？ ansible组成： ​ 1、host inventory --#定义客户机，可以对客户机进行分类：db类，web类…等等 ​ 2、playbook --#剧本 让主机按照我给定的剧本去完成一些事情 ​ 3、module --#模块 实现一个个功能的程序 ​ 4、pluging --#插件 实现一些额外的小功能 --------------------------------------- 有什么作用？ 装软件、卸软件、改配置、打补丁、做备份、跑脚本（运维工作） --------------------------------------- ansible是python写的，底层是ssh --------------------------------------- paramiko --》 这个库/模块 ansible实现ssh功能 --------------------------------------- sshpass 模块 --》linux命令 实现ssh登录 --------------------------------------- [root@cPen_A ~]# ansible --version #注：查看版本 ansible 2.9.15 二. grep 1234#grep相关命令[root@cPen_B network-scripts]# cat /etc/passwd|grep -B 5 mail #注：查看前5行[root@cPen_B network-scripts]# cat /etc/passwd|grep -A 5 mail #注：查看后5行[root@cPen_B network-scripts]# cat /etc/passwd|grep -C 5 mail #注：中间 查看前后5行 12[root@cPen_A ~]# vim /etc/ansible/ansible.cfg #注：ansible配置文件forks = 5 #注：起5个进程去处理 -f 选项 123ip地址显示不出来service NetworkManager stop #注：这个服务影响的service network restart 123456789101112131415161718192021222324252627282930313233343536template 模板 --&gt; 绝大部分固定的，有几个是变量，根据ansible取机器上的值[root@cPen_A ansible]# ansible web -m setup #注：查看节点服务器的信息 以字典形式展示192.168.0.79 | SUCCESS =&gt; &#123; &quot;ansible_facts&quot;: &#123;……&#125;[root@cPen_A ansible]# ansible web -m setup -a &quot;filter=ansible_all_ipv4_addresses&quot;#注：过滤获得指定信息#注：获取 ansible-demo3 主机的 IPV4 地址192.168.0.79 | SUCCESS =&gt; &#123; &quot;ansible_facts&quot;: &#123; #注：ansible_事实 &quot;ansible_all_ipv4_addresses&quot;: [ &quot;192.168.0.79&quot; ], &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot; &#125;, &quot;changed&quot;: false&#125;==========================================================ssh = paramiko.SSHClient()ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())ssh.connect(&quot;某IP地址&quot;,22,&quot;用户名&quot;, &quot;口令&quot;)==========================================================解决使用密码连接，第一ssh过去的时候，需要输入yes的问题[root@C ansible]# vim hosts [web]192.168.0.77[db]192.168.0.35 ansible_ssh_user=root ansible_ssh_pass=123456[root@C ansible]# vim ansible.cfg # uncomment this to disable SSH key host checkinghost_key_checking = False 123api 接口 --&gt; application interface#注：写接口json 有什么用？轻量级的数据交换格式 12[root@cPen_A ansible]# ansible-doc -l #注：查看ansible的模块#注：doc 文档，l list 1lastest表示安装 不是指最新的 1234567891011121314151617181920212223项目ansible项目名称：使用ansible批量部署nginx集群和mysql集群项目环境：centos8.2，ansible2.9.15，nginx1.19.5,mysql5.7.31项目描述： 使用ansible去批量部署6台nginx服务器，1台NFS文件服务器，3台MySQL服务器，其中nginx采用源码编译安装，MySQL采用二进制安装，NFS采用yum安装方法。nginx的编译安装和MySQL的二进制安装过程提前编写好脚本，通过ansible下发到nginx和MySQL服务器上执行，全程采用playbook来实现批量自动化部署项目步骤： 1.部署好11台linux虚拟机，全部的配置，采用1核2G的内存的配置，安装好centos8.2的系统。 2.然后在一台linux系统里安装部署ansible，采用yum安装。 3.编写好一键安装nginx的脚本，连同nginx.conf配置文件都指定好内容，方便后面的playbook使用。 4.编写好一键安装MySQL的脚本，连同my.cnf配置文件都指定好内容，方便后面的playbook使用。 5.在ansible服务器和所有的nginx，MySQL，NFS服务器之间建立ssh免密通道 6.最后编写ansible的playbook文件去统一部署nginx，MySQL，nfs服务器 7.测试整个安装部署是否成功项目心得： 1.对ansible的在大规模集群里的使用有了一些了解，深入体会到批量部署的便捷 2.对集群有了一定的认识 3.编写脚本的能力有了提升 4.自己对*个故障的排除，提升自己的troubleshooting的能力============================================================================================写项目时1.摆数据 nginx ​ 是什么？有什么用？ ​ nginx是一个web服务器 ​ web就是网站 dns ​ domain name system 域名解析系统 ​ www.aliyun.com --&gt; ip ​ 为什么需要DNS？ ​ 方便记住某个网站名字 ​ ip很难记 正向解析：域名 --&gt; ip 反向解析： ip --&gt; 域名 在浏览器输入www,baidu.com回车后发生了什么？ ​ 1、浏览器缓存 ​ 2、hosts文件 ​ 3、本地dns服务器 ​ 4、转发服务器 ​ 5、根域名服务器 ​ 6、迭代过程 ​ 7、递归返回 ​ 8、直接访问 CDN内容分发网络：加速 （就近解析） #注：缓存有滞后的 #注：视频业务大量使用CDN 记录类型 ​ A记录 --&gt; address record ​ www --&gt; 120.77.248.190 需要上线一个自己的网站，有哪些流程(工作要做)？ 1、购买云服务器，部署nginx，mysql，Python等环境 2、购买域名 www.chenpeng.com，绑定域名和云服务器 --&gt; A记录 --&gt; 备案(服务器在国内必须备案) 3、开发网站 --&gt; 写网站 4、测试网站 5、上传到云服务器的nginx网页根目录下 --&gt; 上线 12[root@cPen_C lianxi]# yum provides nslookup#注：查看命令从哪个包安装 NFS ​ network file system 网络文件系统 ​ 有什么用？ ​ 共享文件 --&gt; 多台服务器使用相同的内容 #注：NFS是最廉价的解放方案，受网络影响、服务器硬件配置低，磁盘的速度，CPU，内存，网络带宽 都是比较差的 #注：比较贵的解决方案：上专业存储 #注：更好的是 SAN 光纤设备 SAN --&gt; NAS --&gt; 网络附加存储 SAN一般指存储区域网络。存储区域网络（Storage Area Network，简称SAN）采用网状通道（Fibre Channel ，简称FC，区别与Fiber Channel光纤通道）技术，通过FC交换机连接存储阵列和服务器主机，建立专用于数据存储的区域网络 NAS（Network Attached Storage：网络附属存储）按字面简单说就是连接在网络上，具备资料存储功能的装置，因此也称为“网络存储器”。 ansible ​ 项目 dns nginx一键部署 网站上线 NFS ​ SAN ​ NAS 1234567891011121314151617181920212223242526272829303132333435363738394041nginx一键安装 脚本#!/bin/bash#author:cali#time:2020-49#company:sanchuang#email:695811769@qq.commkdir -p /nginx2cd /nginx2#download nginxcurl -O http://nginx.org/download/nginx-1.17.9.tar.gz#创建用户useradd lihu#解压tar xf nginx-1.17.9.tar.gz #进入解压目录cd nginx-1.17.9#解决依赖关系yum -y install zlib zlib-devel openssl openssl-devel pcre pcre-devel gcc gcc-c++ autoconf automake make #配置./configure --prefix=/usr/local/nginx9 --user=lihu --group=lihu --with-threads --with-file-aio --with-http_ssl_module --with-http_stub_status_module --with-stream #编译和安装make -j 2 ; make install#开机启动echo &quot;/usr/local/nginx9/sbin/nginx&quot; &gt;&gt;/etc/rc.local chmod +x /etc/rc.d/rc.local #修改PATH变量echo &quot;PATH=/usr/local/nginx9/sbin:$PATH&quot; &gt;&gt;/etc/profilePATH=/usr/local/nginx9/sbin:$PATH#启动nginx","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"}]},{"title":"25_Linux基础-NFS服务","slug":"Linux_基础/25_Linux基础-NFS服务","date":"2022-10-13T04:00:00.000Z","updated":"2022-10-13T05:00:00.000Z","comments":true,"path":"posts/317b0311.html","permalink":"https://blog1.cpen.top/posts/317b0311.html","excerpt":"","text":"日志轮转： https://blog.csdn.net/weixin_43265596/article/details/85469405 https://www.cnblogs.com/liangyuxing/p/11962863.html https://blog.csdn.net/dhxaohei/article/details/8014764 一. NFS简介 **NFS（Network File System的简称，即网络文件系统）**可以通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。NFS可以将远程的计算机磁盘挂载到本地，读写文件像访问本地磁盘一样操作 前提：关闭selinx 关闭iptables 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811、安装[root@cPen_A lianxi]# yum install nfs-utils--------------------------------------------------------------------------------------------2、修改配置文件 /etc/exports[root@cPen_A lianxi]# vim /etc/exports #注：配置文件/opt/www 192.168.255.0/24(rw,no_root_squash) #注：192.168.255.0/24共享，rw权限 读写，no_root_squash 将远程根用户当成本地根用户，即不压制root首先创建/opt/www目录，在这下面创建index.html文件，文件内容”this is test nfs”再添加exports配置，nfs的配置：vim /etc/exports添加如下行：/opt/www 192.168.255.0/24(rw)表示共享/opt/www目录，给192.168.255./24这个网段的主机都可以通过nfs来访问我本地的/opt/www目录括号()里面的表示选项，rw表示读写生效配置：exportfs -a 或者重启服务[root@cPen_A opt]# cd /opt[root@cPen_A opt]# mkdir www[root@cPen_A opt]# cd www[root@cPen_A www]# vim index.htmlthis is test nfs[root@cPen_A www]# pwd/opt/www#注：/opt 放额外的软件包的目录--------------------------------------------------------------------------------------------3、启动nfs服务[root@cPen_A www]# service nfs start #注：启动服务[root@cPen_A www]# showmount -e #注：检测是否可以连接Export list for cPen_A:/opt/www 192.168.255.0/24#注：centos8下 启动 [root@cPen_B ~]# service nfs-server start---------------------------------------------------------------NFS的连接查看可以在server端先自我测试一下是否可以连接。命令：showmount [-ae] [hostname | IP]-a：显示当前主机与客户端的NFS连接共享的状态-e：显示某台主机的/etc/exports所共享的目录数据---------------------------------------------------------------4、在另一台机器上测试出现返回 表示ok[root@cPen_C ~]# showmount -e 192.168.255.28 #注：后面指定分析的机器的ip地址Export list for 192.168.255.28: #注：出现这种情况，表示可以连接 连通性没有问题/opt/www 192.168.255.0/245、挂载网络文件在另外一台机器[root@cPen_C ~]# mkdir /mnt2[root@cPen_C ~]# mount -t nfs 192.168.255.28:/opt/www /mnt2 #注：挂载网络文件[root@cPen_C ~]# df #注：使用df命令看磁盘挂载情况（这是网络磁盘挂载）192.168.255.28:/opt/www 17811456 2165760 15645696 13% /mnt2[root@cPen_C ~]# cd /mnt2[root@cPen_C mnt2]# lsindex.html[root@cPen_C mnt2]# cat index.html this is test nfs[root@cPen_C mnt2]# lsindex.html[root@cPen_A ~]# cd /opt/www/ #注：服务端A主机 操作[root@cPen_A www]# touch index2.html #注：服务端操作[root@cPen_C mnt2]# lsindex2.html index.html[root@cPen_C mnt2]# mkdir index2.htmlmkdir: 无法创建目录&quot;index2.html&quot;: 权限不够#注：客户机C没有权限去操作服务器A文件#没有权限的话 /etc/exports 设置 no_root_squash ，就可以操作了no_root_squash 将远程根用户当成本地根用户，即不压制root#注：让服务器将 远端的root用户 识别成 本地根用户#注：修改配置文件后，需要使用exportfs -a 生效配置；再重新挂载（先取消挂载，再重新挂载）#示例：取消挂载[root@cPen_C mnt2]# cd .. #注：先退出mnt2目录，否则报繁忙[root@cPen_C /]# umount /mnt2 #注：然后取消挂载#修改配置文件后，需要使用exportfs -a 生效#重新挂载： 先退出/mnt2目录，然后执行： umount /mnt2 再执行挂载 二. npcbind和nfs 启动nfs之前，确保rpcbind服务已经启动 nfs启动的时候，会向rpcbind服务注册端口，会返回一个端口给nfs使用 可以使用 rpcinfo -p 命令 查看nfs端口是否已经注册成功 rpcbind就像房东，nfs是租客 #注：nfs自己不能起端口，rpcbind为nfs注册端口 #注：nfs起来之前 要确保rpcbind起来 [root@cPen_A www]# rpcinfo -p #注：rpcbind为nfs起2049端口 100003 3 tcp 2049 nfs 三. 实验：nfs和nginx 搭配使用 负载均衡和文件共享 A: 192.168.0.73 nfs 真实机 B: 192.168.0.79 代理机+真实机 C: 192.168.0.53 真实机 前提： 三台主机都安装好nginx，其中一台开启nfs服务 在A机器上开启了nfs服务，网站目录存放在/opt/www下，B、C可以挂载A的/opt/www目录到本地 A机器配置好nfs服务，开启nfs服务，然后在A、C两台上 执行： [root@cPen_B ~]# mount -t nfs 192.168.0.73:/opt/www /opt/www [root@cPen_C ~]# mount -t nfs 192.168.0.73:/opt/www /opt/www 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192B机器变成代理机第1步：把8080端口起来修改A、B、C三台主机nginx的配置，启动8080端口，绑定域名www.sc.com#注：配置文件目录：/etc/nginx#注：进入 /etc/nginx/conf.d目录下 创建 sc.conf输入以下内容[root@cPen_A ~]# cd /etc/nginx/[root@cPen_A nginx]# cd conf.d/[root@cPen_A conf.d]# vim sc.conf #注：后缀必须是 .conf，自动加载读取 该配置文件server &#123; listen 8080; #注：监听8080端口 server_name www.sc.com; #注：指定域名 root /opt/www; #注：指定网站家目录，默认去家目录下找index.html&#125;[root@cPen_A conf.d]# nginx -t #注：进行语法检测[root@cPen_A conf.d]# nginx -s reload #注：生效配置[root@cPen_A conf.d]# lsof -i:8080 #注：8080端口起来了COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnginx 3193 root 6u IPv4 50354 0t0 TCP *:webcache (LISTEN)nginx 3194 nginx 6u IPv4 50354 0t0 TCP *:webcache (LISTEN)nginx 3195 nginx 6u IPv4 50354 0t0 TCP *:webcache (LISTEN)使用lsof -i:8080 端口是否启动使用curl -H &quot;Host: www.sc.com&quot; http://192.168.0.73:8080 查看返回的内容是否一致访问192.168.0.68的8080端口，以www.sc.com域名去访问[root@cPen_A ~]# curl -H &quot;Host: www.sc.com&quot; http://192.168.0.73:8080this is test nfs#注：三台机器访问返回的内容相同 都是 this is test nfs--------------------------------------------------------------------------------------------#注：在B机器上添加反向代理对B机器进行负载均衡：把请求转发到其他机器（代理转发）（高可用）[root@cPen_B conf.d]# vim sc.conf server &#123; listen 8080; server_name www.sc.com; root /opt/www;&#125;upstream sc &#123; #注：代理转发，为upstream取名为sc server 192.168.0.73:8080; server 192.168.0.53:8080; server 192.168.0.79:8080;&#125;#注：虚拟主机，让不同的域名做不同的事情server &#123; listen 80; server_name www.sc.com; root /opt/www; location / &#123; #注：访问网站的/目录，都会转发到sc proxy_set_header Host $host; #注：头部信息，不加的话 可能变成B的主机地址 #注：让客户端发过来的头部host字段信息 和转发包的头部host字段保持一致 proxy_pass http://sc; #注：设置后端代理服务器 &#125;&#125;server &#123; listen 80; server_name www.sc1.com; root /usr/share/www; location / &#123; proxy_set_header Host $host; proxy_pass http://sc; &#125;&#125;#注：输出www.sc.com时，请求时，会有数据包存放host头部信息:www.sc.com ，80端口收到这个包之后，知道是要转发到8080端口。B机器帮你请求A、B、C的8080端口发起请求#注：客户机发起请求 www.sc.com，host头部信息www.sc.com（请求包里的，客户机携带的头部信息），B主机交给相应的server去处理，请求B主机的80端口去处理，转发到8080端口，B主机帮你去请求，B收到包的时候，交给server去处理。这时候A发起的这个包的头部信息 可能就是B的ip地址了（不是www.sc.com了），8080端口收到请求后，没有B的ip地址的server_name，会转发失败。所以 proxy_set_header Host $host 让它们的头部信息保持一致--------------------------------------------------------------------------------------------#生效配置[root@cPen_B conf.d]# nginx -t[root@cPen_B conf.d]# nginx -s reload--------------------------------------------------------------------------------------------#然后多次访问80端口，查看返回内容是否一致，以及查看每台机器的/var/log/nginx/access.log日志是否有新的请求过来 tail -f /var/log/nginx/access.log[root@cPen_B conf.d]# curl -H &quot;Host: www.sc.com&quot; http://192.168.0.79this is test nfs#注：代理转发，访问80端口，转发到8080端口，分发到3台机器去执行了（负载均衡）[root@cPen_C conf.d]# tail -f /var/log/nginx/access.log #注：C主机下 ，B主机帮请求192.168.0.79 - - [01/Dec/2020:17:21:54 +0800] &quot;GET / HTTP/1.0&quot; 200 17 &quot;-&quot; &quot;curl/7.61.1&quot; &quot;-&quot;#注：平均打到3台，默认做轮转 #注：可以使用 killall nginx 全部杀死 #注：404 没找到，403 forbid 禁止 #注：A、B换成B、A nginx代理机+真实机 A nginx真实机 B nfs nginx真实机 C 客户端访问www.sc.com 访问A nginx代理机的80端口（代理的意思是转发） A机器 返回本机的8080去处理，或者B机器的8080去处理，或者C机器的8080去处理 负载均衡：2万人访问A机器80端口，80端口不会去处理请求，只是做代理转发，交给本机8080处理，或者B机器的8080处理，C机器的8080处理。A、B、C三台返回的页面网站 都要保持一致 把B机器/opt/www目录 挂载到A上和C上 （保存文件的一致性，改的都是B机器的nfs） #注：网络问题 桥接模式 VMnet0 同网段 NAT模式 VMnet8 同网段","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"NFS","slug":"NFS","permalink":"https://blog1.cpen.top/tags/NFS/"}]},{"title":"24_Linux基础-DNS服务","slug":"Linux_基础/24_Linux基础-DNS服务","date":"2022-10-12T04:00:00.000Z","updated":"2022-10-12T05:00:00.000Z","comments":true,"path":"posts/ecc378ee.html","permalink":"https://blog1.cpen.top/posts/ecc378ee.html","excerpt":"","text":"参考文章：https://blog.csdn.net/loukundeboke/article/details/80012231 DNS服务 DNS( Domain Name System) 域名系统 前提： 我们网络中都是使用ip地址通信，无论是访问服务，还是不同主机间进行数据交换 ip地址非常多，如果每个服务都通过ip地址来登录的话，用户就需要记住这些很复杂的ip地址，不方便用户使用 就像保存在手机里的电话号码一样，会有一个备注，通过这个备注 就可以找到正确的相应联系人的电话 那域名解析跟这个实现差不多，在普通用户中，我们用域名来访问服务，域名就通过域名解析来获取到ip地址 dns服务就像电话簿，提供了可以查询的域名到ip地址的映射关系 #注：在浏览器中输入www.taobao.com，敲回车的一瞬间，先去解析域名 #注：域名系统；提供域名解析；ip对于用户来说，使用没有域名方便 1. 完全限定域名 FQDN FQDN：Full Qualified Domain Name，完全限定域名，即每个域在全球网络都是唯一的；另外值得提到的一点是域并不是指诸如www.google.com这样的域名，而google.com才是域 #注：www.music.163.com/ 163.com是域，前面是主机名 123456安装dns服务软件包bind[root@cPen_B ~]# yum install bind#注：安装后，数据存放在/var/named/下[root@cPen_B ~]# cd /var/named/[root@cPen_B named]# lsdata dynamic named.ca named.empty named.localhost named.loopback slaves 2. 域的分类 一、根域（.） 全球13组根域名服务器以英文字母A到M依序命名，域名格式为“字母.root-servers.net” ​ 在/var/named/name.ca文件中可以查看 # 注：标识为. 二、顶级域 ​ 顶级域：顶级域（Top Level Domain，简称TLD）分为三类 ​ 1&gt; 通用顶级域：诸如 .com(商业机构) .org(非营利性组织) .net(网络服务机构)等 2&gt; 国家顶级域：诸如 .cn(中国) .uk(英国) .us(美国) .jp(日本) .hk 3&gt; 反向域（基础建设顶级域）：.arpa,即从IP到FQDN的反向解析 # 注：反向查找 #注：正向域：从域名到ip; 反向域：从ip到域名 三、 ​ 二级域 ​ 三级域 www.sc.163.com --&gt; 顶级域.com --&gt;二级域163.com --&gt;三级域sc.163.com ​ #注：前面的www是它的主机名 3. DNS解析 正向解析 域名 --&gt; ip 反向解析 ip --&gt; 域名 常用命令域名解析命令 12345678910111213141516171819202122232425262728293031323334常用命令域名解析命令1、Ping[root@cPen_A ~]# ping www.baidu.comPING www.a.shifen.com (14.215.177.38) 56(84) bytes of data.64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=1 ttl=55 time=16.3 ms#注：ping命令只能返回1个ip2、host安装bind-utils软件包yum install bind-utils[root@cPen_A ~]# host www.baidu.comwww.baidu.com is an alias for www.a.shifen.com.#注：为www.a.shifen.com取别名www.baidu.comwww.a.shifen.com has address 14.215.177.38 #注：ip地址www.a.shifen.com has address 14.215.177.393、dig #注：看的比较详细，推荐[root@cPen_A ~]# dig www.baidu.com;; ANSWER SECTION:www.baidu.com. 34 IN CNAME www.a.shifen.com.www.a.shifen.com. 216 IN A 14.215.177.38www.a.shifen.com. 216 IN A 14.215.177.394、nslookup[root@cPen_A ~]# nslookup www.baidu.comwww.baidu.com canonical name = www.a.shifen.com. #注：查询的时候会加上根域，平时感觉不到Address: 14.215.177.38Address: 14.215.177.39#注：可以拿DNS实现分流的作用。将新机器的域名地址解析成2个ip#注：负载均衡：把很多机器当做1台机器使用。DNS可以做到负载均衡，把流量分发到很多机器#注：高可用：1台机器去服务 它跪掉了，高可用就是这台机器跪掉了，把流量引导其他机器#注：高可用 避免单点故障#注：运维思想：备份、高可用。比如系统盘2块，其中1块跪掉了，另外一块还能继续服务#注：负载均衡和高可用 一般一起存在 DNS服务软件：bind 12345678910111213141516171819202122232425262728293031323334353637383940DNS服务软件：bind默认端口 udp协议 53号端口[root@cPen_A ~]# less /etc/services domain 53/udp示例：修改/etc/hosts文件--------------------------------------------------------------------------------------------[root@cPen_A ~]# cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6[root@cPen_A ~]# ping localhost #注：解析成127.0.0.1PING localhost (127.0.0.1) 56(84) bytes of data.[root@cPen_A ~]# cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6127.0.0.1 www.baidu.com baid.com #注：添加这一行[root@cPen_A ~]# ping www.baidu.comPING www.baidu.com (127.0.0.1) 56(84) bytes of data. #注：解析成127.0.0.1[root@cPen_A ~]# ping baid.comPING www.baidu.com (127.0.0.1) 56(84) bytes of data. #注：解析成127.0.0.1#注：/etc/hosts文件 解析时 优先级最高示例--------------------------------------------------------------------------------------------[root@cPen_A html]# pwd/usr/share/nginx/html[root@cPen_A html]# vim index.htmlhello worldcPen[root@cPen_A html]# ip a inet 192.168.0.19/24 brd 192.168.0.255 scope global noprefixroute dynamic ens33#Windows机器上Windows：C:\\Windows\\System32\\drivers\\etc\\hosts#注：hosts文件里# localhost name resolution is handled within DNS itself.# 127.0.0.1 localhost# ::1 localhost192.168.0.39 www.ldj.com #注：添加这一条这样在浏览器查找 www.ldj.com 就会访问到linux机器上的网址。www.ldj.com被解析成192.168.0.39 4. DNS解析过程 DNS解析过程： #注：面试题：当敲入www.baidu.com 发生什么事情 1、先查找本地hosts文件，linux：/etc/hosts; Windows：C:\\Windows\\System32\\drivers\\etc\\hosts 可以解析就直接返回地址 2、hosts文件不能解析，去看本地缓存。如果有，则返回结果，没有就进行下一步查找 linux下域名缓存：nscd服务 [root@cPen_A html]# yum install nscd [root@cPen_A html]# service nscd restart #注：清除缓存 (重启服务就是清除缓存) 缓存会有缓存时间，缓存多久可以指定的 #注：设置了DNS服务，但是设置了没有生效，考虑1、缓存 清除缓存和2、/etc/hosts是否写死 3、本地缓存没有找到，就会去请求本地的域名服务器，本地域名服务器有 就返回查询结果 Linux下指定域名解析服务器文件 /etc/resolv.conf （配置本地域名服务器ip地址的文件） 第1个指定的nameserver就是首选dns服务器，剩下的都是备选dns服务器 123456[root@cPen_A html]# vim /etc/resolv.conf # Generated by NetworkManagernameserver 114.114.114.114 #注：可以指定多个ip 去解析ipnameserver 192.168.0.1 #注：用nameserver指定[root@cPen_A html]# dig www.baidu.com;; SERVER: 114.114.114.114#53(114.114.114.114) #注：访问114.114.114.114 53号端口去解析ip 4、本地域名服务器没有找到相应记录，如果设置转发查找，就会去转发的服务器上去查询。如果没有设置转发，或者都没有找到，就会去根域查找 （迭代查找） 本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机 #注：面试题：当敲入www.baidu.com 发生什么事情 （DNS解析流程） 答：DNS解析流程 第1步 先去 本地hosts文件(/etc/hosts)去找 ip和域名的映射关系。有就返回。没有就去 第2步 本地DNS缓存 找…。有就返回。没有就去 第3步 本地的域名服务器 (/etc/resolv.conf)找…。有就返回。没有就 第4步 如果本地域名服务器 设置转发查找，就会去转发的服务器 上找…， 有就返回。 没有找到 或 没有设置 就去 根域查找，先在根域里找到顶级域的服务器ip地址 返回顶级域的ip地址给本地域名服务器 本地域名服务器再去顶级域名服务器 找，没有找到就返回二级域服务器的ip地址，本地域名服务器去二级域里找，没有找到 返回三级域的ip地址给本地域名服务器……迭代查找，直到找到整个域名才返回 或者说 去根域查找，迭代查找， 直到找到为止 5. dns服务的类型 dns服务的类型 缓存域名服务器 主域名服务器 这上面定义了真正的ip到域名的映射关系 从域名服务器 上面的数据域名映射 从主域名服务器获取 1、缓存域名服务器 也称为 唯高速缓存服务器 通过向其他域名服务器查询获得域名-&gt;IP地址记录 将域名查询结果缓存到本地，提高重复查询时的速度 2、主域名服务器 特定DNS区域的官方服务器，具有唯一性，权威性 负责维护该区域内所有域名-&gt;IP地址的映射记录 3、从域名服务器 也称为 辅助域名服务器 其维护的 域名-&gt;IP地址记录 来源于主域名服务器 6. 域名服务器配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781、安装bind、bind-utils域名解析主程序[root@cPen_B etc]# which named/usr/sbin/named2、配置文件如果没有安装bind-chroot软件包主配置文件： /etc/named.conf 数据文件位于：/var/named/目录[root@cPen_B etc]# less /etc/named.conf 3、修改配置 1、 vim /etc/named.conf # 注：全局配置文件options &#123; listen-on port 53 &#123; 127.0.0.1; &#125;; listen-on port 53 &#123; any; &#125;; # 注：将监听地址改成any，设置监听在本机的任意ip上 allow-query &#123; localhost; &#125;; # 注：允许访问服务的主机 allow-query &#123; any; &#125;; # 注：将权限设置为any，允许任何人来查询zone &quot;.&quot; IN &#123; # 注：定义根域 type hint; # 注：指定根域 file &quot;named.ca&quot;; # 注：在named.ca里去找 /var/named/named.ca&#125;;include &quot;/etc/named.rfc1912.zones&quot;; # 注：定义其他域include &quot;/etc/named.root.key&quot;; 2、域配置文件 /etc/named.rfc1912.zones添加域配置：[root@cPen_B ~]# vim /etc/named.rfc1912.zoneszone &quot;sc.com&quot; IN &#123; # 注：添加sc.com域的解析 type master; # 注：主域名服务器 file &quot;&quot;sc.com&quot;&quot;; # 注：域名配置存放文件 (域的解析从哪里文件里去找) allow-update &#123; none; &#125;;&#125;;4、配置指定域的解析文件目录：/var/named#注：注意权限， named用户要可读#注：注意属组[root@cPen_B named]# cp named.empty sc.com[root@cPen_B named]# pwd/var/named[root@cPen_B named]# vim sc.com $TTL 3H ; 注：缓存时间@ IN SOA sc.com. ( ; 注：修改的地方 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS @ A 127.0.0.1 AAAA ::1;注：A记录 正向解析记录 dns A 192.168.136.129 ;注：dns服务器的IP地址www A 192.168.136.129 ;注：www服务器的IP地址* A 192.168.136.123 ;注：配置泛域名解析;mail MX 192.168.136.129 ;注：分号注释;dns IN 600 A 192.168.136.129 ;注：配置A记录解析 缓存时间为600s[root@cPen_B named]# service named restart # 注：重启服务[root@cPen_B named]# lsof -i:53 # 注：端口起来了COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnamed 1839 named 21u IPv4 42519 0t0 TCP localhost:domain (LISTEN)named 1839 named 22u IPv4 42521 0t0 TCP cPen_B:domain (LISTEN)named 1839 named 23u IPv6 42523 0t0 TCP localhost:domain (LISTEN)[root@cPen_B named]# dig www.sanchuang.com;; SERVER: 192.168.136.2#53(192.168.136.2)[root@cPen_B named]# cat /etc/resolv.conf # 注：指定本机的DNS服务器# Generated by NetworkManagersearch localdomainnameserver 192.168.136.2[root@cPen_B named]# dig www.sc.com @192.168.136.129 # 注：用192.168.136.129去解析;; QUESTION SECTION:;www.sc.com. IN A;; ANSWER SECTION:www.sc.com. 10800 IN A 192.168.136.129 # 注：解析成功;; AUTHORITY SECTION:sc.com. 10800 IN NS sc.com. 123456789101112#设置反向域[root@cPen_B named]# vim /etc/named.rfc1912.zoneszone &quot;1.0.0.127.in-addr.arpa&quot; IN &#123; type master; file &quot;named.loopback&quot;; allow-update &#123; none; &#125;;&#125;;[root@cPen_B named]# pwd/var/named[root@cPen_B named]# less named.loopback 7. 资源记录类型 资源记录类型 （1）A记录（Address）正向解析 A记录是将一个主机名（全称域名FQDN）和一个IP地址关联起来。这也是大多数客户端程序默认的查询类型。 （2）PTR记录（Pointer）反向解析 PTR记录将一个IP地址对应到主机名（全称域名FQDN）。这些记录保存在in-addr.arpa域中。 （3）CNAME记录(Canonical Name)别名 别名记录，也称为规范名字(Canonical Name)。这种记录允许您将多个名字映射到同一台计算机。 （4）MX记录（Mail eXchange） MX记录是邮件交换记录，它指向一个邮件服务器，用于电子邮件系统发邮件时根据 收信人的地址后缀来定位邮件服务器。MX记录也叫做邮件路由记录，用户可以将该域名下的邮件服务器指向到自己的mail server上，然后即可自行操控所有的邮箱设置。 当有多个MX记录（即有多个邮件服务器）时，则需要设置数值来确定其优先级。通过设置优先级数字来指明首选服务器，数字越小表示优先级越高。 （5）NS记录（Name Server） NS（Name Server）记录是域名服务器记录，也称为授权服务器，用来指定该域名由哪个DNS服务器来进行解析。 将网站的NS记录指向到目标地址，在设置NS记录的同时还需要设置目标网站的指向，否则NS记录将无法正常解析 NS记录优先于A记录。即，如果一个主机地址同时存在NS记录和A记录，则A记录不生效。 8. 小节 DNS服务 DNS( Domain Name System) 域名系统 #注：域名系统；提供域名解析；ip对于用户来说，使用没有域名方便 FQDN 完全限定域名 www.baidu.com 域：baidu.com 主机名：www 域名分类 根类（.） 全国只有13组 顶级域 通用域名 .com 用于商业 .org 非盈利性组织 .net 网络服务 国家 .cn .jp .hk .us 反向解析域 .arpa 二级域，三级域…… DNS解析 正向解析 把域名解析成ip 反向解析 把ip解析成域名 DNS解析流程（面试） 1、先查找本地hosts文件 有没有对应ip和域名的映射关系，存在就返回 2、hosts文件里没有找到，就会在本地缓存中查找，如果找到就返回结果 完成解析 3、本地缓存中没有找到，就会去本地域名服务器查找，找到返回结果 完成解析 4、本地域名服务器中没有，如果设置了转发查找 就会去转发服务器查找。如果没有找到 就会去根域去找顶级域的服务器ip地址，返回给本地域名服务器，本地域名服务器再去顶级域服务器上 找二级域服务器ip地址，依次类推 直到找到整个域名结果为止 5、DNS迭代查询之后，如果拿到结果 就返回给本地域名服务器，本地域名服务器再返回给客户端 #注：DNS客户机迭代查找 DNS服务简单搭建 软件包安装 bind bind-utils 配置文件 主配置文件 /etc/named.conf 域配置文件 /etc/named.rfc1912.zones 数据目录 /var/named 下面文件 需要给named用户可读权限 DNS端口 53 UDP 记录类型 A记录 正向解析记录 PTR记录 反向解析记录 CNAME 别名 MX 邮件记录 NS 授权dns服务器 泛域名解析 对于域sc.com添加：* A 192.168.0.39 #注：只是对主机名的泛域名解析 表示主机名任意 123.sc.com #注：abc.123.sc.com不可以 abc.sc.com 常见的域名解析命令 ping host dig nslookup 相关配置文件 /etc/hosts 指定域名和ip的对应关系，优先级最高 /etc/resolv.conf 指定dns服务器地址 网络连通性都是访问服务的前提条件","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"DNS","slug":"DNS","permalink":"https://blog1.cpen.top/tags/DNS/"}]},{"title":"23_Linux基础-ansible2","slug":"Linux_基础/23_Linux基础-ansible2","date":"2022-10-11T04:00:00.000Z","updated":"2022-10-11T05:00:00.000Z","comments":true,"path":"posts/b0a8892b.html","permalink":"https://blog1.cpen.top/posts/b0a8892b.html","excerpt":"","text":"一. 云计算 云计算 openstack docker kvm 虚拟化技术：在本身物理机的基础上虚拟出云主机 #唯一的不好是 安全性不高 数据保存在别人那里的 (影响不大) #trouble shooting的能力 问题解答的能力 #注：ssh开启2种验证 - 先公钥认证 再密码认证 密码认证失败 提示permit deny 二. ansible不是守护进程 #ansible 不是守护进程 执行ansible命令的时候才会执行ansible #守护进程：一直在内存里面，等待别人连接 #ssh是守护进程 #执行1条命令 命令不是守护进程 #ansible不是一个守护进程（守护进程：起来后一直在内存中运行，等待其他人访问） #ansible就是一个命令脚本，使用Python写的 #[root@cPen_A ansible]# sudo -i #注：直接回到root用户 三. ansible的模块 ansible的模块 1. copy模块 从本地copy文件分发到目录主机路径 参数说明: src= 源文件路径 # 注：source 源 ​ dest= 目标路径 # 注：destination 目的地 ​ 注意src= 路径后面带/ 表示带里面的所有内容复制到目标目录下，不带/是目录递归复制过去 ​ content= 自行填充的文件内容 ​ owner 属主 ​ group 属组 ​ mode权限 123456789101112131415示例1：shell模块、copy模块---------------------------------------------------------------------------------------------------------------------------------#示例1：使用ansible 在B、C主机创建/lianxi 目录#-m 指定模块#-a 传的参数ansible 接 指定主机 -m 指定模块 -a 执行的参数[root@cPen_A ansible]# ansible all -m shell -a &quot;mkdir /lianxi -p&quot;#注：rc ==&gt; reutrn code --&gt; 为0表示执行成功#注：rc ==&gt; reutrn code --&gt; 为1表示执行失败#示例2：将ansible-copy文件 复制到主机B、C/lianxi/ansible目录下，指定权限属主数组[root@cPen_A lianxi]# vim ansible-copy[root@cPen_A lianxi]# ansible all -m copy -a &quot;src=/lianxi/ansible-copy dest=/lianxi/ansible mode=777 owner=sanchuang group=sanchuang&quot;#注：确认B、C主机 指定的用户sanchuang和组sanchuang存在#md5sum 一般来说 是 信息的摘要 判定文件是否被修改 12345678910111213141516示例2：指定webser组，将/etc/passwd 赋值到主机/tmp目录下，指定权限777---------------------------------------------------------------------------------------------------------------------------------[root@cPen_A lianxi]# ansible webser -m copy -a &quot;src=/etc/passwd dest=/tmp mode=777&quot;===========================================================================================示例3：copy src路径后面带/不带/的区别---------------------------------------------------------------------------------------------------------------------------------#注：src= 路径后面带/ 表示带里面的所有内容复制到目标目录下，不带/是目录递归复制过去#注：不带/[root@cPen_A copy_dir]# ansible all -m copy -a &quot;src=/lianxi/copy_dir dest=/lianxi/ansible&quot;#注：带/[root@cPen_A copy_dir]# ansible all -m copy -a &quot;src=/lianxi/copy_dir/ dest=/lianxi/ansible&quot;#带/表示拷贝目录下的子文件或者子文件夹#不带/表示拷贝整个目录 2. fetch模块 #注：从远程主机拉取文件到本地 123456789101112131415161718示例---------------------------------------------------------------------------------------------------------------------------------[root@cPen_A lianxi]# ansible webser -m fetch -a &quot;src=/etc/hostname dest=/lianxi mode=644&quot;192.168.0.22 | CHANGED =&gt; &#123; &quot;changed&quot;: true, &quot;checksum&quot;: &quot;c468f7340237d9f531122f5b03345ce8ac5641b4&quot;, # 注：拉去下来后会比较 &quot;dest&quot;: &quot;/lianxi/192.168.0.22/etc/hostname&quot;, &quot;md5sum&quot;: &quot;8d23b0947f191eb9c20728677271eb4d&quot;, &quot;remote_checksum&quot;: &quot;c468f7340237d9f531122f5b03345ce8ac5641b4&quot;, # 注：和远程比较 内容是否变更 &quot;remote_md5sum&quot;: null&#125;#注：大文件传送中途 突然断掉了 ，文件没有传完 保存的md5sum和它的md5sum不一样#注：如果2个值一致 说明传完了[root@cPen_A lianxi]# ls # 注：路径自动加了个以ip地址为名的文件夹192.168.0.20 192.168.0.22 ansible-copy copy_dir[root@cPen_A lianxi]# cd 192.168.0.20[root@cPen_A 192.168.0.20]# lsetc 123456从远程主机拉取文件到本地fetch会自动的在dest指定目录后加上远程主机命名的目录结构后面接src目录结构fetch存储到本地的目录结构 dest + 远程主机名 + src#注：md5可以判定 1、文件是否修改；2、文件是否传完#注：或者使用任何hash算法中的其中一种，去比较值是否相等 3. command模块 在远程主机上执行命令,属于裸执行,非键值对显示;不进行shell解析 1234567891011121314151617181920示例1：command、shell---------------------------------------------------------------------------------------------------------------------------------[root@cPen_A 192.168.0.20]# ansible all -m command -a &quot;ifconfig&quot;[root@cPen_A 192.168.0.20]# ansible all -m shell -a &quot;ifconfig&quot;示例2：command裸执行 (后面传的参数不会做解析)---------------------------------------------------------------------------------------------------------------------------------#注：把ifconfig|grep inet整个当做1个命令去执行[root@cPen_A 192.168.0.20]# ansible all -m command -a &quot;ifconfig|grep inet&quot;192.168.0.22 | FAILED | rc=2 &gt;&gt;[Errno 2] 没有那个文件或目录#属于裸执行，不会解析它的管道符号 会认为ifconfig|grep inet 是一个命令#注：shell可以 (后面传的参数会做解析)[root@cPen_A 192.168.0.20]# ansible all -m shell -a &quot;ifconfig|grep inet&quot;============================================================================================[root@cPen_A ansible]# ifconfig # 注：查看网卡(看的东西多一点)#注：可以看接收包、返回包、字节，有多少错误[root@cPen_A ansible]# ip a # 注：查看网卡 4. shell模块 1234示例---------------------------------------------------------------------------------------------------------------------------------[root@cPen_A 192.168.0.20]# ansible all -m shell -a &quot;ifconfig|grep inet&quot;跟command一样，只不过shell模块可以解析管道之类的功能 5. file模块 设置文件属性(创建文件) 常用参数: path目标路径 state directory为目录,link为软件链接 group 目录属组 owner 属主 等,其他参数通过ansible-doc -s file 获取 state – absent 删除文件和目录的 directory 目录 touch 新建空文件 link 软链接 hard 硬链接 1234567891011121314示例1：查看file文件帮助信息--------------------------------------------------------------------------------------------[root@cPen_A lianxi]# ansible-doc -s file # 注：查看file文件帮助信息============================================================================================示例2：在目标主机/tmp目录下创建目录#注：创建文件目录---------------------------------------------------------------------------------------------------------------------------------[root@cPen_A lianxi]# ansible all -m file -a &quot;path=/tmp/sanchuang state=directory&quot;============================================================================================示例3：设置修改文件属性---------------------------------------------------------------------------------------------------------------------------------[root@cPen_A lianxi]# ansible all -m file -a &quot;path=/tmp/passwd owner=sanchuang&quot; 6. cron模块 通过cron模块对目标主机生成计划任务 常用参数: 除了分(minute)时(hour)日(day)月(month)周(week)外 name: 本次计划任务的名称 state: present 生成(默认) |absent 删除 (基于name) 12345678#注：首先查看程序有没有起来[root@cPen_A ~]# ps -ef |grep crondroot 702 1 0 10:59 ? 00:00:00 /usr/sbin/crond -nroot 3582 3553 0 14:41 pts/3 00:00:00 grep --color=auto crond#注：学会看日志[root@cPen_A ~]# cd /var/log/[root@cPen_A log]# less cronNov 25 12:01:01 cPen_A run-parts(/etc/cron.hourly)[3498]: finished 0anacron 123456789101112131415示例1：添加计划任务---------------------------------------------------------------------------------------------------------------------------------#注：每三分钟输出当前时间，到/tmp/time.txt文件中[root@cPen_A log]# ansible all -m cron -a &quot;minute=*/3 job=&#x27;date &gt;&gt;/tmp/time.txt&#x27; name=date_test state=present&quot; # 注：minute=*/3 指定每3分钟 date &gt;&gt;/tmp/time.txt 命令[root@cPen_B ~]# crontab -l#Ansible: date_test*/3 * * * * date &gt;&gt;/tmp/time.txt[root@cPen_A log]# ansible 192.168.0.20 -m cron -a &quot;minute=*/3 job=&#x27;date &gt;&gt;/tmp/time.txt&#x27; name=date_test state=present&quot; # 注：可以单独为某个主机设置 并非一定批量处理============================================================================================示例2：删除计划任务---------------------------------------------------------------------------------------------------------------------------------[root@cPen_A log]# ansible 192.168.0.20 -m cron -a &quot;name=date_test state=absent&quot; 123456ntp服务是一个时间管理服务器示例：ntp服务 系统时间管理服务[root@cPen_A log]# yum install ntp # 注：centos7[root@cPen_B ~]# yum install chrony # 注：centos8里面 ntp已被 chrony取代[root@cPen_A log]# ntpdate ntp1.aliyun.com # 注：同步阿里云的时间#注：使用ntp客户端 同步ntp的服务器 把时间同步 7. yum模块 故名思义就是yum安装软件包的模块; 常用参数说明: enablerepo,disablerepo表示启用与禁用某repo库 name 安装包名 state (present’ orinstalled’, latest’)表示安装, (absent’ or `removed’) 表示删除 #注：name安装的包名 state 安装还是卸载 1234示例：安装wget[root@cPen_A log]# ansible all -m yum -a &quot;name=wget state=installed&quot;示例：卸载wget[root@cPen_A log]# ansible all -m yum -a &quot;name=wget state=absent&quot; 8. service模块 服务管理模块 常用参数: name:服务名 state:服务状态 started（启动） stopped（关闭） restarted（重启） reloaded（重新加载） enabled: 是否开机启动 true|false runlevel: 启动级别 (systemed方式忽略) 1234567#安装文件传输服务vsftpd[root@cPen_A log]# ansible all -m yum -a &quot;name=vsftpd state=installed&quot;示例：关闭vsftpd服务[root@cPen_A log]# ansible all -m service -a &quot;name=vsftpd state=stopped&quot;示例：开启vsftpd服务[root@cPen_A log]# ansible all -m service -a &quot;name=vsftpd state=started&quot; 9. script模块 1、把本地的脚本传到远端执行;前提是到远端可以执行,不要把Linux下的脚本同步到windows下执行; #注：只在远程服务器执行脚本，不上传脚本到远程服务器 12345678910111213[root@cPen_A ~]# vim test.sh#!/bin/bashecho &quot;test ansible&quot; &gt;&gt;/tmp/ansible.txt[root@cPen_A ~]# ansible all -m script -a &quot;/root/test.sh&quot; # 注：/root/test.sh脚本路径--------------------------------------------------------------------------------------------示例：执行慢 机器多 怎么解决答：可以使用多进程去执行-f 6 指定6个进程去执行command模块不能识别管道符号、shell模块 可以识别copy模块 推送script模块 不需要上传脚本，在远程服务器执行脚本 四. 查看系统版本 12345示例：查看系统版本[root@cPen_B ~]# uname -r # 注：查看系统内核4.18.0-193.el8.x86_64[root@cPen_B ~]# cat /etc/redhat-release # 注：查看/etc/redhat-release 去查看系统版本CentOS Linux release 8.2.2004 (Core) 五. 链接 1234567891011121314151617181920212223242526272829示例：软链接[root@cPen_A lianxi]# ln -s ansible-copy ansible-copy-likcs-s #注：前面原文件 后面链接文件[root@cPen_A lianxi]# ls -al # 注：-s soft软lrwxrwxrwx 1 root root 12 11月 25 11:30 ansible-copy-likcs-s -&gt; ansible-copy#注：软连接 相当于快捷方式#注：软链接删掉不会影响原文件，软链接的原文件删掉了会影响链接文件示例：硬链接[root@cPen_A lianxi]# ln ansible-copy ansible-copy-link[root@cPen_A lianxi]# ls -al-rw-r--r-- 2 root root 20 11月 25 10:12 ansible-copy-linkrm -rf 删除源文件 硬链接文件 依旧没事#注：硬链接 可以去做备份#注：硬链接的原文件删掉了不会影响链接文件#软链接、硬链接#创建一个硬链接 文件的链接数会+1#删除硬链接文件或者是源文件 只是把文件的链接数-1 文件不会被真正删除#创建一个硬链接[root@cPen_A lianxi]# ls -al-rw-r--r-- 2 root root 20 11月 25 10:12 ansible-copy # 注：链接为2#注：软链接lrwxrwxrwx 1 root root 12 11月 25 11:30 ansible-copy-likcs-s -&gt; ansible-copy # 注：链接为1#注：硬链接-rw-r--r-- 2 root root 20 11月 25 10:12 ansible-copy-link # 注：链接为2符号链接数 1 是rm -rf 删除的是 文件名 和 磁盘里面data的链接data还存在于磁盘里 ，过一段时间 新的数据会覆盖 data#注：为1表示删除了后就没有了，为2表示删除后还有 六. playbook 如果ansible的各模块(能实现各种功能)是车间里的各工具;playbook就是指导手册,目标远程主机就是库存和原料对象 #注：语法 yaml格式配置 1、playbook的核心元素 hosts : playbook配置文件作用的主机 tasks: 任务列表 variables: 变量 templates:包含模板语法的文本文件 handlers :由特定条件触发的任务 roles :用于层次性、结构化地组织playbook。roles 能够根据层次型结构自动装载变量文件、tasks以及handlers等 2、playbook运行方式 ansible-playbook --check 只检测可能会发生的改变,但不真执行操作 ansible-playbook --list-hosts 列出运行任务的主机 ansible-playbook --syntax-check playbook.yaml 语法检测 ansible-playbook -t TAGS_NAME playbook.yaml 只执行TAGS_NAME任务 ansible-playbook playbook.yaml 运行 123456789101112131415161718192021222324示例：编写/执行 playbook--------------------------------------------------------------------------------------------#注：把A机器的/etc/passwd复制到其他机器的/tmp/passwd_tmp下[root@cPen_A ~]# vim ansible_playbook_sc.yaml #注：编写playbook- hosts: all remote_user: root tasks: - name: up file copy: src=/etc/passwd dest=/tmp/passwd_tmp#执行playbook[root@cPen_A ~]# ansible-playbook ansible_playbook_sc.yaml ============================================================================================示例：yaml文件怎么去编写--------------------------------------------------------------------------------------------#第1步 先安装python3：yum install python3#第2步 使用pip3安装PyYaml模块[root@cPen_A ~]# pip3 install PyYaml[root@cPen_A ~]# python3&gt;&gt;&gt; import yaml&gt;&gt;&gt; fp = open(&quot;ansible_playbook_sc.yaml&quot;)&gt;&gt;&gt; dict = yaml.load(fp)&gt;&gt;&gt; dict[&#123;&#x27;hosts&#x27;: &#x27;all&#x27;, &#x27;remote_user&#x27;: &#x27;root&#x27;, &#x27;tasks&#x27;: [&#123;&#x27;name&#x27;: &#x27;up file&#x27;, &#x27;copy&#x27;: &#x27;src=/etc/passwd dest=/tmp/passwd_tmp&#x27;&#125;]&#125;] 123456789101112131415#注：使用1、创建yaml文件[root@cPen_A ~]# cat ansible_playbook_sc.yaml # 注：类似于字典形式 - 相当于list ；里面相当于字典- hosts: all # 注：对所有主机生效（什么组） remote_user: root # 注：root用户执行 tasks: # 注：让它做什么事情 - name: up file # 注：事情名字叫up file copy: src=/etc/passwd dest=/tmp/passwd_tmp # 注：使用copy模块 执行源 目的地址2、可以使用Python解析yaml&gt;&gt;&gt; import yaml&gt;&gt;&gt; fp = open(&quot;ansible_playbook_sc.yaml&quot;)&gt;&gt;&gt; dict = yaml.load(fp)&gt;&gt;&gt; dict[&#123;&#x27;hosts&#x27;: &#x27;all&#x27;, &#x27;remote_user&#x27;: &#x27;root&#x27;, &#x27;tasks&#x27;: [&#123;&#x27;name&#x27;: &#x27;up file&#x27;, &#x27;copy&#x27;: &#x27;src=/etc/passwd dest=/tmp/passwd_tmp&#x27;&#125;]&#125;]#注：使用copy模块 来指定src dest 123456789101112131415示例：多个操作--------------------------------------------------------------------------------------------[root@cPen_A ~]# vim ansible_playbook_sc.yaml # 注：编写- hosts: all remote_user: root tasks: - name: up file copy: src=/etc/passwd dest=/tmp/passwd_tmp - name: download redis yum: name=redis state=installed- hosts: webser tasks: - name: remove file shell: rm -rf /tmp/passwd_tmp[root@cPen_A ~]# ansible-playbook ansible_playbook_sc.yaml # 注：运行 七. 总结 ansible通过常用模块在命令行就可以针对主机清单来管理配置远程主机,无需要代理客户端程序,但需要目标主机有ssh和python2.4+;基于ssh协议既可以通过用户名和密码,也可以通过私钥,推荐使用私钥; windows上需要安装powershell及winrm服务也可以做到,关于这方面 可以参考我之前的博客 ansible自动化管理windows 通过ansib-doc来获取模块信息及指定模块帮助信息; ansible-playbook 基于YAML语法配置;可以对playbook文件进行测试,解析并执行应用于指定无端主机;非常方便我们统一编排分发管理远程主机; 八. 练习 1234567891011121314151617181920212223242526272829303132333435363738394041示例：每天凌晨1点 检查/etc/passwd 文件是否被修改，并且生成检查报告示例：编写脚本 实现ansible node节点(管理的主机)服务器备份 备份/var/log/messages日志 备份到/backup目录下，并且取名2020-11-25-01-log.tar.gz，每一个小时执行一次############################################################################################示例：每天凌晨1点 检查/etc/passwd 文件是否被修改，并且生成检查报告-----------------------------------------------------------------------------------------------------------方法1 md5sum 检查文件是否修改 md5sum -c --statuscheck_file.shmd5sum -c --status d.md5 &amp;&amp;echo &quot;文件未被修改&quot; ||echo &quot;文件已被修改&quot;md5sum /etc/passwd &amp;&gt; d.md5 #注：文件名必须是 d.md5-----------------------------------------------------------------------------------------------------------方法2check_ectpasswd.sha=&#x27;md5sum /etc/passwd&#x27; #注：现在的md5值b=&#x27;tail -n1 /root/b&#x27; #注：上次的md5值[[ $a==$b ]]&amp;&amp;echo &quot;文件未被修改!&quot; &gt;&gt; /root/c||echo &quot;文件已被修改!&quot; &gt;&gt; /root/c$a &gt;&gt; /root/b-----------------------------------------------------------------------------------------------------------方法3touch /tmp/passwd.logtouch /tmp/passwd.txta=`md5sum /etc/passwd`b=`md5sum /tmp/passwd.txt`c=$&#123;a:0:32&#125; #注：因为md5sum是任意长度的输入 固定长度的输出d=$&#123;b:0:32&#125;if [ $c = $d ] then echo &quot;$(date)文件未被修改&quot; &gt;&gt;/tmp/passwd.log cat /etc/passwd &gt;/tmp/passwd.txtelse echo &quot;$(date)文件已被修改&quot; &gt;&gt;/tmp/passwd.log cat /etc/passwd &gt;/tmp/passwd.txtfi ===========================================================================================================ansible_playbook_zuoye.yaml - hosts: all remote_user: root tasks: - name: check file cron: hour=1 day=*/1 job=&#x27;/usr/bin/bash ~/check_file.sh&#x27;#注：需要把脚本file到各个虚拟机，没有写这一步 123456示例：编写脚本 实现ansible node节点(管理的主机)服务器备份 备份/var/log/messages日志 备份到/backup目录下，并且取名2020-11-25-01-log.tar.gz，每一个小时执行一次 - hosts: all remote_user: root tasks: - name: backup messages cron: hour=1 job=&#x27;tar czf /backup/$(date +%Y-%m-%d-%H-log.tar.gz) /var/log/messages&#x27; 12345678910111213141516示例：md5sum 检查文件是否修改 md5sum -c --status[root@cPen_A lianxi]# man md5sum -c, --check read MD5 sums from the FILEs and check them --status don&#x27;t output anything, status code shows success[root@cPen_A lianxi]# md5sum /etc/passwd &gt; d.md5 #注：写进这个文件 文件名必须是这个 不能变[root@cPen_A lianxi]# cat d.md5 28b2503e7fb565ddc0b8ec1f9ad6a9c7 /etc/passwd[root@cPen_A lianxi]# md5sum -c --status d.md5 #注：检查文件是否修改[root@cPen_A lianxi]# echo $? #注：文件未修改，返回00[root@cPen_A lianxi]# useradd chen223344[root@cPen_A lianxi]# md5sum -c --status d.md5[root@cPen_A lianxi]# echo $? #注：文件修改，返回11","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Ansible","slug":"Ansible","permalink":"https://blog1.cpen.top/tags/Ansible/"}]},{"title":"01_Other-Supervisor管理进程-Twikoo版本升级","slug":"Other/01_Other-Supervisor管理进程-Twikoo版本升级","date":"2022-10-10T04:00:00.000Z","updated":"2023-10-10T05:00:00.000Z","comments":true,"path":"posts/88a726.html","permalink":"https://blog1.cpen.top/posts/88a726.html","excerpt":"","text":"1. Supervisor 管理 Twikoo 参考文章 参考文章： https://blog.csdn.net/cyt0906/article/details/107344361 https://www.cnblogs.com/loveCrane/p/15954893.html 12345yum install epel-release #安装yum源yum install -y supervisorsupervisord -c /etc/supervisord.conf 12345678910111213141516171819202122232425262728cat /etc/supervisord.d/test.conf#项目名[program:blog]#脚本目录directory=/opt/bin#脚本执行命令command=/usr/bin/python /opt/bin/test.py#supervisor启动的时候是否随着同时启动，默认Trueautostart=true#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的autorestart=false#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1startsecs=1#脚本运行的用户身份 user = test#日志输出 stderr_logfile=/tmp/blog_stderr.log stdout_logfile=/tmp/blog_stdout.log #把stderr重定向到stdout，默认 falseredirect_stderr = true#stdout日志文件大小，默认 50MBstdout_logfile_maxbytes = 20MB#stdout日志文件备份数stdout_logfile_backups = 20 1234567supervisorctl status //查看所有进程的状态supervisorctl stop es //停止essupervisorctl start es //启动essupervisorctl restart //重启essupervisorctl update //配置文件修改后使用该命令加载新的配置supervisorctl reload //重新启动配置中的所有程序 个人样例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# supervisor主配置文件$ cat /etc/supervisord.conf...[include]files = supervisord.d/*.inifiles = /root/sh_file/supervisord.d/*.ini$ ls /root/sh_file/supervisord.d/tkserver.ini# twikoo服务 配置$ cat /root/sh_file/supervisord.d/tkserver.ini#项目名[program:tkserver]#脚本目录directory=/root/sh_file/twikoo#脚本执行命令command=/bin/bash /root/sh_file/twikoo/tkserver.sh#supervisor启动的时候是否随着同时启动，默认Trueautostart=true#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定 义的autorestart=false#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1startsecs=1#脚本运行的用户身份user = root#日志输出stderr_logfile=/tmp/blog_stderr.logstdout_logfile=/tmp/blog_stdout.log#把stderr重定向到stdout，默认 falseredirect_stderr = true#stdout日志文件大小，默认 50MBstdout_logfile_maxbytes = 20MB#stdout日志文件备份数stdout_logfile_backups = 20# 运行twikoo的脚本$ cat /root/sh_file/twikoo/tkserver.sh#!/bin/bashtkserver# 启动supervisord$ supervisord -c /etc/supervisord.conf$ supervisorctl status 12345678910111213141516171819# 相关命令# 安装 supervisoryum install epel-release #安装yum源yum install -y supervisor# 启动 supervisor$ supervisord -c /etc/supervisord.conf# supervisor 命令supervisorctl status # 查看所有进程的状态supervisorctl stop tkserver # 停止tkserversupervisorctl start tkserver # 启动tkserversupervisorctl restart tkserver # 重启tkserversupervisorctl update # 配置文件修改后使用该命令加载新的配置supervisorctl reload # 重新启动配置中的所有程序# 注：把es换成all可以管理配置中的所有进程。直接输入supervisorctl进入supervisorctl的shell交互界面，此时上面的命令不带supervisorctl可直接使用。 2. Twikoo版本升级（私有部署） 更新 1.6.22 时间：2023-10-10，版本 1.6.22 &lt;= 1.6.7 参考：twikoo.js.org 1.6.22 支持评论/访问量数据 json 导出了 官网步骤： 停止旧版本 kill $(ps -ef | grep tkserver | grep -v 'grep' | awk '&#123;print $2&#125;') 拉取新版本 npm i -g tkserver@latest 启动新版本 nohup tkserver &gt;&gt; tkserver.log 2&gt;&amp;1 &amp; 我的步骤： 先备份，我的数据路径 /root/sh_file/twikoo，cp -r twikoo twikoo_bak 更新 123456789101112131415161718supervisorctl status tkserversupervisorctl stop tkserverps -ef | grep tkserver | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;# 1. 停止旧版本kill $(ps -ef | grep tkserver | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;)# 2. 拉取新版本npm i -g tkserver@latest# 3. 启动新版本# kill $(ps -ef | grep tkserver | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;)supervisorctl start tkserverrm -rf twikoo_bak # 删备份 更新 butterfly 前端资源，CDN.option.twikoo，www.staticfile.org 上查找 前言 乌龙事件，原本以为自己的 twikoo 版本过低，打算升级解决。后来发现是 butterfly 内置的 twikoo js 版本低，换个 js 就行。 主题配置文件 _config.butterfly.yml 新增 twikoo cdn 123CDN: option: twikoo: https://npm.elemecdn.com/twikoo@1.6.7/dist/twikoo.all.min.js 参考文章 参考自：twikoo 官网 停止旧版本 kill $(ps -ef | grep tkserver | grep -v 'grep' | awk '&#123;print $2&#125;') 拉取新版本 npm i -g tkserver@latest 启动新版本 nohup tkserver &gt;&gt; tkserver.log 2&gt;&amp;1 &amp; 个人样例 个人步骤记录 检查是否异常 12345678910# 发现 supervisor 未执行，启动程序$ supervisorctl status tkserverunix:///run/supervisor/supervisor.sock refused connection$ supervisord -c /etc/supervisord.confUnlinking stale socket /run/supervisor/supervisor.sock$ supervisorctl status tkservertkserver RUNNING pid 3268176, uptime 0:00:03 停止旧版本 supervisorctl stop tkserver &amp;&amp; kill $(ps -ef | grep tkserver | grep -v 'grep' | awk '&#123;print $2&#125;') 12345678910111213141516# 停止 twikoo 进程$ supervisorctl stop tkservertkserver: ERROR (not running)$ supervisorctl status tkservertkserver EXITED Nov 06 07:00 PM$ ps -ef | grep tkserver | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;16181961618197# 停止旧版本$ kill $(ps -ef | grep tkserver | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $2&#125;&#x27;)$ ps aux |grep twikoo 拉取新版本 npm i -g tkserver@latest 启动新版本 supervisorctl start tkserver 1234567891011121314# 拉取新版本$ pwd/root/sh_file/twikoo$ npm i -g tkserver@latest# 启动新版本$ supervisorctl start tkservertkserver: started$ ps aux |grep twikooroot 3308516 0.0 0.1 16956 2892 ? S 19:06 0:00 /bin/bash /root/sh_file/twikoo/tkserver.sh","categories":[{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/categories/Other/"}],"tags":[{"name":"Twikoo","slug":"Twikoo","permalink":"https://blog1.cpen.top/tags/Twikoo/"},{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/tags/Other/"},{"name":"Supervisor","slug":"Supervisor","permalink":"https://blog1.cpen.top/tags/Supervisor/"}]},{"title":"01_Error-Nginx 反代后端接口报错","slug":"Error/01_Error-Nginx反代后端接口报错","date":"2022-10-09T04:00:00.000Z","updated":"2022-10-09T05:00:00.000Z","comments":true,"path":"posts/5552.html","permalink":"https://blog1.cpen.top/posts/5552.html","excerpt":"","text":"一. 前言 NGINX 反向代理 后端接口时报错：[error] ...: *1918 readv() failed (104: Connection reset by peer) while reading upstream ... 控制台报错信息 NGINX错误日志 二. 解决办法 参考文章 http://blog.51yip.com/apachenginx/2203.html 查看nginx error错误，发现上传接口报以下错： 2019/10/10 19:58:25 [error] 299784#0: \\*5967188 readv() failed (104: Connection reset by peer) while reading upstream, client: 59.34.155.7, server: xxxxxxxx, request: &quot;POST /stream/tracking/file HTTP/1.1&quot;, upstream: &quot;http://xxxxxxxx/stream/tracking/file&quot;, host: &quot;xxxxxxxx&quot; 这种错误日志不多，第一感觉就是上传文件过大，传输时间过长，然后连接被中断。 当使用nginx作为反向代理时，为了支持长连接，需要做到两点： 从client到nginx的连接是长连接，对于客户端来说，nginx长连接是默认开启的。 从nginx到server的连接是长连接，需要自己开启 12345678910111213141516upstream bigdata &#123; server 10.0.20.xx:18018; server 10.0.20.xx:18018; server 10.0.20.xx:18018; server 10.0.20.xx:18018; keepalive 100; //根据qps来调整 &#125; location ~ / &#123; 。。。。。。。。。省略。。。。。。。。。。。。。 proxy_connect_timeout 120; //加大120 proxy_send_timeout 120; //加大120 proxy_read_timeout 120; //加大120 proxy_http_version 1.1; //开启后端，长连接 proxy_set_header Connection &quot;&quot;; //开启后端，长连接 &#125; 注意：keepalive指定的数值是Nginx每个worker连接后端的最大长连接数，而不是整个Nginx的. 作者:海底苍鹰 地址:http://blog.51yip.com/apachenginx/2203.html 三. 个人配置记录 12345678910111213141516171819202122232425$ cat cpen.top.confserver &#123; listen xxx ssl; server_name xxx.xxx; location / &#123; proxy_pass http://127.0.0.1:xxx; proxy_connect_timeout 120; # 加大120 proxy_send_timeout 120; # 加大120 proxy_read_timeout 120; # 加大120 proxy_http_version 1.1; # 开启后端，长连接 proxy_set_header Connection &quot;&quot;; # 开启后端，长连接 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Upgrade $http_upgrade; &#125; ssl_certificate /usr/local/nginx/ssl/xxx.pem; ssl_certificate_key /usr/local/nginx/ssl/xxx.key; access_log /data/service_logs/nginx/xxx.log misc; error_log /data/service_logs/nginx/xxx.log;&#125;","categories":[{"name":"Error","slug":"Error","permalink":"https://blog1.cpen.top/categories/Error/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://blog1.cpen.top/tags/Error/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog1.cpen.top/tags/Nginx/"},{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://blog1.cpen.top/tags/Troubleshooting/"}]},{"title":"01_PHP-CentOS8.2 编译安装 PHP8.1.10","slug":"PHP/01_PHP-CentOS编译安装PHP8","date":"2022-10-08T04:00:00.000Z","updated":"2022-10-08T05:00:00.000Z","comments":true,"path":"posts/63259.html","permalink":"https://blog1.cpen.top/posts/63259.html","excerpt":"","text":"一. 前言 因 https://www.jsdelivr.com/ 失效，博主打算将 GitHub 托管的图床备份到其他平台。 网上看到 兰空图床 萌生了自建图床的念头，搭建环境要求 PHP &gt;= 8.0.2，于是打算编译安装 PHP。 最终因服务器配置太低（1核2G）编译失败而放弃。转而投身之前已经搭建好环境的又拍云平台。 博文内容：PHP-CentOS8.2 编译安装 PHP8.1.10 + 编写GitHub图床迁移至又拍云的脚本（ftp） + 编写批量修改文章内容的脚本 二. 正文 2.1❤ CentOS8.2 编译安装 PHP8.1.10 2.1.1 PHP8 和 oniguruma 源码下载并上传至服务器 /mnt 目录 https://www.php.net/distributions/php-8.1.10.tar.gz https://codeload.github.com/kkos/oniguruma/tar.gz/refs/tags/v6.9.4 123# 解压tar xzf oniguruma-6.9.4.tar.gztar xzf php-8.1.10.tar.gz 2.1.2 安装 PHP8 依赖包 12# 2 安装 PHP8 依赖包yum -y install autoconf freetype gd libpng libpng-devel libjpeg libxml2 libxml2-devel zlib curl curl-devel net-snmp-devel libjpeg-devel php-ldap openldap-devel openldap-clients freetype-devel gmp-devel libzip libzip-devel sqlite-devel automake libtool 2.1.3 编译 PHP8 依赖包 oniguruma 123456789# 3.1 生成 configurecd /mnt/oniguruma-6.9.4./autogen.sh# 3.2 生成编译配置文件./configure --prefix=/usr# 3.3 编译并安装make &amp;&amp; make install 2.1.4 编译 PHP8 主包 123456# 4.1 生成编译配置文件cd /mnt/php-8.1.10./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --enable-fpm --with-fpm-user=nginx --with-fpm-group=nginx --enable-mysqlnd --with-mysqli --with-pdo-mysql --enable-opcache --with-pcre-jit --enable-gd --with-jpeg --with-freetype --with-gettext --with-curl --with-openssl --enable-sockets --enable-mbstring --enable-xml --with-zip --with-zlib --with-snmp --with-mhash --enable-ftp --enable-bcmath --enable-soap --enable-shmop --enable-sysvsem --enable-pcntl --with-gmp# 4.2 编译并安装make &amp;&amp; make install 因为配置过低，编译失败。 2.1.5 编译安装后目录 /usr/local/php 参考 https://www.bilibili.com/read/cv9248283/ https://www.bilibili.com/video/BV13U4y1T7VS 2.2 基于 FTP 将GitHub图床迁移至又拍云 参考 官方视频教程 - 创建存储服务和使用 FTP 上传 可以得到用户名和密码 默认已经完成了又拍云云存储服务的申请 + 绑定自定义域名 https://help.upyun.com/knowledge-base/quick_start/ 2.2.1 编写 Python 脚本 实现批量 源码来自 http://blog.csdn.net/ouyang_peng/article/details/79271113 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#!/usr/bin/python# -*- coding: UTF-8 -*-from cmath import logfrom ftplib import FTPimport osimport sysimport timeimport socketimport subprocessclass MyFTP: &quot;&quot;&quot; ftp自动下载、自动上传脚本，可以递归目录操作 作者：欧阳鹏 博客地址：http://blog.csdn.net/ouyang_peng/article/details/79271113 &quot;&quot;&quot; def __init__(self, host, port=21): &quot;&quot;&quot; 初始化 FTP 客户端 参数: host:ip地址 port:端口号 &quot;&quot;&quot; # print(&quot;__init__()---&gt; host = %s ,port = %s&quot; % (host, port)) self.host = host self.port = port self.ftp = FTP() # 重新设置下编码方式 #self.ftp.encoding = &#x27;gbk&#x27; self.ftp.encoding = &#x27;utf8&#x27; # 获取脚本路径 path = os.path.dirname(os.path.realpath(__file__)) self.log_file = open(path + &quot;/log.txt&quot;, &quot;a&quot;, encoding=&#x27;utf-8&#x27;) self.file_list = [] def login(self, username, password): &quot;&quot;&quot; 初始化 FTP 客户端 参数: username: 用户名 password: 密码 &quot;&quot;&quot; try: timeout = 60 socket.setdefaulttimeout(timeout) # 0主动模式 1 #被动模式 self.ftp.set_pasv(True) # 打开调试级别2，显示详细信息 # self.ftp.set_debuglevel(2) self.debug_print(&#x27;开始尝试连接到 %s&#x27; % self.host) self.ftp.connect(self.host, self.port) self.debug_print(&#x27;成功连接到 %s&#x27; % self.host) self.debug_print(&#x27;开始尝试登录到 %s&#x27; % self.host) self.ftp.login(username, password) self.debug_print(&#x27;成功登录到 %s&#x27; % self.host) self.debug_print(self.ftp.welcome) except Exception as err: self.deal_error(&quot;FTP 连接或登录失败 ，错误描述为：%s&quot; % err) pass def is_same_size(self, local_file, remote_file): &quot;&quot;&quot;判断远程文件和本地文件大小是否一致 参数: local_file: 本地文件 remote_file: 远程文件 &quot;&quot;&quot; try: remote_file_size = self.ftp.size(remote_file) except Exception as err: # self.debug_print(&quot;is_same_size() 错误描述为：%s&quot; % err) remote_file_size = -1 try: local_file_size = os.path.getsize(local_file) except Exception as err: # self.debug_print(&quot;is_same_size() 错误描述为：%s&quot; % err) local_file_size = -1 self.debug_print(&#x27;local_file_size:%d , remote_file_size:%d&#x27; % (local_file_size, remote_file_size)) if remote_file_size == local_file_size: return 1 else: return 0 def download_file(self, local_file, remote_file): &quot;&quot;&quot;从ftp下载文件 参数: local_file: 本地文件 remote_file: 远程文件 &quot;&quot;&quot; self.debug_print(&quot;download_file()---&gt; local_path = %s ,remote_path = %s&quot; % (local_file, remote_file)) if self.is_same_size(local_file, remote_file): self.debug_print(&#x27;%s 文件大小相同，无需下载&#x27; % local_file) return else: try: self.debug_print(&#x27;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;下载文件 %s ... ...&#x27; % local_file) buf_size = 1024 file_handler = open(local_file, &#x27;wb&#x27;) self.ftp.retrbinary(&#x27;RETR %s&#x27; % remote_file, file_handler.write, buf_size) file_handler.close() except Exception as err: self.debug_print(&#x27;下载文件出错，出现异常：%s &#x27; % err) return def download_file_tree(self, local_path, remote_path): &quot;&quot;&quot;从远程目录下载多个文件到本地目录 参数: local_path: 本地路径 remote_path: 远程路径 &quot;&quot;&quot; print(&quot;download_file_tree()---&gt; local_path = %s ,remote_path = %s&quot; % (local_path, remote_path)) try: self.ftp.cwd(remote_path) except Exception as err: self.debug_print(&#x27;远程目录%s不存在，继续...&#x27; % remote_path + &quot; ,具体错误描述为：%s&quot; % err) return if not os.path.isdir(local_path): self.debug_print(&#x27;本地目录%s不存在，先创建本地目录&#x27; % local_path) os.makedirs(local_path) self.debug_print(&#x27;切换至目录: %s&#x27; % self.ftp.pwd()) self.file_list = [] # 方法回调 self.ftp.dir(self.get_file_list) remote_names = self.file_list self.debug_print(&#x27;远程目录 列表: %s&#x27; % remote_names) for item in remote_names: file_type = item[0] file_name = item[1] local = os.path.join(local_path, file_name) if file_type == &#x27;d&#x27;: print(&quot;download_file_tree()---&gt; 下载目录： %s&quot; % file_name) self.download_file_tree(local, file_name) elif file_type == &#x27;-&#x27;: print(&quot;download_file()---&gt; 下载文件： %s&quot; % file_name) self.download_file(local, file_name) self.ftp.cwd(&quot;..&quot;) self.debug_print(&#x27;返回上层目录 %s&#x27; % self.ftp.pwd()) return True def upload_file(self, local_file, remote_file): &quot;&quot;&quot;从本地上传文件到ftp 参数: local_path: 本地文件 remote_path: 远程文件 &quot;&quot;&quot; if not os.path.isfile(local_file): self.debug_print(&#x27;%s 不存在&#x27; % local_file) return if self.is_same_size(local_file, remote_file): self.debug_print(&#x27;跳过相等的文件: %s&#x27; % local_file) return buf_size = 1024 file_handler = open(local_file, &#x27;rb&#x27;) self.ftp.storbinary(&#x27;STOR %s&#x27; % remote_file, file_handler, buf_size) file_handler.close() self.debug_print(&#x27;上传: %s&#x27; % local_file + &quot;成功!&quot;) def upload_file_tree(self, local_path, remote_path): &quot;&quot;&quot;从本地上传目录下多个文件到ftp 参数: local_path: 本地路径 remote_path: 远程路径 &quot;&quot;&quot; if not os.path.isdir(local_path): self.debug_print(&#x27;本地目录 %s 不存在&#x27; % local_path) return self.ftp.cwd(remote_path) self.debug_print(&#x27;切换至远程目录: %s&#x27; % self.ftp.pwd()) local_name_list = os.listdir(local_path) for local_name in local_name_list: src = os.path.join(local_path, local_name) if os.path.isdir(src): try: self.ftp.mkd(local_name) except Exception as err: self.debug_print(&quot;目录已存在 %s ,具体错误描述为：%s&quot; % (local_name, err)) self.debug_print(&quot;upload_file_tree()---&gt; 上传目录： %s&quot; % local_name) self.upload_file_tree(src, local_name) else: self.debug_print(&quot;upload_file_tree()---&gt; 上传文件： %s&quot; % local_name) self.upload_file(src, local_name) self.ftp.cwd(&quot;..&quot;) def close(self): &quot;&quot;&quot; 退出ftp &quot;&quot;&quot; self.debug_print(&quot;close()---&gt; FTP退出&quot;) self.ftp.quit() self.log_file.close() def debug_print(self, s): &quot;&quot;&quot; 打印日志 &quot;&quot;&quot; self.write_log(s) def deal_error(self, e): &quot;&quot;&quot; 处理错误异常 参数： e：异常 &quot;&quot;&quot; log_str = &#x27;发生错误: %s&#x27; % e self.write_log(log_str) sys.exit() def write_log(self, log_str): &quot;&quot;&quot; 记录日志 参数： log_str：日志 &quot;&quot;&quot; time_now = time.localtime() date_now = time.strftime(&#x27;%Y-%m-%d&#x27;, time_now) format_log_str = &quot;%s ---&gt; %s \\n &quot; % (date_now, log_str) print(format_log_str) self.log_file.write(format_log_str) def get_file_list(self, line): &quot;&quot;&quot; 获取文件列表 参数： line： &quot;&quot;&quot; file_arr = self.get_file_name(line) # 去除 . 和 .. if file_arr[1] not in [&#x27;.&#x27;, &#x27;..&#x27;]: self.file_list.append(file_arr) def get_file_name(self, line): &quot;&quot;&quot; 获取文件名 参数： line： &quot;&quot;&quot; pos = line.rfind(&#x27;:&#x27;) while (line[pos] != &#x27; &#x27;): pos += 1 while (line[pos] == &#x27; &#x27;): pos += 1 file_arr = [line[0], line[pos:]] return file_arrif __name__ == &quot;__main__&quot;: # 清除日志 path = os.path.dirname(os.path.realpath(__file__)) # 脚本路径 if os.path.exists(path + &#x27;/log.txt&#x27;): log_file = path + &#x27;/log.txt &#x27;if os.sep == &quot;/&quot; else path + &#x27;\\\\&#x27; + &#x27;log.txt&#x27; subprocess.Popen(f&#x27;rm -rf &#123;log_file&#125;&#x27;, shell=True) time.sleep(1) my_ftp = MyFTP(&quot;xxx.ftp.upyun.com&quot;) my_ftp.login(&quot;xxx/xxx&quot;, &quot;xxx&quot;) # 下载单个文件 # my_ftp.download_file(&quot;E:/code_zone/image_bed/image/wallpaper/1.jpg&quot;, &quot;/image/wallpaper/1.jpg&quot;) # 上传单个文件 # my_ftp.upload_file(&quot;G:/ftp_test/Release/XTCLauncher.apk&quot;, &quot;/App/AutoUpload/ouyangpeng/I12/Release/XTCLauncher.apk&quot;) # 下载目录 # image.cpen.top/image/ → 本地 E:/code_zone/image_bed/image/ (本地图床目录, 又拍云路径) if os.sep == &quot;\\\\&quot;: my_ftp.download_file_tree(&quot;E:/code_zone/image_bed/image/&quot;, &quot;/image/&quot;) elif os.sep == &quot;/&quot;: # aliyun my_ftp.download_file_tree(&quot;/root/code_zone/image_bed/image/&quot;, &quot;/image/&quot;) # 上传目录 # 本地 E:/code_zone/image_bed/image/ → image.cpen.top/image/ (本地图床目录, 又拍云路径) if os.sep == &quot;\\\\&quot;: # Windows my_ftp.upload_file_tree(&quot;E:/code_zone/image_bed/image/&quot;, &quot;/image/&quot;) my_ftp.close() elif os.sep == &quot;/&quot;: # aliyun my_ftp.upload_file_tree(&quot;/root/code_zone/image_bed/image/&quot;, &quot;/image/&quot;) my_ftp.close()# 命令# python E:/code_zone/tools/python-ftp/ftp.py# python3 /root/code_zone/tools/python-ftp/ftp.py 2.2.2 说明 my_ftp.login(&quot;用户名xxx/xxx&quot;, &quot;密码xxx&quot;) 参考 https://techs.upyun.com/videos/cdnpage/creating_storage.html 后期又将脚本传到云服务器上，通过计划任务，每15分钟同步，保持 GitHub 与又拍云图床一致 123# root @ CentOS in ~ [18:05:59]$ crontab -l*/15 * * * * cd /root/code_zone/image_bed/; git pull; python3 /root/code_zone/tools/python-ftp/ftp.py; bash git.sh 迁移好图床后，博客中调用图片资源时 浏览器自动 http 跳 https，因为没有证书导致图片失效，于是又申请了 ssl 证书，上传至又拍云。 2.3 编写批量修改文章内容的脚本 源码参考 https://blog.csdn.net/qq_38150250/article/details/118026219 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/python# -*- coding: UTF-8 -*-# 源码参考 https://blog.csdn.net/qq_38150250/article/details/118026219import osimport re# 文件查找 find . -name file_name -type f# 查找函数：search_path 查找根路径 # 获取文章路径def search(search_path, search_result): # 获取当前路径下地所有文件 all_file = os.listdir(search_path) # 对于每一个文件 for each_file in all_file: # 若文件为一个文件夹 if os.path.isdir(search_path + each_file): # 递归查找 search(search_path + each_file + &#x27;/&#x27;, search_result) # 如果是需要被查找的文件 else: if re.findall(&#x27;.*\\.md$&#x27;, each_file) == [each_file]: # 输出路径 search_result.append(search_path + each_file)# 替换 sed -i &#x27;s/old_str/new_str/&#x27;# 文本替换 replace_file_name 需要替换的文件路径，replace_old_str 要替换的字符，replace_new_str 替换的字符def replace(replace_file_name, replace_old_str, replace_new_str): with open(replace_file_name, &quot;r&quot;, encoding = &quot;UTF-8&quot;) as f1: content = f1.read() f1.close() t = content.replace(replace_old_str, replace_new_str) with open(replace_file_name, &quot;w&quot;, encoding = &quot;UTF-8&quot;) as f2: f2.write(t) f2.close()# 需要改的地方#path = &#x27;E:/code_zone/.history/20220831_blog/source/_posts/&#x27;path_list = [ &#x27;E:/code_zone/hexo-source/source/_posts/&#x27;, &#x27;E:/code_zone/hexo-source-butterfly/source/_posts/&#x27;, &#x27;E:/code_zone/hexo-source-diary/source/_posts/&#x27;,]old_str = &#x27;https://cdn.iocdn.cc/npm/mycpen-image-bed@0.0.0-elcfumuvhm/image/&#x27;new_str = &#x27;https://cdn.iocdn.cc/npm/mycpen-image-bed@0.0.0-elcfumuvhm/image/&#x27;search_result = []if __name__ == &#x27;__main__&#x27;: result = [] # 存放文件路径 # 默认当前目录 # path = os.getcwd() for path in path_list: search(path, result) # 获取文章路径 count = 0 for file_name in result: replace(file_name, old_str, new_str) count += 1 print(&quot;&#123;&#125; done &#123;&#125;&quot;.format(file_name, count))# 命令# python E:/code_zone/tools/python-replace/replace.py 2.3.1 说明 search 函数指定文件类型为 .md，可获得文章的完整路径； path_list 列表存放需要修改的文章父目录路径，可以递归查询子目录； old_str 需要替换的内容 new_str 新内容","categories":[{"name":"PHP","slug":"PHP","permalink":"https://blog1.cpen.top/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog1.cpen.top/tags/PHP/"},{"name":"脚本","slug":"脚本","permalink":"https://blog1.cpen.top/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"10_Python-CSDN_内存管理","slug":"Python_csdn/10_Python_内存管理","date":"2022-10-07T04:00:00.000Z","updated":"2022-10-07T05:00:00.000Z","comments":true,"path":"posts/62975.html","permalink":"https://blog1.cpen.top/posts/62975.html","excerpt":"","text":"12345Python内存管理三大块○ 引用计数○ 垃圾回收○ 内存池Python的内存管理以引用计数为主，垃圾回收为辅，还有个内存池 一. 引用机制 ● 引用机制 Python动态类型 ○ 对象是储存在内存中的实体。 ○ 我们在程序中写的对象名，只是指向这一对象的引用(reference) ○ 引用和对象分离，是动态类型的核心 ○ 引用可以随时指向一个新的对象（内存地址会不一样） 二. 引用计数 ● 引用计数 在Python中，每个对象都有存有指向该对象的引用总数，即引用计数(reference count) 引用计数器原理 ○ 每个对象维护一个 ob_ref 字段，用来记录该对象当前被引用的次数 每当新的引用指向该对象时，它的引用计数ob_ref加1 ○ 每当该对象的引用失效时计数ob_ref减1 ○ 一旦对象的引用计数为0，该对象可以被回收，对象占用的内存空间将被释放。 它的缺点是需要额外的空间维护引用计数，这个问题是其次的 ○ 最主要的问题是它不能解决对象的“循环引用” 123# 示例# a = 1 , b = 1 ，1的引用计数为2（保存它被引用的次数）# a = 2 , b = 3 , 1的引用计数为0（内存里面不需要它了，回收销毁，这块对象被回收了，对象占用的内存空间将被释放） 12345678获取引用计数: getrefcount()○ 当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1# 示例from sys import getrefcount # 导入模块a = [1,2,3]print(getrefcount(a)) # 获取对象a的引用计数 ， 结果为2 12345678910111213141516增加引用计数○ 当一个对象A被另一个对象B引用时，A的引用计数将增加1减少引用计数○ del删除或重新引用时，引用计数会变化（del只是删除引用）# 示例from sys import getrefcounta = [1,2,3] # 真实引用计数：1b = a # 真实引用计数：2c = [a,a] # 真实引用计数：4del c[0] # del删除引用 引用计数 - 1 ； 真实引用计数: 3print(c) # c 是列表对象 输出为 [[1, 2, 3]]print(getrefcount(a)) # 引用计数为4，真实引用计数为3 1234567891011121314151617181920212223242526272829303132333435363738394041循环引用的情况x = []y = []x.append(y) y.append(x)○ 对于上面相互引用的情况,如果不存在其他对象对他们的引用,这两个对象所占用的内存也还是无法回收,从而导致内存泄漏# 示例1&gt;&gt;&gt; x = [1]&gt;&gt;&gt; y = [2]&gt;&gt;&gt; x.append(y)&gt;&gt;&gt; x[1, [2]]&gt;&gt;&gt; y.append(x)&gt;&gt;&gt; y[2, [1, [...]]] # 注：发生死循环# 示例2&gt;&gt;&gt; from sys import getrefcount&gt;&gt;&gt; x = [&quot;x&quot;]&gt;&gt;&gt; y = [&quot;y&quot;]&gt;&gt;&gt; getrefcount(x)2&gt;&gt;&gt; getrefcount(y)2&gt;&gt;&gt; x.append(y)&gt;&gt;&gt; getrefcount(x)2&gt;&gt;&gt; getrefcount(y)3&gt;&gt;&gt; y.append(x)&gt;&gt;&gt; getrefcount(x)3&gt;&gt;&gt; x[&#x27;x&#x27;, [&#x27;y&#x27;, [...]]]&gt;&gt;&gt; y[&#x27;y&#x27;, [&#x27;x&#x27;, [...]]]&gt;&gt;&gt; del x &gt;&gt;&gt; y[&#x27;y&#x27;, [&#x27;x&#x27;, [...]]]&gt;&gt;&gt; del y # del x;del y引用删除，这块内存区域获取不到了 123引用计数机制的优点：○ 简单○ 实时性 123引用计数机制的缺点：○ 维护引用计数消耗资源○ 循环引用时，无法回收 三. 垃圾回收 ● 垃圾回收 回收原则 ○ 当Python的某个对象的引用计数降为0时，可以被垃圾回收 gc机制 ○ GC作为现代编程语言的自动内存管理机制，专注于两件事 ○ 找到内存中无用的垃圾资源 ○ 清除这些垃圾并把内存让出来给其他对象使用 GC彻底把程序员从资源管理的重担中解放出来，让他们有更多的时间放在业务逻辑上。但这并不意味着码农就可以不去了解GC，毕竟多了解GC知识还是有利于我们写出更健壮的代码 效率问题 ○ 垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率 ○ 当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动 1234567891011121314151617# 示例&gt;&gt;&gt; import gc&gt;&gt;&gt; print(gc.get_threshold())(700, 10, 10) # 注：默认值# 示例&gt;&gt;&gt; del x&gt;&gt;&gt; del y&gt;&gt;&gt; gc.collect()2 # 删除了2个循环引用&gt;&gt;&gt; a = &quot;x1 xx&quot;&gt;&gt;&gt; b = &quot;x1 xx&quot;&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; gc.collect()0 1234三种情况触发垃圾回收○ 调用gc.collect()○ GC达到阀值时○ 程序退出时 12345678分代(generation)回收 这一策略的基本假设是：存活时间越久的对象，越不可能在后面的程序中变成垃圾○ Python将所有的对象分为0，1，2三代○ 所有的新建对象都是0代对象○ 当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象 ○ 垃圾回收启动时，一定会扫描所有的0代对象 ○ 如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理 ○ 当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描 标记清除 ​ 标记-清除机制，顾名思义，首先标记对象（垃圾检测），然后清除垃圾（垃圾回收）。 ​ 主要用于解决循环引用。 ○ 1.标记：活动（有被引用）, 非活动（可被删除） ○ 2.清除：清除所有非活动的对象 四. 缓冲池 ● 缓冲池 整数对象缓冲池 ○ 对于==[-5,256]== 这样的小整数，系统已经初始化好，可以直接拿来用。而对于其他的大整数，系统则提前申请了一块内存空间，等需要的时候在这上面创建大整数对象 123456789101112131415161718192021# 示例：小整数而言 id都是一样的&gt;&gt;&gt; a = 777 # a和b不是一样的&gt;&gt;&gt; b = 777&gt;&gt;&gt; id(a) # 内存地址不同140133545530064&gt;&gt;&gt; id(b) # 内存地址不同140133545530384&gt;&gt;&gt; a = b = 777&gt;&gt;&gt; id(a)140133545530480&gt;&gt;&gt; id(b)140133545530480&gt;&gt;&gt; a = 1 # a和b是一样的&gt;&gt;&gt; b = 1 # python的整数对象缓冲池&gt;&gt;&gt; id(a)140133544871840 # 内存地址一样&gt;&gt;&gt; id(b)140133544871840 # 内存地址一样&gt;&gt;&gt; from sys import getrefcount&gt;&gt;&gt; getrefcount(a)801 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657字符串缓存○ 为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指的对象是否相同。当触发缓存机制时，只是创造了新的引用，而不是对象本身# 示例&gt;&gt;&gt; a = &quot;xxx&quot;&gt;&gt;&gt; b = &quot;xxx&quot;&gt;&gt;&gt; id(a)140133545760616&gt;&gt;&gt; id(b)140133545760616&gt;&gt;&gt; a = &quot;xxx &quot; # 注：特殊字符不能放到缓冲区&gt;&gt;&gt; b = &quot;xxx &quot;&gt;&gt;&gt; id(a)140133545760672 # 内存地址不一样&gt;&gt;&gt; id(b)140133545760728&gt;&gt;&gt; a = &quot;xxx_&quot; # 注：数字、字母、下划线的组合 放在字符串缓冲区&gt;&gt;&gt; b = &quot;xxx_&quot;&gt;&gt;&gt; id(a)140133545760616 # 内存地址一样&gt;&gt;&gt; id(b)140133545760616&gt;&gt;&gt; a = &quot;hello world&quot;&gt;&gt;&gt; b = &quot;hello world&quot;&gt;&gt;&gt; id(a) # 内存地址不一样140133545242928&gt;&gt;&gt; id(b)140133545242992&gt;&gt;&gt; a = &quot;helloworld&quot; &gt;&gt;&gt; b = &quot;helloworld&quot;&gt;&gt;&gt; id(a) # 内存地址一样140133545243120&gt;&gt;&gt; id(b)140133545243120&gt;&gt;&gt; a = &quot;你好&quot;&gt;&gt;&gt; b = &quot;你好&quot;&gt;&gt;&gt; id(a)140612691332856&gt;&gt;&gt; id(b)140612688894592# 示例：对于乘法创建的字符 只会缓冲20个&gt;&gt;&gt; a = &quot;x&quot;*21&gt;&gt;&gt; b = &quot;x&quot;*21&gt;&gt;&gt; id(a) # 内存地址不一样140133545742176&gt;&gt;&gt; id(b)140133545742248&gt;&gt;&gt; a = &quot;x&quot;*20 # 内存地址一样&gt;&gt;&gt; b = &quot;x&quot;*20&gt;&gt;&gt; id(a)140133545246768&gt;&gt;&gt; id(b)140133545246768 注意 ○ 这对于经常使用的数字和字符串来说也是一种优化的方案 字符串的intern机制 ○ python对于短小的，只含有字母数字的字符串自动触发缓存机制。其他情况不会缓存 五. 深拷贝与浅拷贝 ● 深拷贝与浅拷贝 浅拷贝 ○ 拷贝第一层数据（地址） 12345678910111213141516171819202122232425# 示例&gt;&gt;&gt; a = &#123;&quot;first&quot;:[1,2,3]&#125;&gt;&gt;&gt; b = a.copy() # 拷贝第一层数据（地址）&gt;&gt;&gt; a&#123;&#x27;first&#x27;: [1, 2, 3]&#125;&gt;&gt;&gt; b&#123;&#x27;first&#x27;: [1, 2, 3]&#125;&gt;&gt;&gt; id(a) # a、b引用变了140133410603584&gt;&gt;&gt; id(b)140133545741768&gt;&gt;&gt; a[&quot;second&quot;] = &quot;No.2&quot;&gt;&gt;&gt; a&#123;&#x27;first&#x27;: [1, 2, 3], &#x27;second&#x27;: &#x27;No.2&#x27;&#125;&gt;&gt;&gt; b&#123;&#x27;first&#x27;: [1, 2, 3]&#125;&gt;&gt;&gt; a[&quot;first&quot;].append(4) # a、b里面的”first”引用 没有改变&gt;&gt;&gt; a # 拷贝第一层数据（地址）&#123;&#x27;first&#x27;: [1, 2, 3, 4], &#x27;second&#x27;: &#x27;No.2&#x27;&#125;&gt;&gt;&gt; b&#123;&#x27;first&#x27;: [1, 2, 3, 4]&#125;&gt;&gt;&gt; id(a[&quot;first&quot;]) # 第一层数据（地址） 内存地址相同140133413100296&gt;&gt;&gt; id(b[&quot;first&quot;])140133413100296 深拷贝 ○ 递归拷贝所有层的数据 1234567891011121314# 示例&gt;&gt;&gt; a = &#123;&quot;first&quot;:[1,2,3]&#125;&gt;&gt;&gt; import copy # 导入模块&gt;&gt;&gt; b = copy.deepcopy(a)&gt;&gt;&gt; id(a) # 内存地址不同140133545248160&gt;&gt;&gt; id(b)140133410604736&gt;&gt;&gt; a[&quot;second&quot;] = &quot;No.2&quot;&gt;&gt;&gt; a[&quot;first&quot;].append(4)&gt;&gt;&gt; a&#123;&#x27;first&#x27;: [1, 2, 3, 4], &#x27;second&#x27;: &#x27;No.2&#x27;&#125; # 递归拷贝所有层的数据&gt;&gt;&gt; b&#123;&#x27;first&#x27;: [1, 2, 3]&#125; # 递归拷贝所有层的数据 小结 ○ 数字和字符串、元组，不能改变对象本身，只能改变引用的指向，称为不可变数据对象(immutable object) ○ 列表、字典、集合可以通过引用其元素，改变对象自身(in-place change)。这种对象类型，称为可变数据对象(mutable object) 12345678910111213# 示例&gt;&gt;&gt; a=[1,2,3]&gt;&gt;&gt; b=[1,2,[4,5]] # 可变数据对象，有影响&gt;&gt;&gt; c = b[:]&gt;&gt;&gt; c[1, 2, [4, 5]]&gt;&gt;&gt; b[2].append(7)&gt;&gt;&gt; b[1, 2, [4, 5, 7]]&gt;&gt;&gt; c[1, 2, [4, 5, 7]]&gt;&gt;&gt; b=[1,2,3] # 不可变数据对象，没有影响&gt;&gt;&gt; c = b[:]","categories":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"内存管理","slug":"内存管理","permalink":"https://blog1.cpen.top/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"09_Python-CSDN_上下文管理器","slug":"Python_csdn/09_Python_上下文管理器","date":"2022-10-06T04:00:00.000Z","updated":"2022-10-06T05:00:00.000Z","comments":true,"path":"posts/9186.html","permalink":"https://blog1.cpen.top/posts/9186.html","excerpt":"","text":"一. 介绍 ● 介绍 上下文管理器是装饰器的近亲，与装饰器类似的，它们都是包装其他代码的工具 ○ 装饰器：包装用于定义的代码块 ○ 上下文管理器：可以包装任意格式的代码块 上下文管理器是一个包装任意代码块的对象，上下文管理器保证: ○ 进入上下文管理器时，每次代码执行的一致性 ○ 当退出上下文管理器时，相关的资源会被正确地回收（即使内部代码出错，退出步骤也执行） 上下文管理器的应用 ○ 上下文管理器被用到最多的就是——作为确保资源正确清理的一种方式 二. 语法 with语句 ○ python2.5中加入的关键字with ○ with语句仅仅能对支持上下文管理协议的对象使用。 ○ with语句的表达式的作用是返回一个遵循特定协议的对象，具体来说，该对象必须定义一个==__enter__方法和__exit__==方法 with语句执行的解析 ○ 语法：with context_expr as cm: do_sth() ○ 当with语句执行时，便执行上下文表达式（context_expr）来获得一个上下文管理器对象，上下文管理器的职责是提供一个上下文对象，用于在with语句块中处理细节： ​ ○ 一旦获得了上下文对象，就会调用它的__enter__()方法 ​ ○ 将完成with语句块执行前的所有准备工作 ​ ○ 如果with语句后面跟了as语句，方法返回的结果会被赋值给as关键字后面的变量 ​ ○ 除了self参数，__enter__方法不接受任何其他参数。 ​ ○ __enter__方法一般负责执行一些配置 1234567891011121314151617181920212223# 示例：上下文管理器 基本语法# 1、普通方法打开文件对象fp = open(&quot;test.txt&quot;,&quot;a+&quot;) # a+ 追加写print(dir(fp))#结果为 [ …&#x27;__enter__&#x27;, …, &#x27;__exit__&#x27;…]#注：有__enter__、__exit__方法，是上下文管理器fp.write(&quot;this is test&quot;)fp.close() #注：处理结束后，把它关掉，不然占资源# 2、用with语句执行with open(&quot;test.txt&quot;,&quot;a+&quot;) as f: #注：赋给f对象 f.write(&quot;write test&quot;) #退出语句执行之后 with自动回收对象 #因为打开的文件对象是上下文管理器 #注：open(&quot;test.txt&quot;,&quot;a+&quot;):上下文表达式with语句执行的解析○ 当with语句块结束时，无论是正常结束，还是由于异常，都会调用上下文对象的__exit__()方法 ○ __exit__()方法有3个参数 ○ 如果with语句正常结束，三个参数全部都是 None ○ 如果发生异常，三个参数的值分别等于调用sys.exc_info()函数返回的三个值：类型（异常类）、值（异常实例）和跟踪记录（traceback），相应的跟踪记录对象。 ○ 因为上下文管理器主要作用于共享资源，__enter__()和__exit__()方法基本是完成的是分配和释放资源的低层次工作，比如：数据库连接、锁分配、信号量加/减、状态管理、文件打开/关闭、异常处理等 三. 异常处理 ● 异常处理 上下文管理器必须定义__exit__方法，该方法可以选择性地处理包装代码块中出现的异常，或者处理其他需要关闭上下文状态的事情 __exit__方法接收了异常信息，就有处理这个异常的义务，通常可以做以下几件： ○ 传播异常 ○ 中止异常 ○ 抛出不同异常 123456789101112131415161718192021222324252627282930313233343536373839404142# 示例：__exit__#__exit__ 接受三个参数 异常类，异常值，回溯信息#上下文管理器 传播异常 终止异常class MyException(): def __enter__(self): return self def __exit__(self, exc_type, exc_val, exc_tb): if exc_val: #注：如果有异常发生 print(f&quot;My exception: &#123;exc_val&#125;&quot;) # return False #注：传播异常，给解释器识别 return True #注：中止异常with MyException():#使用上下文管理器 print(1+1) #注：没有异常，输出为2with MyException(): print(1/0) #注：False时 有异常#False时 结果为 My exception: division by zero#True时 结果为# My exception: division by zero #注：True时 不报错，程序不中断#注：True时 把异常传递出去，给解释器知道print(&quot;end......&quot;)#注：return False 不会执行 end......#注：return True 执行了 end......# 示例：如果是ValueError异常，终止异常；如果不是，传播异常class MyException(): def __enter__(self): return self def __exit__(self, exc_type, exc_val, exc_tb): if issubclass(exc_type, ValueError): #注：如果是ValueError异常及子类异常 # if exc_type == ValueError: #注：exc_type是类，所以判断条件ValueError类 return True #终止异常 return False #传播异常with MyException(): print(1+1) raise ValueError(&quot;test value error&quot;)#注：issubclass(exc_type, ValueError) 如果是ValueError异常及子类异常 四. contextlib模块 12345● contextlib模块contextlib模块介绍 ○ contextlib模块实现上下文自动管理 ○ 这个生成器可以用更简单的方法创建上下文管理器 1234567891011121314151617181920# 示例：contextlib实现上下文管理器import contextlib@contextlib.contextmanagerdef mycontext(): print(&quot;enter context&quot;) yield #注：生成器函数 print(&quot;exit context&quot;)c1 = mycontext()print(dir(c1))#结果为 […&#x27;__enter__&#x27;, &#x27;__exit__&#x27;…]#注：使用装饰器后 就是上下文管理器了。不使用装饰器，只是生成器对象with c1: print(&quot;xxxxxxxxxx&quot;)#结果为# enter context# xxxxxxxxxx# exit context","categories":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"上下文管理器","slug":"上下文管理器","permalink":"https://blog1.cpen.top/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"}]},{"title":"08_Python-CSDN_面向对象练习","slug":"Python_csdn/08_Python_面向对象练习","date":"2022-10-05T04:00:00.000Z","updated":"2022-10-05T05:00:00.000Z","comments":true,"path":"posts/13683.html","permalink":"https://blog1.cpen.top/posts/13683.html","excerpt":"","text":"菜鸟教程：面向对象 https://www.runoob.com/python3/python3-class.html 一. 回合制对战游戏 12345678● ①、回合制对战游戏 ○回合制对战游戏 ●创建角色：名字、性别、血量、装备 ●战斗 ●创建房间： ●装备-防弹衣 ●角色可加入房间 ●血量默认100 ●房间内的人可互打 ●正常被攻击-10滴血 ●房间上限2人 ●有防弹衣-5滴血 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990class Role(): def __init__(self,name,sex,blood=100,body_armor=None): self.name = name self.sex = sex self.blood = blood self.body_armor = body_armor self.room = None def attack(self,other): if self.room == other.room: # 注：同一房间 if self != other: # 注：不同的人 if self.blood &gt; 0 and other.blood &gt; 0: reduce_blood = 5 if other.body_armor else 10 # 注：body_armor为假 返回10(没有设置防弹衣) other.blood -= reduce_blood print(f&quot;&#123;self.name&#125;攻击&#123;other.name&#125; &#123;reduce_blood&#125;点血量\\t&#123;self.name&#125;当前血量：&#123;self.blood&#125;\\t&#123;other.name&#125;当前血量：&#123;other.blood&#125;&quot;) else: print(&quot;其中一方已死亡，不能攻击&quot;) exit() else: print(&quot;你不能攻击自己&quot;) else: print(&quot;攻击对象，不在同一个房间&quot;)class Room(): def __init__(self,name): self.member = [] self.name = name def join(self,role): if role.room == None: # 注：在角色的类里定义的属性room if len(self.member) &lt; 2: self.member.append(role) # 注：member房间的属性，房间只能加2个人 所以&lt;2 role.room = self.name # 注：达到条件，定义角色加入到 某个房间 else: print(&quot;此房间已满&quot;) else: print(&quot;此角色已经加入房间了&quot;)role_dict = &#123;&#125; # 存放初始化实例 # 注：存放名字和对象的关系room_dict = &#123;&#125; # 存放初始化实例while True: print(&quot;请选择：1.创建角色\\t2.创建房间\\t3.加入房间\\t4.开始战斗\\t5.退出&quot;) enter_number = input(&quot;请输入你的选择\\t&quot;) if enter_number.isdigit(): enter_number = int(enter_number) if 1 &lt;= enter_number &lt;=5: if enter_number == 1: name, sex = input(&quot;请输入角色的姓名与性别，空格隔开\\n&quot;).split() #注：split()是为了 分割 将字符 赋给2个变量 role_dict[name] = Role(name, sex) def_blood = input(&quot;输入自定义血量\\n&quot;) if def_blood.isdigit(): role_dict[name].blood = int(def_blood) print(f&quot;自定义成功，用户&#123;name&#125;当前血量&#123;role_dict[name].blood&#125;&quot;) else: print(f&quot;自定义失败，用户&#123;name&#125;当前血量&#123;role_dict[name].blood&#125;&quot;) wear_body_armor = input(&quot;输入y装备防弹衣\\n&quot;) if wear_body_armor == &quot;y&quot;: role_dict[name].body_armor = 1 elif enter_number == 2: name = input(&quot;请输入房间的名字\\n&quot;) room_dict[name] = Room(name) # 注：创建好的对象(实例化对象) 保存在字典里 elif enter_number == 3: print(f&quot;当前角色有&#123;role_dict.keys()&#125;，当前房间有&#123;room_dict.keys()&#125;&quot;) role_name, room_name = input(&quot;请输入要加入的角色和房间名，空格隔开\\n&quot;).split() # 注：这里可以做1个判断 (考虑到各种情况) room_dict[room_name].join(role_dict[role_name]) # 注：从字典 取出房间对象，调用房间对象的join()方法 elif enter_number == 4: print(f&quot;当前房间有&#123;room_dict.keys()&#125;&quot;) room_name = input(&quot;请输入房间的名字\\n&quot;) # 注：选择房间 if len(room_dict[room_name].member) == 2: # 注：len()==2 这是保证房间里有2个人 才能对打 while True: room_dict[room_name].member[0].attack(room_dict[room_name].member[1]) room_dict[room_name].member[1].attack(room_dict[room_name].member[0]) # 注：通过字典获取房间实例对象，member是房间的属性 # 注：为什么房间实例能获取到创建角色类的对象？因为选项3 是角色类属性 加入 房间member属性，保证了这一步能调用成功实例化对象 else: print(f&quot;房间&#123;room_name&#125;人数不足2人，对战失败！&quot;) continue elif enter_number == 5: print(&quot;退出对战&quot;) break else: print(&quot;输入错误，请输入1-5选择操作！&quot;) else: print(&quot;输入错误，请输入1-5选择操作！&quot;) 二. 模拟ATM 123456789101112● ②、模拟ATM○模拟ATM●1、创建ATM ○ATM里的总金额 ○ATM可向里面加钱 ○ATM里的钱取出来●2、创建账户去取钱 ○账户属性 名称、余额、密码 ○账户要选择1台ATM进行操作 ○可以取钱、存钱、查询余额 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149class Atm(): def __init__(self,name,atm_total): self.name = name self.atm_total = atm_total def add(self,money): self.atm_total += money print(f&quot;机器&#123;self.name&#125;增加金额&#123;money&#125;元，&#123;self.name&#125;当前总金额为&#123;self.atm_total&#125;元&quot;) def decrease(self,money): if self.atm_total &lt; money: print(f&quot;&#123;self.name&#125;余额不足，取钱失败&quot;) else: self.atm_total -= money print(f&quot;机器&#123;self.name&#125;取出金额&#123;money&#125;元，&#123;self.name&#125;当前总金额为&#123;self.atm_total&#125;元&quot;)class Account(): def __init__(self,name,balance,passwd): self.name = name self.balance = balance self.passwd = passwd def draw(self,atm,money): if money &lt;= self.balance: if money &lt;= atm.atm_total: self.balance -= money atm.atm_total -= money print(f&quot;成功取款&#123;money&#125;元，&#123;self.name&#125;当前余额为&#123;self.balance&#125;元&quot;) else: print(f&quot;ATM机 &#123;atm.name&#125;余额不足，取款失败！&quot;) else: print(&quot;您输入的金额大于您的账户余额，取款失败！&quot;) def save(self,atm,money): self.balance += money atm.atm_total += money print(f&quot;成功存款&#123;money&#125;元，&#123;self.name&#125;当前余额为&#123;self.balance&#125;元&quot;) def look(self): print(f&quot;&#123;self.name&#125;当前余额为&#123;self.balance&#125;元&quot;)# 管理员操作def atm_os(): # 管理员登录验证 name, paaswd = input(&quot;请输入管理员账号和密码，空格隔开\\n&quot;).split() if (name, paaswd) in admin_dict.items(): pass else: print(&quot;管理员账号出错&quot;) return while True: print(&quot;请选择：1.创建ATM\\t2.ATM加钱\\t3.ATM取钱\\t4.返回上一级&quot;) enter_number = input(&quot;请输入你的选择\\t&quot;) if enter_number.isdigit(): enter_number = int(enter_number) if 1 &lt;= enter_number &lt;= 4: # 1、创建ATM if enter_number == 1: name, atm_total = input(&quot;请输入ATM名称，总金额，空格隔开\\n&quot;).split() atm_total = int(atm_total) atm_dict[name] = Atm(name,atm_total) print(f&quot;创建ATM机 &#123;name&#125;成功，&#123;name&#125;当前总金额&#123;atm_total&#125;元&quot;) # 2、ATM加钱 elif enter_number == 2: print(f&quot;当前存在的ATM机器：&#123;atm_dict.keys()&#125;&quot;) atm_name = input(&quot;请输入ATM名称\\n&quot;) if atm_name in atm_dict.keys(): money = int(input(&quot;请输入金额\\n&quot;)) atm_dict[atm_name].add(money) else: print(f&quot;&#123;atm_name&#125;不存在&quot;) # 3、ATM取钱 elif enter_number == 3: print(f&quot;当前存在的ATM机器：&#123;atm_dict.keys()&#125;&quot;) atm_name = input(&quot;请输入ATM名称\\n&quot;) if atm_name in atm_dict.keys(): money = int(input(&quot;请输入金额\\n&quot;)) if money &gt; 0: atm_dict[atm_name].decrease(money) else: print(&quot;取出的金额不能为负&quot;) else: print(f&quot;&#123;atm_name&#125;不存在&quot;) elif enter_number == 4: print(&quot;退出ATM操作&quot;) break else: print(&quot;输入错误，请输入1-4选择操作&quot;)# 账户操作def account_os(): while True: print(&quot;请选择：1.创建账户\\t2.取钱\\t3.存钱\\t4.查询余额\\t5.返回上一级&quot;) enter_number = input(&quot;请输入你的选择\\t&quot;) if enter_number.isdigit(): enter_number = int(enter_number) if 1 &lt;= enter_number &lt;= 5: # 1、创建账户 if enter_number == 1: name, balance, passwd = input(&quot;请输入账户名称、余额和密码进行创建，空格分割\\n&quot;).split() balance = int(balance) account_dict[name] = Account(name,balance,passwd) account_passwd[name] = passwd print(f&quot;创建用户 &#123;name&#125;成功，余额为&#123;balance&#125;&quot;) elif enter_number == 2 or enter_number == 3 or enter_number == 4: print(f&quot;当前的ATM机有&#123;atm_dict.keys()&#125;&quot;) atm, name, passwd = input(&quot;请输入您选择的ATM机、您的账户名称和密码进行登陆，空格分割\\n&quot;).split() # 验证ATM是否存在 if atm in atm_dict.keys(): # 验证账户 if (name, passwd) in account_passwd.items(): atm = atm_dict[atm] # 2、取钱 if enter_number == 2: money = int(input(&quot;请输入取款金额\\n&quot;)) account_dict[name].draw(atm, money) # 3、存钱 elif enter_number == 3: money = int(input(&quot;请输入存款金额\\n&quot;)) account_dict[name].save(atm, money) # 4、查询余额 elif enter_number == 4: account_dict[name].look() else: print(&quot;账户错误&quot;) else: print(f&quot;&#123;atm&#125;不存在&quot;) elif enter_number == 5: print(&quot;退出账户操作&quot;) break else: print(&quot;输入错误，请输入1-5选择操作&quot;)admin_dict = &#123;&quot;admin&quot;:&quot;123456&quot;&#125; # 管理员信息account_passwd = &#123;&#125; # 账户信息atm_dict = &#123;&#125; # 存放初始化实例account_dict = &#123;&#125; # 存放初始化实例while True: print(&quot;请选择：1.ATM操作\\t2.账户操作\\t3.退出&quot;) enter_number = input(&quot;请输入你的选择\\t&quot;) if enter_number.isdigit(): enter_number = int(enter_number) if 1 &lt;= enter_number &lt;= 3: # 1、ATM操作 if enter_number == 1: atm_os() # 2、账户操作 elif enter_number == 2: account_os() else: print(&quot;退出操作！&quot;) exit() else: print(&quot;输入错误，请输入1-3选择操作&quot;) else: print(&quot;输入错误，请输入1-3选择操作&quot;) 三. Linux用户管理类 123456789● ③、Linux用户管理类 Linux用户管理类 ●基类：实现往linux系统里添加用户 ●子类A： ○能够查看、修改uid和gid、shell等信息 ●子类C(A,B)： ●子类B： ○1.可以单独新建组 ○1.能删除用户 ○2.可以将某个用户的gid修改为新建的组的gid ○2.能删除组 ○3.加入异常机制，异常的名字需要自己定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import subprocessclass Base(): def add(self,name,passwd): subprocess.Popen(f&#x27;useradd &#123;name&#125; -p &#123;passwd&#125;&amp;&gt;/dev/null &amp;&amp; echo &quot;&#123;name&#125;创建成功&quot; ||echo &quot;创建失败&quot;&#x27;, shell=True)class A(Base): def look(self,name): p = subprocess.Popen(f&#x27;cut -d &quot;:&quot; -f 1,3,4,7 /etc/passwd|grep -E ^&#123;name&#125;:&#x27;, shell=True) def modify(self,name,uid,gid,shell): p = subprocess.Popen(f&#x27;usermod -u &#123;uid&#125; -g &#123;gid&#125; -s &#123;shell&#125; &#123;name&#125;&amp;&gt;/dev/null &amp;&amp; echo &quot;修改成功&quot; ||echo &quot;修改失败&quot;&#x27;, shell=True)class B(Base): def del_user(self,name): p = subprocess.Popen(f&#x27;userdel -r &#123;name&#125;&amp;&gt;/dev/null &amp;&amp; echo &quot;删除成功&quot; ||echo &quot;创建失败&quot;&#x27;, shell=True) def del_group(self,name): p = subprocess.Popen(f&#x27;groupdel &#123;name&#125;&amp;&gt;/dev/null &amp;&amp; echo &quot;删除成功&quot; ||echo &quot;删除失败&quot;&#x27;, shell=True)class C(A,B): group_member = [] def group_add(self,gid,name): p = subprocess.Popen(f&#x27;groupadd -g &#123;gid&#125; &#123;name&#125;&amp;&gt;/dev/null &amp;&amp; echo &quot;创建成功&quot; ||echo &quot;创建失败&quot;&#x27;, shell=True) C.group_member.append(gid) def gid_modify(self,gid,name): if gid in C.group_member: p = subprocess.Popen(f&#x27;usermod -g &#123;gid&#125; &#123;name&#125;&amp;&gt;/dev/null &amp;&amp; echo &quot;修改成功&quot; ||echo &quot;修改失败&quot;&#x27;, shell=True) else: print(f&quot;修改失败，&#123;gid&#125;不是新建的组id&quot;)class DefinedError(Exception): def __str__(self): return &quot;这是自定义异常&quot;while True: print(&#x27;&#x27;&#x27;请选择：1.添加用户\\t2.查看uid、gid和shell信息\\t3.修改uid、gid和shell信息4.删除用户\\t5.删除组\\t6.新建组\\t7.修改用户gid\\t8.触发异常\\t9.退出&#x27;&#x27;&#x27;) enter_number = input(&quot;请输入你的选择\\t&quot;) if enter_number.isdigit(): enter_number = int(enter_number) if 1 &lt;= enter_number &lt;= 9: if enter_number == 1: sample = Base() name, passwd = input(&quot;请输入用户名和密码，空格分割\\n(2个参数)\\t&quot;).split() sample.add(name, passwd) elif enter_number == 2: sample = A() name = input(&quot;请输入用户名\\n&quot;) sample.look(name) elif enter_number == 3: sample = A() name,uid,gid,shell = input(&quot;请输入用户名，修改后的uid、gid和shell，空格分割\\n(4个参数)\\t&quot;).split() sample.modify(name,uid,gid,shell) elif enter_number == 4: sample = B() name = input(&quot;请输入用户名\\n&quot;) sample.del_user(name) elif enter_number == 5: sample = B() name = input(&quot;请输入组名\\n&quot;) sample.del_group(name) elif enter_number == 6: sample = C() name, gid = input(&quot;请输入组名、指定的gid，空格分割\\n(2个参数)\\t&quot;).split() sample.group_add(gid,name) elif enter_number == 7: sample = C() name, gid = input(&quot;请输入用户名、gid\\n(2个参数)\\t&quot;).split() sample.gid_modify(gid,name) elif enter_number == 8: raise DefinedError elif enter_number == 9: print(&quot;退出系统&quot;) exit() else: print(&quot;输入错误，请输入1-5选择操作！&quot;) else: print(&quot;输入错误，请输入1-5选择操作！&quot;)","categories":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"OOP","slug":"OOP","permalink":"https://blog1.cpen.top/tags/OOP/"}]},{"title":"07_Python-CSDN_高阶函数","slug":"Python_csdn/07_Python_高阶函数","date":"2022-10-04T04:00:00.000Z","updated":"2022-10-04T05:00:00.000Z","comments":true,"path":"posts/46.html","permalink":"https://blog1.cpen.top/posts/46.html","excerpt":"","text":"1234567891011高阶函数：把函数作为参数传入，这样的函数称为高阶函数。# 示例def func01(a, b): print(f&quot;&#123;a&#125; &#123;b&#125;&quot;)def func02(func,a,b): # 注：把函数作为参数传递;func02称为高阶函数 print(&quot;start func......&quot;) func(a,b)func02(func01,&quot;x&quot;,&quot;y&quot;) 常用高阶函数 map ● map 用Python-map代码实现：f(x)=x*x ●内置函数map，map()函数接收两个参数，一个是函数，一个是Iterable（可多个）。 ●map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 ●map()传入的第一个参数是f，即函数对象本身。 ●由于结果r是一个Iterator，Iterator是惰性序列。 ●可通过list()函数让它把整个序列都计算出来并返回一个list。 ●map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x**2，还可以计算任意复杂的函数。 12345678910111213141516171819202122232425# 示例1：map 映射def func(item): # 接收1个参数item return item*item # 返回数的平方a = [1,2,3,4,5,6] # 注：a是可迭代对象result = map(func, a)print(result) # 注：返回 map对象#结果为 &lt;map object at 0x0000020EDE156970&gt;print(list(result))#结果为 [1, 4, 9, 16, 25, 36]---------------------------------------------------------------------------------------------------------------------------------# 示例2：保留2位小数b = [1.239865,4.56,3.2,9.82356]result = map(lambda x:round(x,2), b)print(list(result))#结果为 [1.24, 4.56, 3.2, 9.82]---------------------------------------------------------------------------------------------------------------------------------# 示例3：转化为百分数，并且保留2位小数c = [0.000564, 0.456723, 0.5, 0.71345]result = map(lambda x:format(x,&#x27;.2%&#x27;), c)print(list(result))#结果为 [&#x27;0.06%&#x27;, &#x27;45.67%&#x27;, &#x27;50.00%&#x27;, &#x27;71.34%&#x27;] filter ○ filter 用Python-filter代码实现：在一个list中，删掉偶数，只保留奇数 ○Python内建的filter()函数用于过滤序列。和map()类似，filter()也接收一个函数和一个序列。 ○filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 ○注意到filter()函数返回的是一个Iterator，也就是一个惰性序列。 123456789101112131415161718192021222324252627# 示例1：保留奇数a = [1,2,3,4,5,6,7,8]def func01(x): return x % 2 == 1 # 注：保留奇数；返回结果true\\falseresult = filter(func01, a)print(list(result))#结果为 [1, 3, 5, 7]---------------------------------------------------------------------------------------------------------------------------------# 示例2：返回100以内的回数b = range(1, 101) # 注：字符串反向切片def func02(x): return str(x) == str(x)[::-1]result = filter(func02, b)print(list(result))#结果为 [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99]---------------------------------------------------------------------------------------------------------------------------------# 示例3：过滤出 1-100 以内 开平方根 是整数的数# 方法：开平方后还在原列表里# 过滤出 1-100 以内 开平方根 是整数的数from math import sqrtc = range(1, 101)result = filter(lambda x:sqrt(x) in range(1, 101) , range(1, 101))print(list(result)) # 注：开平方后的数还在 c 里面#结果为 [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] sorted ● sorted 用Python-sorted代码实现：按绝对值大小排序 sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序。 key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。 对比原始的list和经过key=abs处理过的list： ●执行语句：sorted([36, 5, -12, 9, -21], key=abs) 原始字符：list = [36, 5, -12, 9, -21] 经过key-abs对应得到：[36, 5, 12, 9, 21] 按照keys-abs排序结果：[5, 9, 12, 21, 36] 原始字符串最终结果：[5, 9, -12, -21, 36] 1234567891011121314151617181920212223242526272829303132# 示例1：sorted(a)和a.sort()&gt;&gt;&gt; a = [1,2,4,3,0] # 注：不会改变a的值&gt;&gt;&gt; sorted(a) # 注：从小到大排序[0, 1, 2, 3, 4]&gt;&gt;&gt; a.sort() # 注：会改变a的值&gt;&gt;&gt; a[0, 1, 2, 3, 4]---------------------------------------------------------------------------------------------------------------------------------# 示例2：全为布尔型，可以排序&gt;&gt;&gt; a = [1,True,0,False,&quot;c&quot;==&quot;c&quot;]&gt;&gt;&gt; sorted(a)[0, False, 1, True, True]---------------------------------------------------------------------------------------------------------------------------------# 示例3：按照字符串长度排序# 注：按照首字母的ASCII码排序&gt;&gt;&gt; a = [&quot;abc&quot;,&quot;defg&quot;,&quot;123456&quot;,&quot;1&quot;,&quot;sbbbfg&quot;]&gt;&gt;&gt; sorted(a)[&#x27;1&#x27;, &#x27;123456&#x27;, &#x27;abc&#x27;, &#x27;defg&#x27;, &#x27;sbbbfg&#x27;]# 注：按照字符串长度排序&gt;&gt;&gt; sorted(a,key=len)[&#x27;1&#x27;, &#x27;abc&#x27;, &#x27;defg&#x27;, &#x27;123456&#x27;, &#x27;sbbbfg&#x27;]---------------------------------------------------------------------------------------------------------------------------------# 示例4：元组排序# 元组的排序，先比较第一个值，再比较第二个，依次类推&gt;&gt;&gt; a=[(1,2),(2,2),(1,0),(2,4),(True,False)]&gt;&gt;&gt; sorted(a)[(1, 0), (True, False), (1, 2), (2, 2), (2, 4)]&gt;&gt;&gt; sorted(a,reverse=True) # 注：反序 reverse=True[(2, 4), (2, 2), (1, 2), (1, 0), (True, False)] reduce ○ reduce 用Python-reduce代码实现：将列表[1,3,5,7,9]，变成整数13579 ○reduce把一个函数作用在一个序列[x1, x2, x3, …]上 ○这个函数必须接收两个参数 ○reduce把结果继续和序列的下一个元素做累积计算 ○reduce(f, [x1, x2, x3, x4]) =&gt; f(f(f(x1, x2), x3), x4) 12345678910111213141516171819202122232425262728# 示例1：[1,2,3,4] --&gt; 转化成1234from functools import reduce # 注：导入模块a = [1,2,3,4]def func1(x,y): # 注：这个函数接收2个参数 return x*10+yprint(reduce(func1,a))#结果为 1234---------------------------------------------------------------------------------------------------------------------------------# 示例2：reduce 实现python的int功能from functools import reducea = input(&quot;输入想要转化的数字：&quot;)b = &#123;&#x27;1&#x27;:1,&#x27;2&#x27;:2,&#x27;3&#x27;:3,&#x27;4&#x27;:4,&#x27;5&#x27;:5,&#x27;6&#x27;:6,&#x27;7&#x27;:7,&#x27;8&#x27;:8,&#x27;9&#x27;:9,&#x27;0&#x27;:0&#125;c = list(map(lambda i:b.get(i),a))print(c)def func(x,y): return x*10+yresult = reduce(func,c)print(result,type(result))---------------------------------------------------------------------------------------------------------------------------------# 示例3：实现阶乘from functools import reducen = int(input(&quot;输入&quot;))redu =reduce(lambda x,y:x*y,range(1,n+1))print(redu)#结果为 输入:4#24","categories":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"函数","slug":"函数","permalink":"https://blog1.cpen.top/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"06_Python-CSDN_psutil模块","slug":"Python_csdn/06_Python_psutil模块","date":"2022-10-03T04:00:00.000Z","updated":"2022-10-03T05:00:00.000Z","comments":true,"path":"posts/314.html","permalink":"https://blog1.cpen.top/posts/314.html","excerpt":"","text":"一. 介绍 123456介绍 ● process and system utilities ● 能够轻松的实现获取系统运行的进程和系统利用率（CPU、内存、磁盘、网络等）信息，主要应用于系统监控 ● 实现了同等命令命令行实现的功能：ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等 ● 跨平台：linux、windows、OS X、FreeBSD和Sun Solaris等 ● 主要功能包含：CPU、磁盘、内存、网络、进程 二. 安装 1234567891011安装 ● 源码安装：git clone https://github.com/giampaolo/psutil.git cd psutil python3 setup.py install ● 先安装相关库：yum install python3-devel,(用yum list |grep python|grep dev 找到包名)， pip3 install psutil ● 导入使用模块： import psutil[root@cPen_B ~]# yum list |grep python |grep devpython36-devel.x86_64 3.6.8-2.module_el8.1.0+245+c39af44f @AppStream[root@cPen_B ~]# yum install python36-devel.x86_64[root@cPen_B ~]# pip3 install psutil 三. 获取系统基本信息 CPU 1234567891011121314151617181920212223242526272829303132331、cpu ● psutil.cpu_count(,[logical]):默认返回逻辑CPU的个数,当设置logical的参数为False时，返回物理CPU的个数 ● psutil.cpu_percent(,[percpu],[interval])：返回CPU的利用率,percpu为True时显示所有物理核心的利用率,interval不为0时,则阻塞时显示interval执行的时间内的平均利用率 ● psutil.cpu_times(,[percpu])：以命名元组(namedtuple)的形式返回cpu的时间花费,percpu=True表示获取每个CPU的时间花费 user：执行用户进程的时间 system：执行内核进程时间 idle：闲置的时间 iowait：等待io操作的时间 irp：硬中断时间 softirq：软中断时间 ● psutil.cpu_times_percent(,[percpu])：功能和cpu_times大致相同，返回耗时比例 ● psutil.cpu_stats(): 以命名元组的形式返回CPU的统计信息，包括上下文切换，中断，软中断和系统调用次数 ctx_switches:上下文切换次数 interrupts：中断次数 soft_interrupts：软中断次数 syscalls：系统调用次数，linux上始终为0 ● psutil.cpu_freq(): 返回cpu频率# 示例1：返回CPU个数&gt;&gt;&gt; import psutil&gt;&gt;&gt; psutil.cpu_count() # 注：返回逻辑CPU个数2&gt;&gt;&gt; psutil.cpu_count(logical=False) # 注：返回物理CPU个数2# 示例2：CPU使用率 百分比利用率&gt;&gt;&gt; psutil.cpu_percent() 0.1# 示例3：cpu_times&gt;&gt;&gt; psutil.cpu_times() # 注：花费的时间占用总时间的百分比scputimes(user=105.27, nice=0.1, system=81.87, idle=69229.05, iowait=11.17, irq=0.0, softirq=5.25, steal=0.0, guest=0.0, guest_nice=0.0)# 示例4：返回每个核的利用率&gt;&gt;&gt; psutil.cpu_percent(percpu = True)[0.1, 0.1] memory 12345678910111213141516172、memory ● virtual_memory():以命名元组的形式返回内存使用情况,单位为字节 total:总物理内存 available:可用内存，available ～free + buffers + cached percent:使用率： percent = (total - available) / total * 100 used：使用的内存： used = total - free - buffers - cache free：完全没用使用内存 active：最近被访问的内存 inactive：长时间未被访问的内存 buffers：缓存 cached：缓存 slab：内核数据结构缓存的内存 ● swap_memory：以命名元组的形式返回swap/memory使用情况，包含swap中页的换入和换出# 示例1：virtual_memory&gt;&gt;&gt; psutil.virtual_memory()svmem(total=3953979392, available=3447025664, percent=12.8, used=249577472, free=3045027840, active=350208000, inactive=329723904, buffers=2162688, cached=657211392, shared=12365824, slab=117297152) disk 1234567891011121314151617183、disk（linux命令：iostat，df） ● psutil.disk_io_counters([perdisk])：以命名元组的形式返回磁盘io统计信息(汇总的)，包括读、写的次数，读、写的字节数等 ● psutil.disk_partitions(）:磁盘挂载分区信息 device：分区 mountpoint：挂载点 fstype：文件系统格式（fat、ext4、 xfs） opts：挂载参数 ● disk_usage：磁盘使用情况，需要传入一个路径参数 &gt;&gt;&gt; psutil.disk_usage(&#x27;/&#x27;) sdiskusage(total=250685575168, used=103938019328, free=134242258944, percent=43.6) ● iostat ： %util 数值越大越忙碌，到达了io瓶颈（安装包：yum install sysstat）# 示例1：磁盘挂载分区信息 disk_partitions&gt;&gt;&gt; psutil.disk_partitions() [sdiskpart(device=&#x27;/dev/mapper/centos-root&#x27;, mountpoint=&#x27;/&#x27;, fstype=&#x27;xfs&#x27;, opts=&#x27;rw,relatime,attr2,inode64,noquota&#x27;), sdiskpart(device=&#x27;/dev/sda1&#x27;, mountpoint=&#x27;/boot&#x27;, fstype=&#x27;xfs&#x27;, opts=&#x27;rw,relatime,attr2,inode64,noquota&#x27;)]# 示例2：磁盘使用情况 disk_usage&gt;&gt;&gt; psutil.disk_usage(&quot;/&quot;) # 注：需要接挂载点sdiskusage(total=18238930944, used=2300264448, free=15938666496, percent=12.6) Network 123456789101112131415161718192021224、Network（linux命令：ifconfig、who、uptime，netstat） ● psutil.net_io_counters([pernic])：以命名元组的形式返回当前系统中每块网卡的网络io统计信息，包括收发字节数，收发包的数量、出错的情况和删包情况。当pernic为True时，则列出所有网卡的统计信息 ● psutil.net_connections([kind])：以列表的形式返回每个网络连接的详细信息(namedtuple) fd：文件描述符 family：地址簇，ipv4（AF_INET），ipv6 type：SOCK_STREAM（tcp）、udp laddr:本地ip地址 raddr status pid ● psutil.net_if_addrs()：以字典的形式返回网卡的配置信息，包括IP地址和mac地址、子网掩码和广播地址 ● psutil.net_if_stats()：返回网卡的详细信息，包括是否启动、通信类型、传输速度与mtu mtu：最大传输单元 ● psutil.users()：以命名元组的方式返回当前登陆用户的信息，包括用户名，登陆时间，终端 ● psutil.boot_time()：以时间戳的形式返回系统的启动时间# 示例1：psutil.users 以命名元组的方式返回当前登陆用户的信息，包括用户名，登陆时间，终端&gt;&gt;&gt; psutil.users() # 注：w、who命令[suser(name=&#x27;root&#x27;, terminal=&#x27;tty1&#x27;, host=&#x27;&#x27;, started=1606217600.0, pid=708), suser(name=&#x27;root&#x27;, terminal=&#x27;pts/0&#x27;, host=&#x27;192.168.0.42&#x27;, started=1606361216.0, pid=5921), suser(name=&#x27;root&#x27;, terminal=&#x27;pts/2&#x27;, host=&#x27;192.168.0.42&#x27;, started=1606361216.0, pid=5942), suser(name=&#x27;root&#x27;, terminal=&#x27;pts/6&#x27;, host=&#x27;192.168.0.42&#x27;, started=1606354816.0, pid=5239), suser(name=&#x27;root&#x27;, terminal=&#x27;pts/7&#x27;, host=&#x27;192.168.0.42&#x27;, started=1606357120.0, pid=5312)]# 示例2：net_if_addrs&gt;&gt;&gt; psutil.net_if_addrs() # 注：lo本地回环地址 127.0.0.1&#123;&#x27;lo&#x27;: [snicaddr(family=&lt;AddressFamily.AF_INET: 2&gt;, address=&#x27;127.0.0.1&#x27;, netmask=&#x27;255.0.0.0&#x27;, broadcast=None, ptp=None), snicaddr(family=&lt;AddressFamily.AF_INET6: 10&gt;, address=&#x27;::1&#x27;, netmask=&#x27;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&#x27;, broadcast=None, ptp=None), snicaddr(family=&lt;AddressFamily.AF_PACKET: 17&gt;, address=&#x27;00:00:00:00:00:00&#x27;, netmask=None, broadcast=None, ptp=None)], &#x27;ens33&#x27;: [snicaddr(family=&lt;AddressFamily.AF_INET: 2&gt;, address=&#x27;192.168.0.21&#x27;, netmask=&#x27;255.255.255.0&#x27;, broadcast=&#x27;192.168.0.255&#x27;, ptp=None), snicaddr(family=&lt;AddressFamily.AF_INET6: 10&gt;, address=&#x27;fe80::22d8:5740:d6d7:d1ff%ens33&#x27;, netmask=&#x27;ffff:ffff:ffff:ffff::&#x27;, broadcast=None, ptp=None), snicaddr(family=&lt;AddressFamily.AF_PACKET: 17&gt;, address=&#x27;00:0c:29:d1:80:fa&#x27;, netmask=None, broadcast=&#x27;ff:ff:ff:ff:ff:ff&#x27;, ptp=None)]&#125; 进程管理 123456789101112131415161718195、进程管理（linux命令：ps、kill） ● psutil.pids()：以列表的形式返回当前正在运行的进程 ● psutil.pid_exists(1)：判断给点定的pid是否存在 ● psutil.Process(1)：对进程进行封装，可以使用该类的方法获取进行的详细信息，或者给进程发送信号 ● psutil.process_iter()：迭代当前正在运行的进程，返回的是每个进程的Process对象 name：获取进程的名称 cmdline：获取启动进程的命令行参数 create_time：获取进程的创建时间 uids：进程uid信息 num_threads：开启的线程数 exe：进程工作的绝对路径 kill：发送SIGKILL信号结束进程示例：process_iter 迭代当前正在运行的进程&gt;&gt;&gt; psutil.process_iter() &lt;generator object process_iter at 0x7f56eb912888&gt;&gt;&gt;&gt; p = psutil.process_iter()&gt;&gt;&gt; next(p)psutil.Process(pid=1, name=&#x27;systemd&#x27;, status=&#x27;sleeping&#x27;, started=&#x27;01:52:52&#x27;)","categories":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"模块","slug":"模块","permalink":"https://blog1.cpen.top/tags/%E6%A8%A1%E5%9D%97/"},{"name":"Psutil","slug":"Psutil","permalink":"https://blog1.cpen.top/tags/Psutil/"}]},{"title":"05_Python-CSDN_排序算法","slug":"Python_csdn/05_Python_排序算法","date":"2022-10-02T04:00:00.000Z","updated":"2022-10-02T05:00:00.000Z","comments":true,"path":"posts/49827.html","permalink":"https://blog1.cpen.top/posts/49827.html","excerpt":"","text":"一. 顺序查找 12345678910● 顺序查找顺序查找：也叫线性查找，从列表第一个元素开始，顺序进行搜索，直到找到元素或搜索到列表最后一个元素为止。时间复杂度：O(n)def Linear_search(li, val): # 注：li列表 ；val待查找的元素 for ind, v in enumerate(li): # 注：因为要返回个下标 所以用 enumerate index和值都需要 if v == val: # 注：如果v == 我们要找的那个值 那就返回 它的index return ind else: # 如果for循环结束后还没有找到 返回None return None b站视频 路飞IT学城 https://www.bilibili.com/video/BV1mp4y1D7UP?p=7 菜鸟教程 Python线性查找 https://www.runoob.com/python3/python-linear-search.html 二. 二分查找 123456789101112131415161718192021● 二分查找二分查找：又叫折半查找，从有序列表的初始候选区li[0:n]开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。时间复杂度：O(logn)def binary_search(li, val): # li 列表 val待查找的值 left = 0 right = len(li) - 1 while left &lt;= right: # 注：循环条件 说明候选区有值 mid = (left + right) // 2 # 注：中间值(下标) 是整除2 if li[mid] == val: # 注：== 找到的情况 每次对比都是对比的li[mid] return mid # 注：返回下标 mid elif li[mid] &gt; val: # 注：代表 待查找的值val在 mid左边 right = mid - 1 # 注：更新候选区了 这种情况就可以继续循环 else: # 注：第3种情况 li[mid] &lt; val 待查找的值在mid右侧 left = mid + 1 # 注：更新候选区 继续循环 else: return None # 注：如果找不到的情况 即不满足 left &lt;= right 时li = [1,2,3,4,5,6,7,8,9]print(binary_search(li,3)) # 注：调用二分查找 查3 b站视频 路飞IT学城 https://www.bilibili.com/video/BV1mp4y1D7UP?p=8 菜鸟教程 Python二分查找 https://www.runoob.com/python3/python-binary-search.html 三. 冒泡排序 12345678910111213141516171819冒泡排序：列表每两个相邻的数，如果前面比后面大，则交换这两个数。时间复杂度：O(n**2)def bubble_sort2(li): for i in range(len(li)-1): for j in range(len(li)-i-1): if li[j] &gt; li[j+1]: li[j], li[j+1] = li[j+1], li[j]改进：如果冒泡排序中的一趟排序没有发生交换，则说明列表已经有序，可以直接结束算法。def bubble_sort_1(li): for i in range(len(li)-1): exchange = False # 在第i趟那加标志位 for j in range(len(li)-i-1): if li[j] &gt; li[j+1]: li[j], li[j+1] = li[j+1], li[j] exchange = True # 注：如果有交换 把它识成True 交换这里也是1个标志位 if not exchange: # 注：如果每1趟结束后 exchange没有发生交换 (这个在for里面) return # 注：就直接结束掉这个函数 b站视频 路飞IT学城 https://www.bilibili.com/video/BV1mp4y1D7UP?p=12 菜鸟教程 Python冒泡排序 https://www.runoob.com/python3/python-bubble-sort.html 四. 选择排序 1234567891011选择排序：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。时间复杂度：O(n**2)def select_sort(li): for i in range(len(li) - 1): min_loc = i for j in range(i+1, len(li)): if li[j] &lt; li[min_loc]: min_loc = j if min_loc != i: li[i], li[min_loc] = li[min_loc], li[i] b站视频 路飞IT学城 https://www.bilibili.com/video/BV1mp4y1D7UP?p=14 菜鸟教程 Python选择排序 https://www.runoob.com/python3/python-selection-sort.html 五. 插入排序 1234567891011插入排序：它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。时间复杂度：O(n**2)def insert_sort(li): for i in range(1, len(li)): tmp = li[i] j = i - 1 while j &gt;= 0 and tmp &lt; li[j]: li[j + 1] = li[j] j = j - 1 li[j + 1] = tmp b站视频 路飞IT学城 https://www.bilibili.com/video/BV1mp4y1D7UP?p=15 菜鸟教程 Python插入排序 https://www.runoob.com/python3/python-insertion-sort.html 六. 快速排序 12345678910111213141516171819202122232425快速排序：快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。时间复杂度：O(nlogn)# 快速排序-partition函数def partition(li, left, right): tmp = li[left] while left &lt; right: while left &lt; right and li[right] &gt;= tmp: # 从右边找比tmp小的数 right -= 1 # 往右走一步 li[left] = li[right] # 把右边的值写到左边空位上 while left &lt; right and li[left] &lt;= tmp: left += 1 li[right] = li[left] # 把左边的值写到右边空位上 li[left] = tmp # 把tmp归位 return left # mid 是 这个函数返回left值的目的# 快速排序-框架def quick_sort(li, left, right): if left &lt; right: # 至少2个元素 mid = partition(li, left, right) # 这个函数返回left值的目的 quick_sort(li, left, mid - 1) # 左边部分 quick_sort(li, mid + 1, right) # 右边部分li = [5,7,4,6,3,1,2,9,8]quick_sort(li, 0, len(li)-1) b站视频 路飞IT学城 https://www.bilibili.com/video/BV1mp4y1D7UP?p=16 菜鸟教程 Python快速排序 https://www.runoob.com/python3/python-quicksort.html 七. 堆排序 12345678910111213141516171819202122232425262728293031323334堆排序：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。时间复杂度：O(nlogn)def sift(li, low, high): # 向下调整函数 # li：列表 # low: 堆的根节点位置 # high: 堆的最后一个元素的位置 i = low # i最开始指向根节点 j = 2 * i + 1 # j开始是左孩子 tmp = li[low] # 把堆顶存起来 while j &lt;= high: # 只要j位置有数 if j + 1 &lt;= high and li[j+1] &gt; li[j]: # 如果有孩子有并且比较大 j = j + 1 # j指向右孩子 if li[j] &gt; tmp: li[i] = li[j] i = j # 往下看一层 j = 2 * i + 1 else: # tmp更大，把tmp放到i的位置上 li[i] = tmp # 该语句可省 # 把tmp放到某一级领导位置上 break else: li[i] = tmp # 把tmp放到叶子节点上def heap_sort(li): # 建堆函数 n = len(li) for i in range((n-2)//2, -1, -1): # i表示建堆的时候调整的部分的根的下标 sift(li, i, n-1) # 这里不是递归 #建堆完成了#---------------------这一步 挨个出数的步骤 for i in range(n-1, -1, -1): # i指向当前堆的最后一个元素 li[0], li[i] = li[i], li[0] sift(li, 0, i - 1) # i-1是新的high b站视频 路飞IT学城 https://www.bilibili.com/video/BV1mp4y1D7UP?p=22 菜鸟教程 Python堆排序 https://www.runoob.com/python3/python-heap-sort.html 八. 归并排序 1234567891011121314151617181920212223242526272829归并排序：创建在归并操作上的一种有效的排序算法。时间复杂度：O(nlogn)def merge(li, low, mid, high): i = low j = mid + 1 ltmp = [] while i&lt;=mid and j&lt;=high: # 只要左右两边都有数 if li[i] &lt; li[j]: ltmp.append(li[i]) i +=1 else: ltmp.append(li[j]) j += 1 # while执行完，肯定有一部分没数了 while i &lt;= mid: ltmp.append(li[i]) i += 1 while j &lt;= high: ltmp.append(li[j]) j += 1 li[low:high+1] = ltmpdef merge_sort(li, low, high): if low &lt; high: # 至少有2个元素，递归 mid = (low + high) // 2 merge_sort(li, low, mid) merge_sort(li, mid+1, high) merge(li, low, mid, high) b站视频 路飞IT学城 https://www.bilibili.com/video/BV1mp4y1D7UP?p=30 菜鸟教程 Python归并排序 https://www.runoob.com/python3/python-merge-sort.html 九. 希尔排序 1234567891011121314151617希尔排序：希尔排序(Shell Sort)是一种分组插入排序算法。时间复杂度讨论比较复杂，并且和选取的gap序列有关。def insert_sort_gap(li, gap): for i in range(gap, len(li)): # i 表示摸到的牌的下标 tmp = li[i] j = i - gap # j指的是手里牌的下标 while j &gt;= 0 and li[j] &gt; tmp: li[j+gap] = li[j] j = j - gap li[j+gap] = tmpdef shell_sort(li): d = len(li) // 2 while d &gt;= 1: insert_sort_gap(li, d) d //= 2 b站视频 路飞IT学城 https://www.bilibili.com/video/BV1mp4y1D7UP?p=34 菜鸟教程 Python希尔排序 https://www.runoob.com/python3/python-shellsort.html 十. 计数排序 1234567891011计数排序：计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。时间复杂度：O(n)def count_sort(li, max_count=100): count = [0 for _ in range(max_count+1)] for val in li: count[val] += 1 li.clear() for ind, val in enumerate(count): for i in range(val): li.append(ind) b站视频 路飞IT学城 https://www.bilibili.com/video/BV1mp4y1D7UP?p=36 菜鸟教程 Python计数排序 https://www.runoob.com/python3/python-counting-sort.html 十一. 桶排序 123456789101112131415161718桶排序：首先将元素分在不同的桶中，在对每个桶中的元素排序。时间复杂度 取决于数据的分布def bucket_sort(li, n=100, max_num=10000): buckets = [[] for _ in range(n)] # 创建桶 for var in li: i = min(var // (max_num // n), n-1) # i表示var放到几号桶里 buckets[i].append(var) # 把var加到桶里面 # 保持桶内的顺序 for j in range(len(buckets[i])-1, 0, -1): if buckets[i][j] &lt; buckets[i][j-1]: buckets[i][j], buckets[i][j-1] = buckets[i][j-1], buckets[i][j] else: break sorted_li = [] for buc in buckets: sorted_li.extend(buc) return sorted_li b站视频 路飞IT学城 https://www.bilibili.com/video/BV1mp4y1D7UP?p=37 菜鸟教程 桶排序 https://www.runoob.com/w3cnote/bucket-sort.html 十二. 基数排序 1234567891011121314151617181920基数排序：基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。时间复杂度：O(kn)def list_to_buckets(li, base, iteration): buckets = [[] for _ in range(base)] for number in li: digit = (number // (base ** iteration)) % base buckets[digit].append(number) return bucketsdef buckets_to_list(buckets): return [x for bucket in buckets for x in bucket]def radix_sort(li, base=10): maxval = max(li) it = 0 while base ** it &lt;= maxval: li = buckets_to_list(list_to_buckets(list_to_buckets(li, base, it))) it += 1 return li b站视频 路飞IT学城 https://www.bilibili.com/video/BV1mp4y1D7UP?p=39 菜鸟教程 基数排序 https://www.runoob.com/w3cnote/radix-sort.html","categories":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://blog1.cpen.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"04_Python-CSDN_mail模块","slug":"Python_csdn/04_Python_mail模块","date":"2022-10-01T04:00:00.000Z","updated":"2022-10-01T05:00:00.000Z","comments":true,"path":"posts/33188.html","permalink":"https://blog1.cpen.top/posts/33188.html","excerpt":"","text":"一. 理论 1234567891011mail模块作用1、邮件报警2、发送报表邮件协议1、smtp (simple mail transfer protocol) 简单邮件传输协议，主要用来发送文件 默认端口 25号2、pop3 主要用来接收邮件 默认端口 110 客户端的操作不会反馈到服务器端3、imap 主要用来接收邮件 默认端口 143 客户端的操作会反馈到服务器端[参考：菜鸟教程 https://www.runoob.com/python3/python3-smtp.html](https://www.runoob.com/python3/python3-smtp.html) 二. 步骤 QQ邮箱获取授权码 ○ QQ邮箱获取授权码 [参考：获取授权码] (https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256) 先进入设置 －&gt; 帐户页面找到入口 （1）点击“开启” （2）验证密保 （3）获取授权码 或者开启IMAP/SMTP服务，同理 代码部分 123456789101112131415○ 代码部分□ 示例1from smtplib import SMTP # 导入smtplib模块的SMTP类s = SMTP(&quot;smtp.qq.com&quot;) # 使用qq邮箱去发送s.login(&quot;848723505@qq.com&quot;,&quot;hopo**secret**bbdj&quot;) # 发件人邮箱账号、授权码tolist = [&quot;1533431376@qq.com&quot;] # 收件人邮箱账号msg = &quot;&quot;&quot;\\From: 848723505@qq.com@qq.comTO: 1533431376@qq.comSubject: mail module studythis is cPen test&quot;&quot;&quot;s.sendmail(&quot;848723505@qq.com&quot;,tolist, msg) 效果图 12345678910111213141516171819202122□ 示例2from smtplib import SMTPfrom email.mime.text import MIMEText# 第三方smtp服务设置mail_host = &quot;smtp.qq.com&quot;mail_user = &quot;848723505@qq.com&quot; # 发件人邮箱账号mail_pass = &quot;hopo**secret**bbdj&quot; # 发件人授权码recv = &quot;1533431376@qq.com&quot; # 收件人邮箱账号# 构造邮件内容# 正文内容、正文内容类型、正文内容编码message = MIMEText(&quot;Hello World ~ cPen&quot;, &quot;plain&quot;, &quot;utf-8&quot;) # plain是普通的文本message[&quot;From&quot;] = mail_user # 把对象像字典一样传参message[&quot;To&quot;] = recvmessage[&quot;Subject&quot;] = &quot;I Love Coding&quot;s = SMTP(&quot;smtp.qq.com&quot;) # 使用qq邮箱去发送s.login(&quot;848723505@qq.com&quot;,&quot;hopo**secret**bbdj&quot;) # 登录s.sendmail(mail_user,recv,message.as_string()) # 文件内容需要转换成字符型 效果图 12345678910111213141516171819202122□ 示例3from smtplib import SMTPfrom email.mime.text import MIMEText# 第三方smtp服务设置mail_host = &quot;smtp.qq.com&quot;mail_user = &quot;848723505@qq.com&quot; # 发件人邮箱账号mail_pass = &quot;hopo**secret**bbdj&quot; # 发件人授权码recv = &quot;1533431376@qq.com&quot; # 收件人邮箱账号# 把内容识别成网页传送html_msg = &quot; &lt;p&gt;Python mail module test&lt;/p&gt;&lt;p&gt;&lt;a href=&#x27;https://www.baidu.com&#x27;&gt;点击进入百度&lt;/a&gt;&lt;/p&gt;&quot;message = MIMEText(html_msg,&#x27;html&#x27;,&#x27;utf-8&#x27;)message[&quot;From&quot;] = mail_user # 把对象像字典一样传参message[&quot;To&quot;] = recvmessage[&quot;Subject&quot;] = &quot;cPen mail&quot;s = SMTP(&quot;smtp.qq.com&quot;) # 使用qq邮箱去发送s.login(&quot;848723505@qq.com&quot;,&quot;hopo**secret**bbdj&quot;) # 登录s.sendmail(mail_user,recv,message.as_string()) # 文件内容转换成字符型 效果图 Foxmail登录 ○ Foxmail登录 [下载Foxmail客户端](https://www.foxmail.com/) 先进入设置 －&gt; 新建账号，填入E-mail地址和授权码 □ 使用POP3协议登录 □ 使用IMAP协议登录 效果图","categories":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"模块","slug":"模块","permalink":"https://blog1.cpen.top/tags/%E6%A8%A1%E5%9D%97/"},{"name":"Mail","slug":"Mail","permalink":"https://blog1.cpen.top/tags/Mail/"}]},{"title":"03_Python-CSDN_数据类型2","slug":"Python_csdn/03_Python_数据类型2","date":"2022-09-30T04:00:00.000Z","updated":"2022-09-30T05:00:00.000Z","comments":true,"path":"posts/37069.html","permalink":"https://blog1.cpen.top/posts/37069.html","excerpt":"","text":"容器类型 123454种内置数据结构（容器类型） 列表：list=&gt;[val1,val2,val3,val4] 元组：tuple=&gt;(val1,val2,val3,val4) 字典：dict=&gt;&#123;key1:val1,key2:val2&#125; 集合：set=&gt;&#123;key1,key2,key3,key4&#125; 一. 列表（list） 12345678列表是处理一组有序项目的数据结构列表是python中最具灵活性的有序集合对象类型列表可以包含任何类型的对象：字符串、数字甚至其他列表列表是可变的数据类型，即这种类型的值是可以被修改的Example:表示一个购物清单 goods=[&#x27;牛奶&#x27;、&#x27;运动鞋&#x27;、&#x27;咖啡&#x27;、&#x27;手机&#x27;、&#x27;羊肉&#x27;、&#x27;葡萄&#x27;、&#x27;桔子&#x27;]列表通过方括号中用逗号分割的项目定义 12345678910111213141516# 示例# 定义空列表&gt;&gt;&gt; lst = []&gt;&gt;&gt; type(lst)&lt;class &#x27;list&#x27;&gt;&gt;&gt;&gt; lst2 = list() # 注：工厂函数&gt;&gt;&gt; type(lst2)&lt;class &#x27;list&#x27;&gt;# 列表可装入python的任何对象：&gt;&gt;&gt; lst3 = list(&quot;abc&quot;) # 注：字符串&gt;&gt;&gt; lst3 [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; lst = [1,&#x27;abc&#x27;,2.5,True]&gt;&gt;&gt; lst = [1,&#x27;abc&#x27;,2.5,True,lst3] # 注：其他列表&gt;&gt;&gt; lst[1, &#x27;abc&#x27;, 2.5, True, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]] 列表基本操作 索引 ​ 通过下标访问列表中的元素，下标从0开始计数，可取出一个元素 12345678910111213141516171819# 示例&gt;&gt;&gt; lst = [1,2,3]&gt;&gt;&gt; id(lst)140078683813384&gt;&gt;&gt; lst += [4]&gt;&gt;&gt; id(lst)140078683813384 # 注：内存地址不变&gt;&gt;&gt; lst[0]1&gt;&gt;&gt; lst[0] = &quot;a&quot; # 注：改变列表里的元素值&gt;&gt;&gt; id(lst)140078683813384# 下标不能越界（Index Error:list index out of range）&gt;&gt;&gt; lst[&#x27;b&#x27;, 2, 3, 4]&gt;&gt;&gt; lst[4] # 注：下标越界 会报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range 切片 123456切片是通过下标访问列表中的元素，切片可以取出一个子列表起止区间：[ start,end )step:默认=&gt;1start:默认=&gt;step为正时，start为0；step为负时,start为-1end:默认=&gt;step为正时，end为列表结尾；step为负时,end为列表开始注意：三个值都为选填项 12345678910111213141516171819202122# 示例：正切片&gt;&gt;&gt; a = [1,2,3,4,5,6]&gt;&gt;&gt; a[0:4] # 注：切片，前4个[1, 2, 3, 4]&gt;&gt;&gt; str = &quot;123456&quot;&gt;&gt;&gt; str[0:4] # 注：切片，前4个&#x27;1234&#x27;&gt;&gt;&gt; a[:4] # 注：效果一样[1, 2, 3, 4]# 示例：负切片，步长为-1&gt;&gt;&gt; a = [1,2,3,4,5,6]&gt;&gt;&gt; a[-1:3:-1] # 注：-1指向6， 3指向4，-1从右往左[6, 5]&gt;&gt;&gt; a[-1:-4:-1] # 注：-1指向6，-4指向3，-1从右往左[6, 5, 4]&gt;&gt;&gt; a[-1:-44:-1] # 注：-1指向6，-44越界，-1从右往左[6, 5, 4, 3, 2, 1]&gt;&gt;&gt; a[-1:4:-1] # 注：-1指向6, 4指向5，-1从右往左[6]&gt;&gt;&gt; a[-3:4:-1] # 注：-3指向4， 4指向5，4向左取不到5[] # 注：为空 起始位置有误时，切出来会是空(不会报错) 12切片对象(slice函数) slice函数的用途：生成一个slice对象，相当于可以给要切的内容取个名字。 12345678910111213# 示例&gt;&gt;&gt; a = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]&gt;&gt;&gt; a[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; b = [1,2,3,4,5,6]&gt;&gt;&gt; s1 = slice(0,3,1) # 注：引用时需要传参进去&gt;&gt;&gt; a[s1] # 注：切片 前3个[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; b[s1] # 注：切片 前3个[1, 2, 3]&gt;&gt;&gt; c = [&quot;xx&quot;,&quot;yy&quot;,&quot;zz&quot;,&quot;ee&quot;] &gt;&gt;&gt; c[s1] # 注：切片 前3个[&#x27;xx&#x27;, &#x27;yy&#x27;, &#x27;zz&#x27;] 增加 1234增加列表元素的方式 append:在末尾，作为整体追加，类型不限 insert:在index位置插入元素 extend:扩展列表 12345678910111213141516171819202122# 示例# append&gt;&gt;&gt; a = [&quot;apple&quot;, &quot;orange&quot;, 123, 0.1111, &quot;cali&quot;]&gt;&gt;&gt; a.append(&quot;test&quot;) # 注：追加字符串&gt;&gt;&gt; a[&#x27;apple&#x27;, &#x27;orange&#x27;, 123, 0.1111, &#x27;cali&#x27;, &#x27;test&#x27;]&gt;&gt;&gt; lst = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; lst2 = [1,2,3]&gt;&gt;&gt; lst.append(lst2) # 注：追加的类型是数组&gt;&gt;&gt; lst[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, [1, 2, 3]] # 注：追加的类型是数组# insert&gt;&gt;&gt; lst = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; lst.insert(1,&#x27;d&#x27;) # 注：在第2个元素前插入数据&gt;&gt;&gt; lst[&#x27;a&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]# extend&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; str = &quot;abc&quot;&gt;&gt;&gt; a.extend(str) # 注：扩展字符串&gt;&gt;&gt; a[1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 12extend与+ 注意：只限可转为list的类型(str,list,tuple) 123456789101112131415161718192021# 示例&gt;&gt;&gt; a = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; a2 = [1,2,3]&gt;&gt;&gt; a.extend(a2)&gt;&gt;&gt; a[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 1, 2, 3]&gt;&gt;&gt; a + [&quot;5&quot;] # 注：+ 法只能list 和 list 相加[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 1, 2, 3, &#x27;5&#x27;]&gt;&gt;&gt; a[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 1, 2, 3] # 注：+ 法 运行结束后 数组a没有变化&gt;&gt;&gt; b = a + [&quot;5&quot;] # 注：赋值给数组b&gt;&gt;&gt; b # 注：可以通过 赋值给数组b的方法来保存 变化[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 1, 2, 3, &#x27;5&#x27;]&gt;&gt;&gt; id(a)140273972677768&gt;&gt;&gt; a += [&quot;6&quot;]&gt;&gt;&gt; id(a)140273972677768 # 注：a += [&quot;6&quot;] 内存地址不变 对象不变，内容改变&gt;&gt;&gt; a = a + [&quot;7&quot;]&gt;&gt;&gt; id(a)140273837551816 # 注：a = a + [&quot;7&quot;]内存地址改变 删除 123456删除列表元素的方式 pop：删除元素，默认最后一个（指定index删除） remove：删除指定的元素（要删除的数据不存在时，会出错） del：根据下标删除 del是python的一个关键字，用于删除变量(的引用) clear：清空列表 1234567891011121314151617181920212223242526272829303132333435# 示例# pop&gt;&gt;&gt; a.pop() # 注：默认删除最后1个&#x27;7&#x27; # 注：返回值，删除的元素&gt;&gt;&gt; a.pop(2) # 注：指定索引2 删除第3个元素&#x27;c&#x27;# remove&gt;&gt;&gt; a = [&quot;xx&quot;,&quot;yy&quot;,&quot;xx&quot;]&gt;&gt;&gt; a.remove(&quot;xx&quot;) # 注：删除指定元素，只删除第1个&gt;&gt;&gt; a[&#x27;yy&#x27;, &#x27;xx&#x27;]&gt;&gt;&gt; a[&#x27;yy&#x27;, &#x27;xx&#x27;]&gt;&gt;&gt; a.remove(&quot;zz&quot;) # 注：要删除的数据不存在时，会报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: list.remove(x): x not in list# del&gt;&gt;&gt; a = [1,2,3,&quot;xx&quot;,&quot;yy&quot;,&quot;zz&quot;]&gt;&gt;&gt; del a[3] # 注：删除索引3 第4个&gt;&gt;&gt; a[1, 2, 3, &#x27;yy&#x27;, &#x27;zz&#x27;]&gt;&gt;&gt; del a[0:2] # 注：切片删除&gt;&gt;&gt; c = 1&gt;&gt;&gt; del c # 注：del删除变量的引用&gt;&gt;&gt; cTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;c&#x27; is not defined# clear&gt;&gt;&gt; a[3, &#x27;yy&#x27;, &#x27;zz&#x27;]&gt;&gt;&gt; a.clear()&gt;&gt;&gt; a[] # 注：clear清空 修改 修改元素主要是利用下标和切片来修改或增加、删除 1234567891011121314151617181920212223242526272829303132333435363738394041# 示例&gt;&gt;&gt; a = [1,2,3,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; a[1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; a[2] = &quot;x&quot; # 注：修改元素&gt;&gt;&gt; a[1, 2, &#x27;x&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; a[1:1] # 注：[1,1)[] # 注：为空&gt;&gt;&gt; a[1:1] = &quot;abc&quot; # 注：在起始位置 索引为1 处之前 增加列表 str类型转换为列表&gt;&gt;&gt; a[1, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 2, &#x27;x&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; b = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]&gt;&gt;&gt; b[2:2] = [&quot;x&quot;,&quot;y&quot;] # 注：索引为2处之前 增加列表&gt;&gt;&gt; b[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; b[2:4] = [&quot;x&quot;,&quot;y&quot;,&quot;z&quot;] # 注：索引2、3 的值 替换&gt;&gt;&gt; b[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; b[1:5] = &quot;12&quot; # 注：切出来后，再转换为列表。str类型转换为列表&gt;&gt;&gt; b # 注：索引1、2、3、4 的值 替换 为 ‘1’‘2’[&#x27;a&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; b[&#x27;a&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; b[5:-3] []&gt;&gt;&gt; b[3:-3] # 注：获取不到[]&gt;&gt;&gt; b[3:-3] = &quot;xy&quot; # 注：这个位置开始(start位置开始)，替换成其他的list&gt;&gt;&gt; b # 注：看 找出的元素是否为空[&#x27;a&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; c = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;1&quot;]&gt;&gt;&gt; c[1:4] = &quot;hello&quot; # 注：找出b c d 把bcd 替换成h e l l o&gt;&gt;&gt; c[&#x27;a&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;1&#x27;]&gt;&gt;&gt; c = [&#x27;a&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;1&#x27;]&gt;&gt;&gt; c[5:3] # 注：获取不到[]&gt;&gt;&gt; c[5:3] = [&quot;x&quot;,&quot;y&quot;] # 注：c[5:3]为空，在 o (下标5)处插入x y&gt;&gt;&gt; c[&#x27;a&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;o&#x27;, &#x27;1&#x27;] 反转 ​ 反转列表-reverse 或 切片 12345678910111213# 示例# 1.负切片 实现反转，输出的值反转&gt;&gt;&gt; a = [1,2,3,4]&gt;&gt;&gt; a[::-1] # 注：负切片[4, 3, 2, 1]&gt;&gt;&gt; a # 注：a本身的值 没有反转[1, 2, 3, 4]# 2.reverse 字符串的反转&gt;&gt;&gt; a[1, 2, 3, 4]&gt;&gt;&gt; a.reverse()&gt;&gt;&gt; a # 注：a本身的值 反转[4, 3, 2, 1] 排序 ​ 列表排序-sort 123456789101112131415161718192021222324252627# 示例&gt;&gt;&gt; a[4, 3, 2, 1]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1, 2, 3, 4] # 注：排序后 a本身的值发生改变# 反向排序a.sort(reverse=True)&gt;&gt;&gt; a[1, 2, 3, 4]&gt;&gt;&gt; a.sort(reverse=True) # 注：反向排序，升序变成降序&gt;&gt;&gt; a[4, 3, 2, 1] # 注：从大到小排序# 不支持int和str混合 的排序：&gt;&gt;&gt; a = [&quot;a&quot;,1,&quot;b&quot;,2]&gt;&gt;&gt; a.sort()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;&lt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27;&gt;&gt;&gt; a = [&quot;a&quot;,&quot;1&quot;,&quot;b&quot;,&quot;2&quot;]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;a&#x27;, &#x27;b&#x27;]# 按 编码排序&gt;&gt;&gt; a = [&quot;a&quot;,&quot;1&quot;,&quot;b&quot;,&quot;2&quot;,&quot;A&quot;]&gt;&gt;&gt; a[&#x27;a&#x27;, &#x27;1&#x27;, &#x27;b&#x27;, &#x27;2&#x27;, &#x27;A&#x27;] 统计 ​ len、count、index 12345678910111213141516171819202122232425262728293031# 示例# len 总长度&gt;&gt;&gt; a[&#x27;a&#x27;, &#x27;中&#x27;, &#x27;序&#x27;, &#x27;排&#x27;, &#x27;文&#x27;]&gt;&gt;&gt; len(a)5&gt;&gt;&gt; a.append([1,2,3])&gt;&gt;&gt; len(a)6&gt;&gt;&gt; a[&#x27;a&#x27;, &#x27;中&#x27;, &#x27;序&#x27;, &#x27;排&#x27;, &#x27;文&#x27;, [1, 2, 3]]&gt;&gt;&gt; a.extend([1,2,3])&gt;&gt;&gt; len(a)9# count统计元素出现的次数&gt;&gt;&gt; a[&#x27;a&#x27;, &#x27;中&#x27;, &#x27;序&#x27;, &#x27;排&#x27;, &#x27;文&#x27;, [1, 2, 3], 1, 2, 3]&gt;&gt;&gt; a.count(&quot;a&quot;)1&gt;&gt;&gt; a.count(1)1# index返回元素所在的索引位置&gt;&gt;&gt; a = [&quot;x&quot;,&quot;y&quot;,&quot;x&quot;,1]&gt;&gt;&gt; a.count(&quot;x&quot;)2&gt;&gt;&gt; a.index(&quot;x&quot;)0&gt;&gt;&gt; a.index(&quot;z&quot;) # 注：index通过元素找索引，如果没有会报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: &#x27;z&#x27; is not in list 遍历 ​ 遍历：依次取出对象中的每一项数据 ​ list是一个可迭代对象（iterable），可以直接用for遍历 1234567891011121314151617181920212223242526272829# 1.for i in a:&gt;&gt;&gt; a[&#x27;x&#x27;, &#x27;y&#x27;, &#x27;x&#x27;, 1]&gt;&gt;&gt; for i in a:... print(f&quot;item is ---&gt;&#123;i&#125;&quot;)... item is ---&gt;xitem is ---&gt;yitem is ---&gt;xitem is ---&gt;1# 2.enumerate()函数 # 特点：会返回元组，元组里包含每一个下标和值# 注：用1个i去遍历，获取的是元组&gt;&gt;&gt; for i in enumerate(a):... print(f&quot;item is ---&gt;&#123;i&#125;&quot;)... item is ---&gt;(0, &#x27;x&#x27;)item is ---&gt;(1, &#x27;y&#x27;)item is ---&gt;(2, &#x27;x&#x27;)item is ---&gt;(3, 1)# 用2个临时变量，获取enumerate(a)元组的返回&gt;&gt;&gt; for i,j in enumerate(a):... print(f&quot;&#123;i&#125;--&gt;&#123;j&#125;&quot;)... 0--&gt;x1--&gt;y2--&gt;x3--&gt;1 判断成员关系 ​ 判断列表中是否有某个数据 123456789# 示例&gt;&gt;&gt; lst = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]&gt;&gt;&gt; print(&#x27;a&#x27; in lst)True&gt;&gt;&gt; print(&#x27;x&#x27; in lst)False&gt;&gt;&gt; s = &#x27;a&#x27;&gt;&gt;&gt; print(s, &#x27;在&#x27; if s in lst else &#x27;不在&#x27;,&#x27;列表里&#x27;)a 在 列表里 类型转换 ​ 字符串(str)转列表(list) 1234# 示例&gt;&gt;&gt; str = &#x27;abc 123&#x27;&gt;&gt;&gt; list(str)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27; &#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] 二. 元组（tuple） 123456元组是处理一组有序项目的数据结构元组和字符串一样是不可变的,即你不能修改元组元组可以包含任何类型的对象：字符串、数字甚至其他列表适应场景：性别选择，数据库的查询结果Example:表示一个购物清单 goods=(&#x27;牛奶&#x27;、&#x27;运动鞋&#x27;、&#x27;咖啡&#x27;、&#x27;手机&#x27;、&#x27;羊肉&#x27;、&#x27;葡萄&#x27;、&#x27;桔子&#x27;) 123456789101112131415161718192021# 示例# 元组通过圆括号中用逗号分割的项目定义&gt;&gt;&gt; a = ()&gt;&gt;&gt; type(a)&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; a = (1) # 注：括号还可以代表集合&gt;&gt;&gt; type(a)&lt;class &#x27;int&#x27;&gt;# 元组中只有一个元素的时候，需要在元素后面加个，区分这个括号是表示结合还是表示元组&gt;&gt;&gt; a = (1,) # 注：元组中只有1个元素时，需要加逗号(,)表示元组&gt;&gt;&gt; type(a)&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; a = tuple() # 注：定义空元组&gt;&gt;&gt; type(a)&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; a()# 元组可装入python的任何对象&gt;&gt;&gt; a = (&quot;a&quot;,1,1.2,True,print)&gt;&gt;&gt; a(&#x27;a&#x27;, 1, 1.2, True, &lt;built-in function print&gt;) 元组基本操作 索引 ​ 通过下标访问列表中的元素，下标从0开始计数，可取出一个元素 123456789101112# 示例&gt;&gt;&gt; a = (&quot;a&quot;,1,1.2,True,print)&gt;&gt;&gt; a[4]&lt;built-in function print&gt;&gt;&gt;&gt; a[3]True# 下标不能越界，越界会报错&gt;&gt;&gt; a = (&quot;a&quot;,1,1.2,True,print)&gt;&gt;&gt; a[5]Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: tuple index out of range 切片 123456切片是通过下标访问元组中的元素，切片可以取出一个子元组起止区间：[start,end)step:默认=&gt;1start:默认=&gt;step为正时，start为0；step为负时,start为-1end:默认=&gt;step为正时，end为列表结尾；step为负时,end为列表开始注意：三个值都为选填项 1234# 示例&gt;&gt;&gt; a = (&quot;a&quot;,1,1.2,True,print)&gt;&gt;&gt; a[1:3](1, 1.2) 不可变性 123456789101112# 示例&gt;&gt;&gt; a(&#x27;a&#x27;, 1, 1.2, True, &lt;built-in function print&gt;)&gt;&gt;&gt; a[0] = 1 # 注：报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;tuple&#x27; object does not support item assignment&gt;&gt;&gt; tu1 = (1,2)&gt;&gt;&gt; tu2 = (3,4)&gt;&gt;&gt; tu3 = tu1 + tu2&gt;&gt;&gt; tu3(1, 2, 3, 4) 统计 1234# 示例&gt;&gt;&gt; a = (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)&gt;&gt;&gt; print(len(a))3 遍历 1234567891011121314# 示例&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; for i in enumerate(a):... print(i)... (0, 1) # 注：返回值 是 元组(1, 2)(2, 3)&gt;&gt;&gt; for i,j in enumerate(a):... print(f&quot;&#123;i&#125;---&#123;j&#125;&quot;) # 注：用两个参数 来接收 返回值... 0---11---22---3 成员关系 ​ 成员关系： in , not in 123456# 示例&gt;&gt;&gt; a = (&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)&gt;&gt;&gt; &quot;a&quot; in aTrue&gt;&gt;&gt; &quot;d&quot; not in aTrue 三. 字典（dict） 1234567字典是Python中一个键值映射的数据结构字典是无序的字典是可变对象key必须是唯一的,so天生去重example: singer=&#123;key1:value,key2:value&#125; singer=&#123;&quot;李圣杰&quot;:&#x27;痴心绝对&#x27;,&#x27;张韶涵&#x27;:&#x27;阿刁&#x27;,&#x27;汪峰&#x27;:&#x27;普通迪斯高&#x27;&#125; 1234字典的定义 字典的key必须是可hash对象 python中所有字符串、数字、元组、布尔值、None都是可hash对象 字典的value可以是任何值 1234567891011121314151617181920212223# 示例# 定义空字典# 方法1：&gt;&gt;&gt; a = &#123;&#125; # 注：定义空字典# 方法2：&gt;&gt;&gt; b = dict() # 注：定义空字典，工厂函数&gt;&gt;&gt; type(a)&lt;class &#x27;dict&#x27;&gt;&gt;&gt;&gt; type(b)&lt;class &#x27;dict&#x27;&gt;# 示例&gt;&gt;&gt; c = [(&#x27;root&#x27;,&#x27;123456&#x27;),(&#x27;admin&#x27;,&#x27;admin&#x27;)]&gt;&gt;&gt; d = dict(c) # 注：列表转换成字典 工厂函数&gt;&gt;&gt; d&#123;&#x27;root&#x27;: &#x27;123456&#x27;, &#x27;admin&#x27;: &#x27;admin&#x27;&#125;&gt;&gt;&gt; e = [1,2,3]&gt;&gt;&gt; e[1, 2, 3]&gt;&gt;&gt; dict(e) # 注：转换的对象要有 键值映射 的格式Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: cannot convert dictionary update sequence element #0 to a sequence 字典基本操作 取值 12用法1：dicts[key]=&gt;当key不存在时，会引了KeyError错误用法2：dicts.get(key,default)=&gt;当key不存在时，返回default值 123456789101112131415161718192021# 示例&gt;&gt;&gt; a = &#123;&quot;a&quot;:4,&quot;b&quot;:2&#125;&gt;&gt;&gt; a[&#x27;a&#x27;]=3 # 注：修改key=”a”的 value 值&gt;&gt;&gt; a&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 2&#125;&gt;&gt;&gt; a[&#x27;c&#x27;]=4 # 注：增加键值对&gt;&gt;&gt; a&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 2, &#x27;c&#x27;: 4&#125;&gt;&gt;&gt; a[&#x27;c&#x27;] # 注：取值4&gt;&gt;&gt; a[&#x27;d&#x27;] # 注：key不存在，报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &#x27;d&#x27;# 推荐使用get&gt;&gt;&gt; a&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 2, &#x27;c&#x27;: 4&#125;&gt;&gt;&gt; a.get(&#x27;d&#x27;) # 注：不报错&gt;&gt;&gt; c = a.get(&#x27;d&#x27;)&gt;&gt;&gt; print(c)None # 注：默认值没有设置 增加/修改 123用法：dicts[key]=value 当key不存在时，表示增加一个键值对 当key存在时，表示修改对应的value值 12345678910# 示例：修改&gt;&gt;&gt; a&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 2, &#x27;c&#x27;: 4&#125;&gt;&gt;&gt; a[&#x27;a&#x27;] = 5&gt;&gt;&gt; a&#123;&#x27;a&#x27;: 5, &#x27;b&#x27;: 2, &#x27;c&#x27;: 4&#125;# 示例：新增&gt;&gt;&gt; a[&#x27;d&#x27;] = False&gt;&gt;&gt; a&#123;&#x27;a&#x27;: 5, &#x27;b&#x27;: 2, &#x27;c&#x27;: 4, &#x27;d&#x27;: False&#125; 删除 12用法1：dicts.pop(key)用法2：dicts.popitem() 123456789101112131415161718# 示例：dicts.pop(key)&gt;&gt;&gt; a = &#123;&#x27;a&#x27;:5,&#x27;b&#x27;:2,&#x27;c&#x27;:4,&#x27;d&#x27;:False&#125;&gt;&gt;&gt; a.pop(&#x27;a&#x27;) # 注：删除 key=‘a’ 的元素5 # 注：pop有返回值&gt;&gt;&gt; c = a.pop(&#x27;b&#x27;) # 注：获取返回值&gt;&gt;&gt; c2&gt;&gt;&gt; a&#123;&#x27;c&#x27;: 4, &#x27;d&#x27;: False&#125;# 示例：dicts.popitem()# python3里面删除的是最后一个&gt;&gt;&gt; a = &#123;&quot;x&quot;:1,&quot;y&quot;:2,&quot;z&quot;:3&#125;&gt;&gt;&gt; a.popitem()(&#x27;z&#x27;, 3)&gt;&gt;&gt; a.popitem()(&#x27;y&#x27;, 2)&gt;&gt;&gt; a.popitem()(&#x27;x&#x27;, 1) 合并 12用法1：dict1.update(dict2)=&gt;将dict2合并到dict1用法2：dict(dict1,**dict2)=&gt;将dict1与dict2合并生成一个新字典 1234567891011121314151617181920# 示例：dict1.update(dict2)&gt;&gt;&gt; a = &#123;&quot;x&quot;:1,&quot;y&quot;:3&#125;&gt;&gt;&gt; b = &#123;&quot;q&quot;:2,&quot;w&quot;:3&#125;&gt;&gt;&gt; a.update(b) # 注：a自带的属性&gt;&gt;&gt; a&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 3, &#x27;q&#x27;: 2, &#x27;w&#x27;: 3&#125;&gt;&gt;&gt; b&#123;&#x27;q&#x27;: 2, &#x27;w&#x27;: 3&#125;# 示例：dict(dict1, **dict2)&gt;&gt;&gt; a = &#123;&quot;x&quot;:1,&quot;y&quot;:3&#125;&gt;&gt;&gt; b = &#123;&quot;q&quot;:2,&quot;w&quot;:3&#125;&gt;&gt;&gt; dict(a,**b) # 注：工厂函数，返回一个字典 a和b的合并&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 3, &#x27;q&#x27;: 2, &#x27;w&#x27;: 3&#125;&gt;&gt;&gt; a # 注：a本身没有改变&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 3&#125;&gt;&gt;&gt; dict()&#123;&#125;&gt;&gt;&gt; c = dict(a,**b)&gt;&gt;&gt; c&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 3, &#x27;q&#x27;: 2, &#x27;w&#x27;: 3&#125; 成员关系 123用法： item in dicts item not in dicts 12345678910# 示例&gt;&gt;&gt; a = &#123;&quot;x&quot;:1,&quot;y&quot;:2,&quot;z&quot;:3&#125;&gt;&gt;&gt; a&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2, &#x27;z&#x27;: 3&#125;&gt;&gt;&gt; &#x27;x&#x27; in a # 注：in 默认 对比的是key值True&gt;&gt;&gt; 2 in aFalse&gt;&gt;&gt; 2 in a.values() # 注：a.values()对比的是value值True 遍历 ​ 默认遍历的是 key 12345678910111213141516171819202122232425262728293031323334353637383940414243# 示例&gt;&gt;&gt; a&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2, &#x27;z&#x27;: 3&#125;# 遍历key值&gt;&gt;&gt; for i in a:... print(i)... x # 注：遍历key值yz# 遍历value值&gt;&gt;&gt; for i in a.values():... print(i)... 1 # 注：遍历value值23# 既想获得key 也想获得value# items返回的是元组# 方式1&gt;&gt;&gt; for i in a.items():... print(i)... (&#x27;x&#x27;, 1)(&#x27;y&#x27;, 2)(&#x27;z&#x27;, 3)# 方式2&gt;&gt;&gt; for i,j in a.items(): # 注：2个参数获取返回值key,value... print(f&quot;key is &#123;i&#125;, value is &#123;j&#125;&quot;)... key is x, value is 1key is y, value is 2key is z, value is 3# 方式3&gt;&gt;&gt; for i in a.items():... print(f&quot;key is &#123;i[0]&#125;, value is &#123;i[1]&#125;&quot;) # 注：索引获取参数... key is x, value is 1key is y, value is 2key is z, value is 3 四. 集合（set） 12集合是一个无序的，不重复的数据组合集合是一个只含有key的字典 12345集合的作用 去重：把一个列表变成集合，就自动去重了 关系测试：测试两组数据之前的交集、差集、并集等关系 example: singer=&#123;&quot;李圣杰&quot;,&#x27;张韶涵&#x27;,&#x27;汪峰&#x27;&#125; 1234集合的定义 集合通过花括号中，而各个元素用逗号分割 集合元素必须是可hash对象，跟字典一样 set和dict的唯一区别仅在于没有存储对应的value 12345678910# 示例# 定义空集合（2种方式）&gt;&gt;&gt; a = &#123;1,2,3&#125; # 注：第1种方式&gt;&gt;&gt; type(a)&lt;class &#x27;set&#x27;&gt;&gt;&gt;&gt; a = set() # 注：第2种方式&gt;&gt;&gt; aset()&gt;&gt;&gt; type(a)&lt;class &#x27;set&#x27;&gt; 集合基本操作 添加 12用法：s.add(item)=&gt;添加一项用法：s.update(someitems)=&gt;添加多项 1234567891011# 示例&gt;&gt;&gt; s = &#123;1,2,3&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.update(&quot;str&quot;) # 注：str被扩展进来，是一个一个被扩展进来的&gt;&gt;&gt; s&#123;1, 2, 3, 4, &#x27;t&#x27;, &#x27;r&#x27;, &#x27;s&#x27;&#125;&gt;&gt;&gt; s.update(&#123;&quot;x&quot;:1,&quot;y&quot;:2&#125;) # 注：字典 扩展的是 key值&gt;&gt;&gt; s&#123;1, 2, 3, 4, &#x27;x&#x27;, &#x27;t&#x27;, &#x27;y&#x27;, &#x27;r&#x27;, &#x27;s&#x27;&#125; 移除 12用法1：s.remove(item)=&gt;移除一项(item不存在会出错KeyError)用法2：s.discard(item)=&gt;移除一项(item不存在则什么也不做) 1234567891011121314151617181920212223242526# 示例# remove&gt;&gt;&gt; s&#123;1, 2, 3, 4, &#x27;x&#x27;, &#x27;t&#x27;, &#x27;y&#x27;, &#x27;r&#x27;, &#x27;s&#x27;&#125;&gt;&gt;&gt; s.remove(&#x27;r&#x27;)&gt;&gt;&gt; s&#123;1, 2, 3, 4, &#x27;x&#x27;, &#x27;t&#x27;, &#x27;y&#x27;, &#x27;s&#x27;&#125;&gt;&gt;&gt; s.remove(&#x27;p&#x27;) # 注：“p”不存在，报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &#x27;p&#x27;# discard&gt;&gt;&gt; s&#123;1, 2, 3, 4, &#x27;x&#x27;, &#x27;t&#x27;, &#x27;y&#x27;, &#x27;s&#x27;&#125;&gt;&gt;&gt; s.discard(&#x27;o&#x27;) # 注：不存在 不报错 什么也不做&gt;&gt;&gt; s.discard(&#x27;x&#x27;)&gt;&gt;&gt; s&#123;1, 2, 3, 4, &#x27;t&#x27;, &#x27;y&#x27;, &#x27;s&#x27;&#125;# pop&gt;&gt;&gt; a=&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;&gt;&gt;&gt; a.pop()&#x27;c&#x27;&gt;&gt;&gt; a.pop()&#x27;a&#x27;&gt;&gt;&gt; a.pop()&#x27;b&#x27; 集合操作 1234并集：t和s的并集,返回一个新的set包含s和t中的每一个元素交集:t和s的交集,返回一个新的set包含s和t中的公共元素差集:返回一个新的set包含s中有但是t中没有的元素对称差集:返回一个新的set包含s和t中不重复的元素（在t或s中，但不会同时出现在二者中） 123456789101112131415161718192021222324252627282930313233343536# 示例# 创建集合&gt;&gt;&gt; set(&#x27;hello&#x27;)&#123;&#x27;e&#x27;, &#x27;o&#x27;, &#x27;l&#x27;, &#x27;h&#x27;&#125;# 并集&gt;&gt;&gt; s1 = &#123;1,2,3&#125;&gt;&gt;&gt; s2 = &#123;2,3,4&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s1.union(s2)&#123;1, 2, 3, 4&#125;# 交集&gt;&gt;&gt; s1 = &#123;1,2,3&#125;&gt;&gt;&gt; s2 = &#123;2,3,4&#125;&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1.intersection(s2)&#123;2, 3&#125;# 差集&gt;&gt;&gt; s1 = &#123;1,2,3&#125;&gt;&gt;&gt; s2 = &#123;2,3,4&#125;&gt;&gt;&gt; s1 - s2&#123;1&#125;# 注：s1里面有的,s2里面没有的&gt;&gt;&gt; s2 - s1&#123;4&#125;# 对称差集&gt;&gt;&gt; s1 = &#123;1,2,3&#125;&gt;&gt;&gt; s2 = &#123;2,3,4&#125;&gt;&gt;&gt; s1 ^ s2&#123;1, 4&#125;# 注：除了交集 的部分","categories":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"数据类型","slug":"数据类型","permalink":"https://blog1.cpen.top/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"02_Python-CSDN_数据类型1","slug":"Python_csdn/02_Python_数据类型1","date":"2022-09-29T04:00:00.000Z","updated":"2022-09-29T05:00:00.000Z","comments":true,"path":"posts/4979.html","permalink":"https://blog1.cpen.top/posts/4979.html","excerpt":"","text":"基本类型 Python数字 在Python中有3种类型的数——整数、浮点数和复数 数字类型 示例 说明 整数 -2, 12389 999999L, ∞ 0b1110, 0xabf, 0o126 python2中区分整型、长整型，长整型的整数可以 无穷大 python3中统称为整型 整型的二进制，十六进制，八进制表示法 浮点数 -3.23, -52.3E-4 在 python 中可以用科学计数法表示浮点数 复数 -5+4j,2.3-4.6j 其中-5,4为实数，j为虚数 int python3 中只有 int（可存超长数据） 整型进制表示法 进制 表示方法 示例 二进制 以0b开头，只能包含0、1，逢2进1 0b11，0b12（错误的表示） 八进制 以0o开头，能包含0-7，逢8进1 0o11 十六进制 以0x开头，能包含0-F，逢16进1 0x11 十进制 直接由数字0-9组成，逢10进1 11 整型进制操作 1234进制转换-bin:任意进制转2进制,接收一个int,返回一个str进制转换-oct:任意进制转8进制,接收一个int,返回一个str进制转换-hex:任意进制转16进制,接收一个int,返回一个str进制转换-int:任意进制转10进制,接收一个int/str,返回一个int 12345678910111213# 示例&gt;&gt;&gt; bin(10) # 10进制转2进制&#x27;0b1010&#x27;&gt;&gt;&gt; bin(0o71) # 8进制转2进制&#x27;0b111001&#x27;&gt;&gt;&gt; bin(0x11) # 16进制转2进制&#x27;0b10001&#x27;&gt;&gt;&gt; int(&quot;10&quot;)10 # str 转换成 int&gt;&gt;&gt; int(&quot;0o11&quot;,base=8) # 8进制的字符串，要指定一下9&gt;&gt;&gt; int(0o11) # 8进制整型 直接转换9 float float(浮点型)：浮点数即带有小数点的数字 ​ float由整数位，小数点，小数位组成，也可以用科学计数法表示，例如-3.23，-52.3E-4，6.23E12 ​ float是不精确的 decimal模块 ​ Decimal类型数据是精确的小数，可以传递给Decimal整型或者字符串参数 官方文档 ​ float https://docs.python.org/3/library/functions.html#float ​ decimal https://docs.python.org/3/library/decimal.html?highlight=decimal 1234567891011121314# 示例：浮点型数据float是不精确的&gt;&gt;&gt; i = 1&gt;&gt;&gt; i = i - 0.1&gt;&gt;&gt; i0.9&gt;&gt;&gt; i = i - 0.1&gt;&gt;&gt; i0.8&gt;&gt;&gt; i = i - 0.1&gt;&gt;&gt; i0.7000000000000001&gt;&gt;&gt; i = i - 0.1&gt;&gt;&gt; i0.6000000000000001 1234567891011# 示例：Decimal类型数据是精确的小数，可以传递给Decimal整型或者字符串参数&gt;&gt;&gt; from decimal import getcontext, Decimal, Context&gt;&gt;&gt; mydec = Decimal.from_float(12.222)&gt;&gt;&gt; mydecDecimal(&#x27;12.2219999999999995310417943983338773250579833984375&#x27;)&gt;&gt;&gt; mydec = Decimal(0.9)&gt;&gt;&gt; mydecDecimal(&#x27;0.90000000000000002220446049250313080847263336181640625&#x27;)&gt;&gt;&gt; mydec = Decimal(&quot;3.14&quot;)&gt;&gt;&gt; mydecDecimal(&#x27;3.14&#x27;) complex 复数complex：复数就是实数和虚数的统称 在数学中的表示：复数的基本形式是a+bi,其中a,b是实数,a称为实部,bi称为虚部,i是虚数单位 complex的组成：复数由实数部分和虚数部分组成，一般形式为x＋yj，其中的x是复数的实数部分，y是复数的虚数部分，这里的x和y都是实数 123456# 示例&gt;&gt;&gt; a = 5 + 4j&gt;&gt;&gt; a.real5.0 # 存放的是浮点型&gt;&gt;&gt; a.imag4.0 Python字符串 字符串：字符串是字符的序列 表示方法：单引号（‘）；双引号（“）；三引号（’''或”””）；原样输出 符号 说明 示例 单引(') 可引用包含双引号的字符串 ‘say“hello”’ 双引号(“) 可引用包含单引号的字符串 “What’syourname?” 三号引(‘’'或”””) 可引用一个多行的字符串，在三引号中可自由使用单引号和双引号 ‘’‘这是多行字符里面可包含单引号’和双引号”’‘’ 特殊标记® 不使得转义字符，将字符原样输出 r”hello\\tworld!” 123456789101112131415161718192021222324252627282930313233343536# 示例&gt;&gt;&gt; a = &#x27;test&#x27;&gt;&gt;&gt; b = &quot;test&quot;&gt;&gt;&gt; a&#x27;test&#x27;&gt;&gt;&gt; b&#x27;test&#x27;&gt;&gt;&gt; a = &#x27;&#x27;&#x27;... t... e... s... t&#x27;&#x27;&#x27;&gt;&gt;&gt; a&#x27;\\nt\\ne\\ns\\nt&#x27;&gt;&gt;&gt; print(a)test# print(a)按照规定的格式打印输出&gt;&gt;&gt; c = &quot;t1\\nt2&quot;&gt;&gt;&gt; c&#x27;t1\\nt2&#x27;&gt;&gt;&gt; print(c)t1t2&gt;&gt;&gt; c = &#x27;t1\\nt2&#x27;&gt;&gt;&gt; c&#x27;t1\\nt2&#x27;&gt;&gt;&gt; print(c)t1t2&gt;&gt;&gt; c = r&quot;t1\\nt2&quot;&gt;&gt;&gt; print(c)t1\\nt2 转义字符 ​ 转义字符是一种特殊的字符常量。转义字符以反斜线&quot;&quot;开头，后跟一个或几个字符。转义字符具有特定的含义，不同于字符原有的意义，故称“转义”字符。 转义字符 描述 转义字符 描述 转义字符 描述 \\(在行尾时) 续行符 \\n 换行 \\oyy 八进制数，yy代表的字符，例如：\\o12代表换行 \\\\ 反斜杠符号 \\v 纵向制表符 \\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行 \\’ 单引号 \\t 横向制表符 \\other 其它的字符以普通格式输出 \\&quot; 双引号 \\r 回车 \\b 退格(Backspace) \\a 响铃 \\f 换页 \\e 转义 字符串取值 ​ 下标取值法（注意：下标从0开始） ​ 切片取值法 1234567# 示例&gt;&gt;&gt; a = &quot;test&quot;&gt;&gt;&gt; a[0]&#x27;t&#x27;&gt;&gt;&gt; a = &quot;test&quot;&gt;&gt;&gt; a[0:2] # 取下标为0~2的数据。包括0，不包括2&#x27;te&#x27; # 前面包括，后面不包括 字符串的不可变的序列 一旦创造了一个字符串，就不能再改变它 12345678# 示例&gt;&gt;&gt; a = &quot;hello world&quot;&gt;&gt;&gt; a[4] = &quot;1&quot;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;str&#x27; object does not support item assignment&gt;&gt;&gt; id(a)140585442705648 级连字符串 如果把两个字符串相邻放着，它们会被python自动级连 1234# 示例&gt;&gt;&gt; info = &quot;chen&quot;&quot;peng&quot;&gt;&gt;&gt; info&#x27;chenpeng&#x27; 字符串常用方法 字符串常用方法——判断系列（True/False） 方法 功能 str.isdigit() 字符串中是否只包含数字 str.isnumeric() 字符串中是否只包含数字（包括中文一到九等） str.isalnum() 字符串中是否只包含字母或数字 str.istitle() 字符串中是否每个单词首字母大写，其他字母小写 str.isalpha() 字符串中是否只包含字母（汉字会算作字母） str.isupper() 字符串中是否全为大写 str.isidentifier() 字符串是否为合法标识符 str.isprintable() 字符串是否为可打印字符 str.islower() 字符串中是否全为小写 str.isspace() 字符串中是否只包含空格（tab也算空格） str.startswith(prefix[,start[,end]]) 字符串是否以某字符串开始，可以通过start和stop参数设置搜索范围 str.endswith(suffix[,start[,end]]) 字符串是否以某个字符串结束，可以通过start和stop参数设置搜索范围 12345678910111213141516171819# 示例my_str = &quot;This Is TEST!&quot;my_title = &quot;This is My Title&quot;my_num = &quot;123&quot;my_num2 = &quot;一二三四&quot;my_str2 = &quot;hello&quot;my_str3 = &quot;hello123&quot;# 判断系列print(&quot;判断数字&quot;, my_num.isdigit()) # 字符串中是否只包含数字print(&quot;判断数字&quot;, my_num.isnumeric()) # 字符串中是否只包含数字（包括中文一到九等）print(&quot;判断数字&quot;, my_num2.isdigit()) # 只能判断阿拉伯数字print(&quot;判断数字&quot;, my_num2.isnumeric()) # 可以判断中文数字print(&quot;判断字母：&quot;, my_str.isalpha()) # 有空格/“!”会报错 # 判断字母（汉字会算作字母）print(&quot;判断字母数字：&quot;, my_str3.isalnum()) # 有空格会报错 # 判断字母数字print(&quot;判断字符串是否以This开始&quot;, my_title.startswith(&quot;This&quot;))print(&quot;判断字符串是否以This结束&quot;, my_title.endswith(&quot;This&quot;)) ​ ​ 2. 字符串常用方法——查找统计类 方法 功能 len(string) 统计字符串长度 str.index(sub[,start[,end]]) 显示substring在字符串中第一次出现的下标位置，没有会报错 str.find(sub[,start[,end]]) 查找substring,找到返回其起始位置，找不到返回-1 12345678# 示例# 查找统计类my_str = &quot;This Is TEST!&quot;print(&quot;长度：&quot;, len(my_str)) # 空格、！占长度print(&quot;i 第一次出现的位置&quot;, my_str.index(&quot;i&quot;)) # 字符串“i”第一次出现的位置print(&quot;i 第一次出现的位置&quot;, my_str.find(&quot;i&quot;)) # 字符串“i”第一次出现的位置，找不到返回-1print(&quot;i 出现的次数&quot;, my_str.count(&quot;i&quot;)) ​ 3. 字符串常用方法——字符串转换类（返回一个新对象） 方法 功能 str.upper() 将字符串转换为大写 str.lower() 将字符串转换为小写 str.title() 将字符串中的单词首字母大写，其他字母小写 str.split(‘sep’) 指定’sep’作为分隔符将字符串切割成列表，分隔符可以是任意字符（默认是空格） ‘str’.join(list) 将列表用str拼接成一个大字符串 str.strip([string]) 去除字符串中首尾的字符串，不带参数默认去除空格 str.zfill(number) 返回指定长度的字符串，原字符串右对齐，前面填充0 str.replace(‘old’,‘new’[,count]) 用新的字符替换老字符，还可以指定替换的个数，默认全部替换 str.capitalize() 句子首字母大写 str.center(width[,fillchar])str.ljust(width[,fillchar])str.rjust(width[,fillchar]) 返回一个原字符串居中(靠左/靠右)对齐，width为总长度，两边用一个字符fillchar填充，如果指定的长度小于原字符串的长度则返回原字符串 str.expandtabs(number) 将\\t转换成number个空格 12345678910111213141516171819202122# 示例# 字符串转换类msg = &quot; hEllo World Chen &quot;print(&quot;大写&quot;, msg.upper())print(&quot;小写&quot;, msg.lower())print(&quot;标题&quot;, msg.title())msg2 = &quot;root:x:0:0:root:/root:/bin/bash&quot;print(&quot;切割：&quot;, msg2.split(&quot;:&quot;))msg3 = msg2.split(&quot;:&quot;)print(&quot;拼接：&quot;, &quot;#&quot;.join(msg3))print(&quot;去除首尾空白&quot;, msg.strip(), &quot;######&quot;)print(&quot;去除root首尾：&quot;, msg2.strip(&quot;root&quot;))print(&quot;字符串填充：&quot;, msg.zfill(40))print(&quot;字符串替换&quot;, msg2.replace(&quot;:&quot;, &quot;%&quot;))print(&quot;整个字符串首字母大写&quot;, msg.capitalize())msg4 = &quot;xxx&quot;print(msg4.center(50, &#x27; &#x27;))print(msg4.center(50, &#x27;-&#x27;))print(msg4.ljust(50, &quot;-&quot;))print(msg4.rjust(50, &quot;-&quot;)) 字符串拼接 12345678910# 示例# 字符串拼接（+）&gt;&gt;&gt; a = &#x27;I&#x27; + &#x27;Love&#x27; + &#x27;Python&#x27;&gt;&gt;&gt; print(a)ILovePython#字符串拼接（join）&gt;&gt;&gt; a = [&#x27;I&#x27;, &#x27;Love&#x27;, &#x27;Python&#x27;]&gt;&gt;&gt; print(&#x27;&#x27;.join(a))ILovePython 1234+ 与 join的效率问题 一般来说，+ 拼接 效率比 join 拼接低 +拼接，每一次出现都会在内存中开辟1个新的空间，所有效率低，比较耗时 join一次性拼接成1个大的字符串 字符串格式化 1234567字符串格式化（%）基本格式 %[(name)][flags][width].[precision]typecode -(name):命名 -flags:+,-,&#x27;&#x27;或0。+表示右对齐；-表示左对齐；&#x27;&#x27;为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐，0表示使用0填充 -width表示显示宽度 -precision表示小数点后精度 123456# 示例# %格式化 name = &quot;wen&quot;age = 18print(&quot;姓名： %s, 年龄： %s&quot;%(name, age))print(&quot;姓名： %s, 年龄： %s&quot;%(age, &quot;wen2&quot;)) 12字符串格式化(format) &#123;变量:[填充字符][对齐方式 &lt;^&gt;][宽度][格式]&#125; 123456789101112131415161718192021# 示例# format 格式化name = &quot;wen&quot;age = 18print(&quot;format01 --&gt; 姓名：&#123;&#125;， 年龄：&#123;&#125;&quot;.format(name, age))print(&quot;format01 --&gt; 姓名：&#123;&#125;， 年龄：&#123;&#125;&quot;.format(age, name))print(&quot;format02 --&gt; 姓名: &#123;1&#125;, 年龄：&#123;0&#125;&quot;.format(name, age))print(&quot;format02 --&gt; 姓名: &#123;1&#125;, 年龄：&#123;0&#125;&quot;.format(age, name))print(&quot;format03 --&gt; 姓名：&#123;name1&#125;, 年龄：&#123;age1&#125;&quot;.format(name1 = name, age1 = age))print(&quot;format01 --&gt; &#123;0:*&gt;10&#125;&quot;.format(10,20)) # 注：0 第1个变量print(&quot;format01 --&gt; &#123;1:*&gt;10&#125;&quot;.format(10,20)) # 注：1 第2个变量print(&quot;format01 --&gt; &#123;1:*&lt;10&#125;&quot;.format(10,20)) # 注：：执行 ; * 填充字符print(&quot;format01 --&gt; &#123;1:*^10&#125;&quot;.format(10,20)) # 注：^ 居中 ; 10 填充宽度10字符print(&quot;format02 --&gt; &#123;0:.2f&#125;&quot;.format(1/3,5.333))print(&quot;format02 --&gt; &#123;1:06.2f&#125;&quot;.format(1/3,5.333))# 二进制print(&quot;format02 --&gt; &#123;0:b&#125;&quot;.format(10))# 八进制 注：16进制是”&#123;0:x&#125;”.format(10)print(&quot;format02 --&gt; &#123;0:o&#125;&quot;.format(10))# 千分位格式化print(&quot;format02 --&gt; &#123;0:,&#125;&quot;.format(123456789)) 1字符串格式化-f 12345678910111213# 示例# f标志符 格式化a = &quot;I&quot;b = &quot;Love&quot;c = &quot;Python&quot;print(f&quot;&#123;a&#125;&#123;b&#125;&#123;c&#125;&quot;)#结果 ILovePythonprint(&quot;&#123;a&#125;&#123;b&#125;&#123;c&#125;&quot;.format(a = a, b = b, c = c)) # 注：效果等同#结果 ILovePythonprint(f&quot;&#123;a&#125;&#123;b&#125;&#123;c:a^10&#125;&quot;) # 注：对字符串c的操作：用“a”填充宽度10，居中#结果 ILoveaaPythonaaprint(&quot;&#123;a&#125;&#123;b&#125;&#123;c:a^10&#125;&quot;.format(a = a, b = b, c = c)) # 注：效果等同#结果 ILoveaaPythonaa Python数字-Booleans 1234567布尔值(Booleans)是一个逻辑值取值范围只有True和False(真和假)布尔值为假： &#x27;&#x27;,0,0.0,(),[],&#123;&#125;,None,False None是一个特殊的常量，表示一种特殊的数据类型（NoneType）值布尔值为真： 除了为假的，其他的都为真 12345678910111213# 示例* 布尔值可以相互加减&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; print(a == b)False&gt;&gt;&gt; c = (a == b) + (a == d) # 注：c = 0 +1&gt;&gt;&gt; c1# 布尔值排序&gt;&gt;&gt; lst=[(a==d),(a==b)] # 注：(a==d)为真，(a==b)为假&gt;&gt;&gt; sorted(lst)[False, True] # 注：因为默认情况下 0为假，1为真 Others 12345○常量 常量是指一旦初始化后就不能修改的固定值 注意：在Python中表示一个常量通常用大写（约定俗成，非强制）表示，如：PI=3.1415926○NoneType None表示什么也没有","categories":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"数据类型","slug":"数据类型","permalink":"https://blog1.cpen.top/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"01_Python-CSDN_环境搭建","slug":"Python_csdn/01_Python_环境搭建","date":"2022-09-28T04:00:00.000Z","updated":"2022-09-28T05:00:00.000Z","comments":true,"path":"posts/16756.html","permalink":"https://blog1.cpen.top/posts/16756.html","excerpt":"","text":"① Python解释器 安装 Windows平台 下载地址：https://www.python.org/ftp/python/3.9.5/python-3.9.5-amd64.exe（3.9版本） 安装python39 ​ exe安装：注意修改目录、环境变量 ​ 安装路径：C:/python39（安装路径可以自定，但注意不要包含中文或空格等特殊字符） ​ 验证：按键盘“win+R”，输入“cmd” , 在命令行测试 ​ C:\\Users\\cPenadm&gt;python -V ​ Python 3.9.5 Linux平台 自带python（不同版本的操作系统带的python版本不一样） centos-yum安装（3.6版本） 123yum install epel-releaseyum install python36yum install python36-devel ② pip工具 设置 pip是Python 包管理工具，该工具提供了对Python包的查找、下载、安装、卸载的功能。 配置国内源 解决安装慢的问题 方法 1 升级pip到10.0以上版本 1pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 方法 2 Windows平台 创建目录及文件 C:\\Users&lt;你的用户名&gt;\\pip\\pip.ini pip.ini文件内容如下：修改成阿里的源，其他国内源也可以 1234[global]index-url=http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com Linux平台 12345mkdir ~/.pipvim ~/.pip/pip.conf#输入以下内容[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple ③ PyCharm 安装 PyCharm是由JetBrains打造的一款PythonIDE，支持macOS、Windows、Linux系统 集成开发环境（IDE,IntegratedDevelopmentEnviroment）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具 优点：界面友好、调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制等 下载地址 官网：http://www.jetbrains.com/pycharm/ 安装 社区版：免费使用，不用激活 专业版：功能更丰富，需要激活 激活 打开pycharm，执行：Help-Register 配置Python解释器 参考：https://zhuanlan.zhihu.com/p/40716785","categories":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"环境","slug":"环境","permalink":"https://blog1.cpen.top/tags/%E7%8E%AF%E5%A2%83/"}]},{"title":"04_Django-模板变量/标签/过滤器/继承-url反向解析","slug":"Django/04_Django-模板变量-标签-过滤器-继承-url反向解析","date":"2022-09-27T04:00:00.000Z","updated":"2022-09-27T05:00:00.000Z","comments":true,"path":"posts/65154.html","permalink":"https://blog1.cpen.top/posts/65154.html","excerpt":"","text":"视频链接：https://www.bilibili.com/video/BV1vK4y1o7jH 一. 模板层 - 变量和标签 变量 视图函数中可以将Python变量封装到 字典 中传递到模板上 样例： 123456def xxx_view(request): dic = &#123; &quot;变量1&quot;: &quot;值1&quot;, &quot;变量2&quot;: &quot;值2&quot;, &#125; return render(request, &#x27;xxx.html&#x27;, dic) 能传递到模板中的 数据类型 1234str-字符串 int-整型list-数组 tuple-元组dict-字典 func-方法obj-类实例化的对象 在模板中使用变量语法 12345- &#123;&#123; 变量名 &#125;&#125;- &#123;&#123; 变量名.index &#125;&#125;- &#123;&#123; 变量名.key &#125;&#125;- &#123;&#123; 对象.方法 &#125;&#125;- &#123;&#123; 函数名 &#125;&#125; 演示： 1http://127.0.0.1:8000/test_html_param 12345678910111213141516171819202122232425262728293031323334353637# mysite1/mysite1/urls.pyurlpatterns = [ ... path(&#x27;test_html&#x27;, views.test_html)]# mysite1/mysite1/views.pydef test_html_param(request): dic = &#123;&#125; dic[&#x27;int&#x27;] = 88 dic[&#x27;str&#x27;] = &#x27;peng&#x27; dic[&#x27;lst&#x27;] = [&#x27;Tom&#x27;, &#x27;Jack&#x27;, &#x27;Lily&#x27;] dic[&#x27;dict&#x27;] = &#123;&#x27;a&#x27;:9, &#x27;b&#x27;:8&#125; dic[&#x27;func&#x27;] = say_hi dic[&#x27;class_obj&#x27;] = Dog() dic[&#x27;script&#x27;] = &#x27;&lt;script&gt;alert(1111)&lt;/script&gt;&#x27; return render(request, &#x27;test_html_param.html&#x27;, dic)def say_hi(): return &#x27;hahaha&#x27;class Dog: def say(self): return &#x27;wangwang&#x27;# mysite1/templates/test_html_param.html&lt;h3&gt;int 是 &#123;&#123; int|add:&quot;2&quot; &#125;&#125;&lt;/h3&gt;&lt;h3&gt;str 是 &#123;&#123; str|upper &#125;&#125;&lt;/h3&gt;&lt;h3&gt;lst 是 &#123;&#123; lst &#125;&#125;&lt;/h3&gt;&lt;h3&gt;lst 是 &#123;&#123; lst.0 &#125;&#125;&lt;/h3&gt;&lt;h3&gt;dict 是 &#123;&#123; dict &#125;&#125;&lt;/h3&gt;&lt;h3&gt;dict[&#x27;a&#x27;] 是 &#123;&#123; dict.a &#125;&#125;&lt;/h3&gt;&lt;h3&gt;function 是 &#123;&#123; func &#125;&#125;&lt;/h3&gt;&lt;h3&gt;class_obj 是 &#123;&#123; class_obj.say &#125;&#125;&lt;/h3&gt;&lt;h3&gt;script 是 &#123;&#123; script|safe &#125;&#125;&lt;/h3&gt; 标签 模板标签 作用：将一些服务器端的功能嵌入到模板中，例如流程控制等 标签语法： 123&#123;% 标签 %&#125;...&#123;% 结束标签 %&#125; if标签 语法： 123456789&#123;% if 条件表达式1 %&#125;...&#123;% elif 条件表达式2 %&#125;...&#123;% elif 条件表达式3 %&#125;...&#123;% else %&#125;...&#123;% endif %&#125; - 需要有结束标签 注意： if条件表达式里可以用的运算符 ==, !=, &lt;, &gt; , &lt;=, &gt;=, in, not in, is, is not, not、and、or 在if标记中使用实际括号是无效的语法。如果需要它们指示优先级，则应使用嵌套的if标记。 官方文档：https://docs.djangoproject.com/zh-hans/2.2/ref/templates/builtins/#if 演示： 1http://127.0.0.1:8000/test_if_for 1234567891011121314151617181920212223242526272829# mysite1/mysite1/urls.pyurlpatterns = [ ... path(&#x27;test_if_for&#x27;, views.test_if_for),]# mysite1/mysite1/views.pydef test_if_for(request): dic = &#123;&#125; dic[&#x27;x&#x27;] = 20 dic[&#x27;lst&#x27;] = [&#x27;Tom&#x27;, &#x27;Jack&#x27;, &#x27;Lily&#x27;] return render(request, &#x27;test_if_for.html&#x27;, dic)# mysite1/templates/test_if_for.html&#123;% if x &gt; 10 %&#125;今天天气很好&#123;% else %&#125;今天天气非常好&#123;% endif %&#125;&lt;br&gt;&#123;% for name in lst %&#125; &#123;% if forloop.first %&#125; &amp;&amp;&amp;&amp;&amp; &#123;% endif %&#125; &lt;p&gt; &#123;&#123; forloop.counter &#125;&#125; &#123;&#123; name &#125;&#125;&lt;/p&gt; &#123;% if forloop.last %&#125; ===== &#123;% endif %&#125;&#123;% empty %&#125; 当前没数据&#123;% endfor %&#125; 模板标签 - if标签 - 练习 写一个简单的计算器页面，能够在服务端进行简单加减乘除计算（需记录用户上次填写状态、下拉列表选择状态） 前端参考代码： 演示： 1http://127.0.0.1:8000/mycal 1234567891011121314151617181920212223242526272829303132333435363738394041424344# mysite1/mysite1/urls.pyurlpatterns = [ ... path(&#x27;mycal&#x27;, views.test_mycal),]# mysite1/mysite1/views.pydef test_mycal(request): if request.method == &#x27;GET&#x27;: return render(request, &#x27;mycal.html&#x27;) elif request.method == &#x27;POST&#x27;: #处理计算 x = int(request.POST[&#x27;x&#x27;]) y = int(request.POST[&#x27;y&#x27;]) op = request.POST[&#x27;op&#x27;] result = 0 if op == &#x27;add&#x27;: result = x + y elif op == &#x27;sub&#x27;: result = x - y elif op == &#x27;mul&#x27;: result = x * y elif op == &#x27;div&#x27;: result = x / y #dic=&#123;&#x27;x&#x27;:x, &#x27;y&#x27;:y, &#x27;op&#x27;:op&#125; return render(request, &#x27;mycal.html&#x27;, locals()) # locals方法-局部变量直接封装成字典（Python自带方法）# mysite1/templates/mycal.html&lt;form action=&#x27;/mycal&#x27; method=&#x27;post&#x27;&gt; &lt;input type=&#x27;text&#x27; name=&quot;x&quot; value=&quot;&#123;&#123; x &#125;&#125;&quot;&gt; &lt;select name=&#x27;op&#x27;&gt; &lt;option value=&quot;add&quot; &#123;% if op == &#x27;add&#x27; %&#125;selected&#123;% endif %&#125; &gt; +加&lt;/option&gt; # ☆ 记录op状态，option selected属性，使用了if标签 &lt;option value=&quot;sub&quot; &#123;% if op == &#x27;sub&#x27; %&#125;selected&#123;% endif %&#125;&gt; -减&lt;/option&gt; &lt;option value=&quot;mul&quot; &#123;% if op == &#x27;mul&#x27; %&#125;selected&#123;% endif %&#125;&gt; *乘&lt;/option&gt; &lt;option value=&quot;div&quot; &#123;% if op == &#x27;div&#x27; %&#125;selected&#123;% endif %&#125;&gt; /除&lt;/option&gt; &lt;/select&gt; &lt;input type=&#x27;text&#x27; name=&quot;y&quot; value=&quot;&#123;&#123; y &#125;&#125;&quot;&gt; = &lt;span&gt;&#123;&#123; result &#125;&#125;&lt;/span&gt; &lt;div&gt;&lt;input type=&quot;submit&quot; value=&#x27;开始计算&#x27;&gt;&lt;/div&gt;&lt;/form&gt; for标签 语法： 12345&#123;% for 变量 in 可迭代对象 %&#125; ... 循环语句&#123;% empty %&#125; ... 可迭代对象无数据时填充的语句&#123;% endfor %&#125; 官方文档：https://docs.djangoproject.com/zh-hans/2.2/ref/templates/builtins/#for 内置变量 - forloop 演示： 1http://127.0.0.1:8000/test_if_for 1234567891011121314151617181920# mysite1/mysite1/urls.pyurlpatterns = [ ... path(&#x27;test_if_for&#x27;, views.test_if_for),]# mysite1/mysite1/views.pydef test_if_for(request): dic = &#123;&#125; dic[&#x27;lst&#x27;] = [&#x27;Tom&#x27;, &#x27;Jack&#x27;, &#x27;Lily&#x27;] return render(request, &#x27;test_if_for.html&#x27;, dic)# mysite1/templates/test_if_for.html&#123;% for name in lst %&#125; &#123;% if forloop.first %&#125; &amp;&amp;&amp;&amp;&amp; &#123;% endif %&#125; &lt;p&gt; &#123;&#123; forloop.counter &#125;&#125; &#123;&#123; name &#125;&#125;&lt;/p&gt; &#123;% if forloop.last %&#125; ===== &#123;% endif %&#125;&#123;% empty %&#125; 当前没数据&#123;% endfor %&#125; 小节 变量调用 - 点大法 标签语法 {% 标签 %} {% 结束标签 %} 二. 模板层 - 过滤器和继承 过滤器 定义：在变量输出时对变量的值进行处理 作用：可以通过使用 过滤器 来改变变量的输出显示 语法：**{{ 变量 | 过滤器1:'参数1' | 过滤器2:'参数2' ... }}** 官方文档：https://docs.djangoproject.com/zh-hans/2.2/ref/templates/builtins/ 常用过滤器： 演示： 1http://127.0.0.1:8000/test_html_param 1234567891011121314151617181920212223242526# mysite1/mysite1/urls.pyurlpatterns = [ ... path(&#x27;test_html&#x27;, views.test_html)]# mysite1/mysite1/views.pydef test_html_param(request): dic = &#123;&#125; dic[&#x27;int&#x27;] = 88 dic[&#x27;script&#x27;] = &#x27;&lt;script&gt;alert(1111)&lt;/script&gt;&#x27; return render(request, &#x27;test_html_param.html&#x27;, dic)def say_hi(): return &#x27;hahaha&#x27;class Dog: def say(self): return &#x27;wangwang&#x27;# mysite1/templates/test_html_param.html&lt;h3&gt;int 是 &#123;&#123; int|add:&quot;2&quot; &#125;&#125;&lt;/h3&gt;&lt;h3&gt;str 是 &#123;&#123; str|upper &#125;&#125;&lt;/h3&gt;&lt;h3&gt;script 是 &#123;&#123; script|safe &#125;&#125;&lt;/h3&gt; 继承 模板的继承 ​ 如下样例： 模板继承可以使父模板的内容重用，子模板直接继承父模板的全部内容并可以覆盖父模板中相应的块 语法 - 父模板中： 定义父模板中的**块 block **标签 表时出哪些在子模块中是允许被修改的 block 标签：在父模板中定义，可以在子模板中覆盖 语法 - 子模板中： 继承模板 extends 标签（写在模板文件的第一行） 例如 &#123;% extends 'base.html' %&#125; 子模板 重写父模板中的内容块 123&#123;% block block_name %&#125;子模板块用来覆盖父模板中 block_name 块的内容&#123;% endblock block_name %&#125; - block_name 可写可不写 重写的覆盖规则 不重写，将按照父模板中的效果显示 重写，则按照重写效果显示 注意 模板继承时，服务器端的动态内容无法继承 演示： 1http://127.0.0.1:8000/base_index 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# mysite1/mysite1/urls.pyurlpatterns = [ ... path(&#x27;base_index&#x27;, views.base_view, name=&#x27;base_index&#x27;), path(&#x27;music_index&#x27;, views.music_view), path(&#x27;sport_index&#x27;, views.sport_view),]# mysite1/mysite1/views.pydef base_view(request): lst = [&#x27;Tom&#x27;, &#x27;Jack&#x27;] return render(request, &#x27;base.html&#x27;, locals())def music_view(request): return render(request, &#x27;music.html&#x27;)def sport_view(request): return render(request, &#x27;sport.html&#x27;)#-------------------------------------------------------------# mysite1/templates/base.html # 父模板&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &#123;% block mytitle %&#125; &lt;title&gt;主页&lt;/title&gt; # 子模板能改的地方 &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt;&#123;&#123; lst &#125;&#125; # 子模板无法继承变量（动态内容）&lt;a href=&quot;/music_index&quot;&gt;音乐频道&lt;/a&gt; # 子模板不能改&lt;a href=&quot;/sport_index&quot;&gt;体育频道&lt;/a&gt;&lt;br&gt;&#123;% block info %&#125; 这是主页 # 子模板能改的地方&#123;% endblock %&#125;&lt;br&gt;&lt;h3&gt;有任何问题联系xxxx&lt;/h3&gt; # 子模板不能改# mysite1/templates/music.html # 子模板&#123;% extends &#x27;base.html&#x27; %&#125; # 继承父模板&#123;% block mytitle %&#125; &lt;title&gt;音乐频道&lt;/title&gt; # 子模板重写block&#123;% endblock %&#125;&#123;% block info %&#125; 欢迎来到音乐频道&#123;% endblock %&#125;# mysite1/templates/sport.html&#123;% extends &#x27;base.html&#x27; %&#125;&#123;% block mytitle %&#125; &lt;title&gt;体育频道&lt;/title&gt;&#123;% endblock %&#125;&#123;% block info %&#125; 欢迎来到体育频道&#123;% endblock %&#125; 小节 过滤器 { 变量 | 过滤器1:‘参数值1’ | 过滤器2:‘参数值2’ … } 模板的继承 父模板 - 定义可被修改的block 子模板 - 继承父模板；按需修改父模板中定义的block 三. url反向解析 代码中 url 出现位置 模板 【html中】 &lt;a href=‘url’&gt;超链接&lt;/a&gt; 点击后 页面跳转至 url &lt;form action=‘url’ method=‘post’&gt; form表单中的数据 用post方法提交至 url 视图函数中 - 302跳转 HttpResponseRedirect(‘url’) 将用户地址栏中的地址跳转到 url 代码中 url 书写规范 绝对地址 ​ http://127.0.0.1:8000/page/1 相对地址 ‘==/==page/1’ - ‘/’ 开头的相对地址，浏览器会把当前地址栏里的 协议，ip 和 端口 加上这个地址，作为最终访问地址，即如果当前页面地址栏为 http://127.0.0.1:8000/page/3；当前相对地址最终结果为 http://127.0.0.1:8000 + /page/1 （☆ 高频使用） ‘page/1’ - 没有 ‘/’ 开头的相对地址，浏览器会根据当前 url 的最后一个 / 之前的内容 加上 该相对地址 作为最终访问地址，例如当前地址栏地址为 ==http://127.0.0.1:8000/topic/==detail；则该相对地址最终结果为 http://127.0.0.1:8000/topic/ + page/1 演示： 1http://127.0.0.1:8000/test/url 12345678910111213141516171819202122# mysite1/mysite1/urls.pyurlpatterns = [ ... # http://127.0.0.1:8000/test/url path(&#x27;test/url&#x27;, views.test_url), path(&#x27;test_url_result&#x27;, views.test_url_result)]# mysite1/mysite1/views.pydef test_url(request): return render(request, &#x27;test_url.html&#x27;)def test_url_result(request): return HttpResponse(&#x27;---test url res is ok&#x27;)# mysite1/templates/test_url.html&lt;a href=&quot;http://127.0.0.1:8000/test_url_result&quot;&gt;绝对地址&lt;/a&gt;&lt;a href=&quot;/test_url_result&quot;&gt;带&#x27;/&#x27;的相对地址&lt;/a&gt;&lt;a href=&quot;test_url_result&quot;&gt;不带&#x27;/&#x27;的相对地址&lt;/a&gt; # 浏览器解析为 http://127.0.0.1:8000/test/test_url_result url 反向解析 url 反向解析是指在视图或者模板中，用 path 定义的名称来动态查找或计算出相应的路由 path 函数的语法 path(route, views, name=“别名”) path(‘page’, views.page_view, name=“page_url”) 根据 path 中的 ‘name=’ 关键字传给 url 确定了个唯一确定的名字，在模板或视图中，可以通过这个名字反向推断出此 url 信息 模板中 - 通过 url 标签实现地址的反向解析 12345&#123;% url &#x27;别名&#x27; %&#125;&#123;% url &#x27;别名&#x27; &#x27;参数值1&#x27; &#x27;参数值2&#x27; %&#125;ex:&#123;% url &#x27;pagen&#x27; &#x27;400&#x27; %&#125; --- 传参一律是 str&#123;% url &#x27;person&#x27; age=&#x27;18&#x27; name=&#x27;gxn&#x27; %&#125; 演示：在模板中使用 1http://127.0.0.1:8000/test/url 123456789101112131415161718# mysite1/mysite1/urls.pyurlpatterns = [ ... # http://127.0.0.1:8000/test/url path(&#x27;test/url&#x27;, views.test_url), path(&#x27;test_urls_result/&lt;int:age&gt;&#x27;, views.test_url_result, name=&#x27;tr&#x27;) # 起别名 tr]# mysite1/mysite1/views.pydef test_url(request): return render(request, &#x27;test_url.html&#x27;)def test_urls_result(request): return HttpResponse(&#x27;---test url res is ok&#x27;)# mysite1/templates/test_url.html&lt;a href=&quot;&#123;% url &#x27;tr&#x27; &#x27;100&#x27; %&#125;&quot;&gt;url反向解析版本&lt;/a&gt; # ☆ 模板中使用别名 在视图函数中 → 可调用 django 中的 reverse 方法进行反向解析 1234567from django.urls import reversereverse(&#x27;别名&#x27;, args=[], kwargs=&#123;&#125;)ex:print(reverse(&#x27;pagen&#x27;, args=[300]))print(reverse(&#x27;person&#x27;, kwargs=&#123;&#x27;name&#x27;:&#x27;peng&#x27;, &#x27;age&#x27;:23&#125;)) 演示： 123http://127.0.0.1:8000/test/url# 302跳转 - 响应头里的 location 标记跳转地址 1234567891011121314151617181920212223242526272829303132# mysite1/mysite1/urls.pyurlpatterns = [ ... path(&#x27;base_index&#x27;, views.base_view, name=&#x27;base_index&#x27;), # 起别名 base_index # http://127.0.0.1:8000/test/url path(&#x27;test/url&#x27;, views.test_url), path(&#x27;test_urls_result/&lt;int:age&gt;&#x27;, views.test_url_result, name=&#x27;tr&#x27;) # 起别名 tr]# mysite1/mysite1/views.pydef base_view(request): lst = [&#x27;Tom&#x27;, &#x27;Jack&#x27;] return render(request, &#x27;base.html&#x27;, locals())def test_url(request): return render(request, &#x27;test_url.html&#x27;)def test_url_result(request, age): #302跳转 from django.urls import reverse url = reverse(&#x27;base_index&#x27;) # ☆ 视图函数中使用别名 return HttpResponseRedirect(url)#---------------------------------------------------------------# mysite1/templates/test_url.html&lt;a href=&quot;&#123;% url &#x27;tr&#x27; &#x27;100&#x27; %&#125;&quot;&gt;url反向解析版本&lt;/a&gt;# mysite1/templates/base.html略 四. 总结 请求（request）和响应（HttpResponseqing） GET/POST处理 - request.GET/POST MVC 和 MTV 模板层基础配置 模板变量/标签/过滤器/继承 url反向解析","categories":[{"name":"Django","slug":"Django","permalink":"https://blog1.cpen.top/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://blog1.cpen.top/tags/Django/"},{"name":"URL","slug":"URL","permalink":"https://blog1.cpen.top/tags/URL/"}]},{"title":"03_Django-GET请求和POST请求-设计模式及模板层","slug":"Django/03_Django-GET请求和POST请求-设计模式及模板层","date":"2022-09-26T04:00:00.000Z","updated":"2022-09-26T05:00:00.000Z","comments":true,"path":"posts/42935.html","permalink":"https://blog1.cpen.top/posts/42935.html","excerpt":"","text":"视频链接：https://www.bilibili.com/video/BV1vK4y1o7jH 一. GET请求和POST请求 定义 ·无论是GET还是POST，统一都由视图函数接收请求，通过判断request.method区分具体的请求动作 ·样例： 123456if requests.method == &#x27;GET&#x27;: 处理GET请求时的业务逻辑elif requests.method == &#x27;POST&#x27;: 处理POST请求的业务逻辑else: 其他请求业务逻辑 ------------------------------------------------------------------ 123456789101112演示 &lt;项目同名文件夹下&gt;/views.pydef test_get_post(request): if request.method == &#x27;GET&#x27;: pass elif request.method == &#x27;POST&#x27;: #处理用户提交数据 pass else: pass return HttpResponse(&#x27;--test get post is ok--&#x27;) GET处理 ·GET请求动作，一般用于向服务器获取数据 ·能够产生GET请求的场景： ​ - 浏览器地址栏中输入URL，回车后 ​ - &lt;a href=“地址?参数=值&amp;参数=值”&gt; ​ - form表单中的method为get ------------------------------------------------------------------ GET请求方式中，如果有数据需要传递给服务器，通常会用查询字符串（Query String）传递【注意：不要传递敏感数据】 URL格式：xxx?参数名1=值1&amp;参数名2=值2... - 如：http://127.0.0.1:8000/page1`?a=100&amp;b=200` 服务器端接收参数 获取客户端请求GET请求提交的数据 ·方法示例： 1234567request.GET[&#x27;参数名&#x27;] # QueryDictrequest.GET.get(&#x27;参数名&#x27;, &#x27;默认值&#x27;)request.GET.getlist(&#x27;参数名&#x27;)# mypage?a=100&amp;b=200&amp;c=300&amp;b=400# request.GET=QueryDict(&#123;&#x27;a&#x27;: [&#x27;100&#x27;], &#x27;b&#x27;: [&#x27;200&#x27;, &#x27;400&#x27;], &#x27;c&#x27;: [&#x27;300&#x27;]&#125;)# a = request.GET[&#x27;a&#x27;]# b = request.GET[&#x27;b&#x27;] # Error ------------------------------------------------------------------ 123456789101112131415161718192021222324252627282930演示http://127.0.0.1:8000/test_get_post?a=400--test get post is ok--终端&lt;QueryDict: &#123;&#x27;a&#x27;: [&#x27;400&#x27;, &#x27;200&#x27;, &#x27;100&#x27;]&#125;&gt;100[&#x27;400&#x27;, &#x27;200&#x27;, &#x27;100&#x27;]no c &lt;项目同名文件夹下&gt;/urls.pyurlpatterns = [ ... path(&#x27;test_get_post&#x27;, views.test_get_post)] &lt;项目同名文件夹下&gt;/views.pydef test_get_post(request): if request.method == &#x27;GET&#x27;: print(request.GET) print(request.GET[&#x27;a&#x27;]) # 问卷调查 = form get 兴趣爱好 - 复选框 print(request.GET.getlist(&#x27;a&#x27;)) print(request.GET.get(&#x27;c&#x27;, &#x27;no c&#x27;)) elif request.method == &#x27;POST&#x27;: #处理用户提交数据 pass else: pass return HttpResponse(&#x27;--test get post is ok--&#x27;) ------------------------------------------------------------------ ·思考：之前的计算器功能，能否拿查询字符串做？ ​ http://127.0.0.1:8000/整数/操作符/整数 ​ http://127.0.0.1:8000/cal?x=10&amp;y=20&amp;op=add POST处理 ·POST请求动作，一般用于向服务器提交大量/隐私数据 ·客户端通过表单等POST请求将数据传递给服务器端，如： ·服务器端接收参数 ​ 通过request.method来判断是否为POST请求，如： 1234if request.method == &#x27;POST&#x27;: 处理POST请求的数据并响应else: 处理非POST请求的响应 ------------------------------------------------------------------ 使用post方式接收客户端数据 123request.POST[&#x27;参数名&#x27;] # request.POST 绑定QueryDictrequest.POST.get(&#x27;参数名&#x27;, &#x27;&#x27;)request.POST.getlist(&#x27;参数名&#x27;) 取消csrf验证，否则Django将会拒绝客户端发来的POST请求，报403响应 ------------------------------------------------------------------ 取消csrf验证 ​ - 禁止掉settings.py中MIDDLEWARE中的CsrfviewsMiddleWare的中间件 12345MIDDLEWARE = [ ... # &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;, ...] ------------------------------------------------------------------ 演示 http://127.0.0.1:8000/test_get_post 123456789101112131415161718192021post is ok终端uname is cpen &lt;项目同名文件夹下&gt;/urls.pyurlpatterns = [ ... path(&#x27;test_get_post&#x27;, views.test_get_post)] &lt;项目同名文件夹下&gt;/views.pyPOST_FORM = &#x27;&#x27;&#x27;&lt;form method=&#x27;post&#x27; action=&#x27;/test_get_post&#x27;&gt; 用户名: &lt;input type=&#x27;text&#x27; name=&#x27;uname&#x27;&gt; &lt;input type=&#x27;submit&#x27; value=&#x27;提交&#x27;&gt;&lt;/form&gt;&#x27;&#x27;&#x27;def test_get_post(request): if request.method == &#x27;GET&#x27;: return HttpResponse(POST_FORM) ... --------------------------------------------------------------------------------------------------------------------------------- 小节 ·Django处理GET请求 ​ 查询字符串 - 少量数据传递 ·Django处理POST请求 ​ 专用于浏览器提交数据 二. Django的设计模式及模板层 MVC和MTV 传统的MVC MVC代表Model-View-Controller（模型-视图-控制器）模式。 M模型层（Model），主要用于对数据库层的封装 V视图层（View），用于向用户展示结果（WHAT + HOW） C控制（Controller），用于处理请求、获取数据、返回结果（重要） 作用：降低模块间的耦合度（解耦） Django的MTV模式 MTV代表Model-Template-View（模型-模板-视图）模式。 M模型层（Model）负责与数据库交互 T模板层（Template）负责呈现内容到浏览器（HOW） V视图层（View）是核心，负责接收请求、获取数据、返回结果（WHAT） 作用：降低模块间的耦合度（解耦） --------------------------------------------------------------------------------------------------------------------------------- 模板层 什么是模板 1、模板是可以根据字典数据动态变化的html网页 2、模板可以根据视图中传递的字典数据动态生成相应的HTML网页 模板配置 创建模板文件夹 &lt;项目名&gt;/templates 在settings.py中TEMPLATES配置项 ​ 1.BACKEND：指定模板的引擎 ​ 2.DIRS：模板的搜索目录（可以是一个或多个） ​ 3.APP_DIRS：是否要在应用中的templates文件夹中搜索模板文件 ​ 4.OPTIONS：有关模板的选项 ·配置项中 需要修改部分 ​ 设置DIRS - 'DIRS': [os.path.join(BASE_DIR, 'templates')], ------------------------------------------------------------------ 演示 1234567 &lt;项目同名文件夹下&gt;/settings.pyTEMPLATES = [ &#123; ... &#x27;DIRS&#x27;: [os.path.join(BASE_DIR, &#x27;templates&#x27;)], ... 模板的加载方式 方案1 - 通过loader获取模板，通过HttpResponse进行响应（特点：麻烦） 在视图函数中： 1234567from django.template import loader# 1.通过 loader 加载模板t = loader.get_template(&quot;模板文件名&quot;)# 2.将 t 转换成 HTML 字符串html = t.reader(字典数据)# 3.用响应对象将转换的字符串内容返回给浏览器return HttpResponse(html) -------------------------------------------------------------------------------------- 演示 http://127.0.0.1:8000/test_html 123456789101112131415 &lt;项目同名文件夹下&gt;/urls.pyurlpatterns = [ ... path(&#x27;test_html&#x27;, views.test_html)] &lt;项目同名文件夹下&gt;/views.pydef test_html(request): from django.template import loader t = loader.get_template(&#x27;test_html.html&#x27;) html = t.render() return HttpResponse(html) &lt;项目文件夹下&gt;/templates/test_html.html&lt;h3&gt;我是模板层的~~~~&lt;/h3&gt; --------------------------------------------------------------------------------------------------------------------------------- 方案2 - 通过render() 直接加载并响应模板（特点：方便，大量使用这种） 在视图函数中： 12from django.shortcuts import renderreturn render(request, &#x27;模板文件名&#x27;, 字典数据) -------------------------------------------------------------------------------------- 演示 http://127.0.0.1:8000/test_html 12345 &lt;项目同名文件夹下&gt;/views.pydef test_html(request): # 方案2 from django.shortcuts import render return render(request, &#x27;test_html.html&#x27;) 视图层与模板层之间的交互 1、视图函数中可以将Python变量封装到字典中传递到模板 样例： def xxx_view(request): dic = { “变量1”: “值1”, “变量2”: “值2”, } return render(request, ‘xxx.html’, dic) 2、模板中，我们可以用 的语法 调用视图传进来的变量 -------------------------------------------------------------------------------------- 演示 http://127.0.0.1:8000/test_html 1234567891011121314 &lt;项目同名文件夹下&gt;/urls.pyurlpatterns = [ ... path(&#x27;test_html&#x27;, views.test_html)] &lt;项目同名文件夹下&gt;/views.pydef test_html(request): from django.shortcuts import render dic = &#123;&#x27;username&#x27;: &#x27;peng&#x27;, &#x27;age&#x27;: 23&#125; return render(request, &#x27;test_html.html&#x27;, dic) &lt;项目文件夹下&gt;/templates/test_html.html&lt;h3&gt;&#123;&#123; username &#125;&#125;是模板层的~~~~&lt;/h3&gt;","categories":[{"name":"Django","slug":"Django","permalink":"https://blog1.cpen.top/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://blog1.cpen.top/tags/Django/"},{"name":"MTV","slug":"MTV","permalink":"https://blog1.cpen.top/tags/MTV/"},{"name":"HTTP","slug":"HTTP","permalink":"https://blog1.cpen.top/tags/HTTP/"},{"name":"GET","slug":"GET","permalink":"https://blog1.cpen.top/tags/GET/"},{"name":"POST","slug":"POST","permalink":"https://blog1.cpen.top/tags/POST/"},{"name":"MVC","slug":"MVC","permalink":"https://blog1.cpen.top/tags/MVC/"}]},{"title":"02_Django-路由配置-HTTP协议的请求和响应","slug":"Django/02_Django-路由配置-HTTP协议的请求和响应","date":"2022-09-25T04:00:00.000Z","updated":"2022-09-25T05:00:00.000Z","comments":true,"path":"posts/57095.html","permalink":"https://blog1.cpen.top/posts/57095.html","excerpt":"","text":"视频链接：https://www.bilibili.com/video/BV1vK4y1o7jH 一. 路由配置 settings.py中的 `ROOT_URLCONF` 指定了主路由配置列表 urlpatterns 的文件位置 12345# file: &lt;项目同名文件夹下&gt;/urls.pyurlpatterns = [ path(&#x27;page/2003/&#x27;, views.page_2003_view), ... # 此处配置主路由] path() path()函数 path()函数 导入 - from django.urls import path 语法 - path(route, views, name=None) 参数: ​ 1.route: 字符串类型，匹配的请求路径 ​ 2.views: 指定路径所对应的视图处理函数的名称 ​ 3.name: 为地址起 别名，在模块中地址反向解析时使用 练习 - 建立一个小网站： ​ 输入网址：http://127.0.0.1:8000, 在网页中输出：这是我的首页 ​ 输入网址：http://127.0.0.1:8000/page/1, 在网页中输出：这是编号为1的网页 ​ 输入地址：http://127.0.0.1:8000/page/2, 在网页中输出：这是编号为2的网页 123http://127.0.0.1:8000http://127.0.0.1:8000/page/1http://127.0.0.1:8000/page/2 12345678910111213141516171819202122 &lt;项目同名文件夹下&gt;/urls.pyurlpatterns = [ #http://127.0.0.1:8000 path(&#x27;&#x27;, views.index_view), #http://127.0.0.1:8000/page/1 path(&#x27;page/1&#x27;, views.page1_view), #http://127.0.0.1:8000/page/2 path(&#x27;page/2&#x27;, views.page2_view)] &lt;项目同名文件夹下&gt;/views.pydef index_view(request): html = &#x27;这是我的首页&#x27; return HttpResponse(html)def page1_view(request): html = &#x27;这是编号为1的网页&#x27; return HttpResponse(html)def page2_view(request): html = &#x27;这是编号为2的网页&#x27; return HttpResponse(html) 思考 建立如上一百个网页该怎么办？ 例如： ​ http://127.0.0.1:8000/page/3 ​ http://127.0.0.1:8000/page/4 ​ … ​ http://127.0.0.1:8000/page/100 path转换器 语法：&lt;转换器类型: 自定义名&gt; 作用：若转换器类型匹配到对应类型的数据，则将数据按照关键字传参的方式传递给视图函数 例子：path(‘page/&lt;int:page&gt;’, view.xxx) 转换器类型：str、int、slug、path 123456789101112http://127.0.0.1:8000/page/30 &lt;项目同名文件夹下&gt;/urls.pyurlpatterns = [ #http://127.0.0.1:8000/page/3-100 path(&#x27;page/&lt;int:pg&gt;&#x27;, views.pagen_view)] &lt;项目同名文件夹下&gt;/views.pydef pagen_view(request, pg): html = &#x27;这是编号为%s的网页!&#x27;%(pg) return HttpResponse(html) 练习：小计算器 ​ 定义一个路由的格式为： ​ ==http://127.0.0.1:8000/整数/操作字符串[add/sub/mul]/整数== ​ 从路由中提取数据，做相应的操作后返回给浏览器 ​ 效果如下： ​ 输入：127.0.0.1:8000/100/add/200 ​ 页面显示结果：300 123456789101112131415161718192021http://127.0.0.1:8000/100/add/200结果为：300 &lt;项目同名文件夹下&gt;/urls.pyurlpatterns = [ #http://127.0.0.1:8000/整数/操作符/整数 path(&#x27;&lt;int:n&gt;/&lt;str:op&gt;/&lt;int:m&gt;&#x27;, views.cal_view)] &lt;项目同名文件夹下&gt;/views.pydef cal_view(request, n, op, m): if op not in [&#x27;add&#x27;, &#x27;sub&#x27;, &#x27;mul&#x27;]: return HttpResponse(&#x27;Your op is wrong&#x27;) result = 0 if op == &#x27;add&#x27;: result = n + m elif op == &#x27;sub&#x27;: result = n - m elif op == &#x27;mul&#x27;: result = n * m return HttpResponse(&#x27;结果为：%s&#x27;%(result)) re_path() re_path()函数 re_path()函数 在 url 的匹配过程中可以使用正则表达式进行精确匹配 语法： ​ re_path(reg, view, name=xxx) ​ 正则表达式为命名分组模式(**?P&lt;name&gt;**pattern); 匹配提取参数后用关键字传参方式传递给视图函数 123456789101112131415161718样例# 可匹配 http://127.0.0.1:8000/20/mul/40# 不可匹配 http://127.0.0.1:8000/200/mul/400http://127.0.0.1:8000/10/add/20 -&gt; x:10 op:add y:20 &lt;项目同名文件夹下&gt;/urls.pyfrom django.urls import path, re_pathurlpatterns = [ #http://127.0.0.1:8000/整数2/操作符/整数2 re_path(r&#x27;^(?P&lt;x&gt;\\d&#123;1,2&#125;)/(?P&lt;op&gt;\\w+)/(?P&lt;y&gt;\\d&#123;1,2&#125;)$&#x27;, views.cal2_view),] # \\d 整数; \\w 字符 &lt;项目同名文件夹下&gt;/views.pydef cal2_view(request, x, op, y): html = &#x27;x:%s op:%s y:%s&#x27;%(x, op, y) return HttpResponse(html) 练习 访问地址： ​ http://127.0.0.1:8000/birthday/四位数字/一到两位数字/一到两位数字 ​ http://127.0.0.1:8000/birthday/一到两位数字/一到两位数字/四位数字 最终输出：生日为：xxxx年xx月xx日 效果样例： ​ 输入网址：http://127.0.0.1:8000/birthday/2015/12/11 ​ 显示为：生日为：2015年12月11日 ​ 输入网址：http://127.0.0.1:8000/birthday/2/28/2008 ​ 显示为：生日为：2008年2月28日 123456789101112131415http://127.0.0.1:8000/birthday/1992/01/01生日为1992年01月01日 &lt;项目同名文件夹下&gt;/urls.pyurlpatterns = [ #http://127.0.0.1:8000/birthday/年4/月2/日2 re_path(r&#x27;^birthday/(?P&lt;y&gt;\\d&#123;4&#125;)/(?P&lt;m&gt;\\d&#123;1,2&#125;)/(?P&lt;d&gt;\\d&#123;1,2&#125;)$&#x27;, views.birthday_view), #http://127.0.0.1:8000/birthday/月2/日2/年4 re_path(r&#x27;^birthday/(?P&lt;m&gt;\\d&#123;1,2&#125;)/(?P&lt;d&gt;\\d&#123;1,2&#125;)/(?P&lt;y&gt;\\d&#123;4&#125;)$&#x27;, views.birthday_view),] &lt;项目同名文件夹下&gt;/views.pydef birthday_view(request, y, m, d): html = &quot;生日为%s年%s月%s日&quot;%(y, m, d) return HttpResponse(html) Django Day02 请求和响应 GET请求和POST请求 Django的设计模式及模板层 模板层 - 变量和标签 模板层 - 过滤器和继承 url反向解析 二. HTTP协议的请求和响应 定义 ​ 请求是指浏览器端通过HTTP协议发送给服务器端的数据 ​ 响应是指服务器端接收到请求后做相应的处理后再回复给浏览器端的数据 请求 请求样例 请求样例 请求中的方法 根据HTTP标准，HTTP请求可以使用多种请求方法 HTTP1.0定义了三种请求方法：GET，POST和HEAD方法（最常用） HTTP1.1新增了五种请求方法：OPTIONS，PUT，DELETE，TRACE和CONNECT方法 Django中的请求 请求在Django中实则就是 视图函数的第一个参数，即HttpRequest对象 Django接收到http协议的请求后，会根据请求数据报文创建HttpRequest对象 HttpRequest对象 通过属性 描述了 请求的 所有相关信息 ·path_info：URL字符串 ·method：字符串，表示HTTP请求方法，常用值：`GET`、`POST` ·GET：QueryDict查询字典的对象，包含get请求方法的所有数据 ·POST：QueryDict查询字典的对象，包含post请求方式的所有数据 ·FILES：类似于字典的对象，包含所有的上传文件信息 ·COOKIES：Python字典，包含所有的cookie，键和值都为字符串 ·session：似于字典的对象，表示当前的会话 ·body：字符串，请求体的内容（POST或PUT） ·scheme：请求协议（‘http’/‘https’） ·request.get_full_path()：请求的完整路径 ·request.META：请求中的元数据（消息头） ​ - request.META[‘REMOTE_ADDR’]：客户端IP地址 123456789101112131415161718192021http://127.0.0.1:8000/test_request?a=1&amp;b=1test request ok终端path info is /test_requestmethod is GETquerystring is &lt;QueryDict: &#123;&#x27;a&#x27;: [&#x27;1&#x27;], &#x27;b&#x27;: [&#x27;1&#x27;]&#125;&gt;full path is /test_request?a=1&amp;b=1[20/Dec/2021 23:27:09] &quot;GET /test_request?a=1&amp;b=1 HTTP/1.1&quot; 200 15 &lt;项目同名文件夹下&gt;/urls.pyurlpatterns = [ path(&#x27;test_request&#x27;, views.test_request)] &lt;项目同名文件夹下&gt;/views.pydef test_request(request): print(&#x27;path info is&#x27;, request.path_info) print(&#x27;method is&#x27;, request.method) print(&#x27;querystring is&#x27;, request.GET) print(&#x27;full path is&#x27;, request.get_full_path()) return HttpResponse(&#x27;test request ok&#x27;) 响应 响应样例 响应样例 响应状态码 HTTP状态码的英文为HTTP Status Code 下面是常见的HTTP状态码： - 200 - 请求成功 - 301 - 永久重定向-资源（网页等）被永久转移到其它URL - 302 - 临时重定向 - 404 - 请求的资源（网页等）不存在 - 500 - 内部服务器错误 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： Django中的响应对象 构造函数格式： ​ HttpResponse(content=响应体, content_type=响应体数据类型, status=状态码) 作用： ​ 向客户端浏览器返回响应，同时携带响应体内容 常用的**Conten-Type**如下 - ‘text/html’（默认的，html文件） - ‘text/plain’（纯文本） - ‘text/css’（css文件） - ‘text/javascript’（js文件） - ‘multipart/form-data’（文件提交） - ‘application/json’（json传输） - ‘application/xml’（xml文件） ------------------------------------------------------------------ HttpResponse子类 12345678910111213http://127.0.0.1:8000/test_request =&gt; http://127.0.0.1:8000/page/1 &lt;项目同名文件夹下&gt;/urls.pyurlpatterns = [ path(&#x27;test_request&#x27;, views.test_request)] &lt;项目同名文件夹下&gt;/views.pyfrom django.http import HttpResponse, HttpResponseRedirectdef test_request(request): return HttpResponseRedirect(&#x27;/page/1&#x27;)","categories":[{"name":"Django","slug":"Django","permalink":"https://blog1.cpen.top/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://blog1.cpen.top/tags/Django/"},{"name":"HTTP","slug":"HTTP","permalink":"https://blog1.cpen.top/tags/HTTP/"},{"name":"状态码","slug":"状态码","permalink":"https://blog1.cpen.top/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"}]},{"title":"01_Django-介绍-项目结构-URL和视图函数","slug":"Django/01_Django-介绍-项目结构-URL和视图函数","date":"2022-09-24T04:00:00.000Z","updated":"2022-09-24T05:00:00.000Z","comments":true,"path":"posts/14763.html","permalink":"https://blog1.cpen.top/posts/14763.html","excerpt":"","text":"视频链接：https://www.bilibili.com/video/BV1vK4y1o7jH 一. 课程目录 Django介绍 Django项目结构 URL和视图函数 路由配置 二. Django介绍 起源 2005年发布，采用Python语言编写的开源web框架 早期的时候Django主做新闻和内容管理的 重量级的Python Web框架，Django配备了常用的大部分组件 组件 包含组件如下： ​ 基本配置文件/路由系统 ​ 模型层(M)/模块层(T)/视图层(V) ​ Cookies和Session ​ 分页及发邮件 ​ Admin管理后台 用途 用途一：网站/微信公众号/小程序后端开发 用途二：人工智能平台融合 版本 Django官网：http://www.djangoproject.com Django中文文档参考网站：https://yiyibooks.cn/ 版本 ​ 最新版本3.0.x ​ 当前教学版本2.2.12 安装 支持Python的版本 - 3.5，3.6，3.7，3.8 在线安装 ​ 虚拟机执行 sudo pip3 install django==2.2.12 ​ 检查是否成功 sudo pip3 freeze |grep -i ‘Django’ 离线安装 - 官方下载离线安装包 ​ 将安装包复制到虚拟机 ​ 解压缩 tar -xvf Django-2.2.12.tar.gz ​ 进入目录 cd Django-2.2.12 ​ 执行安装 sudo python3 setup.py install ​ 检查是否成功 sudo pip3 freeze |grep -i ‘Django’ 三. Django项目结构 创建项目 成功安装 Django 后，虚拟机终端会有 django-admin 命令 执行 django-admin startproject 项目名 即可创建出对应项目文件夹 例如 终端执行 django-admin startproject mysite1; 则创建出mysite1项目 启动服务 启动[测试开发阶段] ​ 1.终端cd进入到项目文件夹，例如 cd mysite1 ​ 2.进入到项目文件夹后，执行 python3 manage.py runserver 启动django服务完【注：该启动方式下，Django在前台启动服务，默认监听8000端口】 ​ 3.浏览器访问 http://127.0.0.1:8000 可看到django的启动页面 ​ 注：【如果想更换端口，则可以用 python3 manage.py runserver 端口号】 关闭服务 方式1：在runserver启动终端下 ​ 执行 Ctrl + c 可关闭Django服务 方式2：在取它终端下 ​ 执行 sudo lsof -i:8000 查询出Django的进程id ​ 执行 kill -9 对应Django进程id 启动常见问题 问题：启动时报错 ​ Error: That port is already in use. 问题原因：端口已被使用，证明当前Django启动时，默认监听的8000端口已被其他进程占用 解决方案：参考关闭服务 结构解析 123456789101112131415展开mysite1项目，结构如下$ tree mysite1mysite1├── db.sqlite3 #注：默认django数据库存储文件├── manage.py # *└── mysite1 # * ├── __init__.py ├── __pycache__ │ ├── __init__.cpython-39.pyc │ ├── settings.cpython-39.pyc │ ├── urls.cpython-39.pyc │ └── wsgi.cpython-39.pyc ├── settings.py ├── urls.py └── wsgi.py manage.py manage.py包含项目管理的子命令，如： ​ python3 manage.py runserver 启动服务 ​ python3 manage.py startapp 创建应用 ​ python3 manage.py migrate 数据库迁移 ​ … ​ 直接执行python3 manage.py 可列出所有的Django子命令 项目同名文件夹 项目同名文件夹 - mysite1/mysite1 ​ __init__: Python包的初始化文件 ​ wsgi.py: WEB服务网关的配置文件 - Django正式启动时，需要用到 ​ urls.py: 项目的主路由配置 - HTTP请求进入Django时，优先调用该文件 ​ settings.py: 项目的配置文件 - 包含项目启动时需要的配置 settings.py settings.py包含了Django项目启动的所有配置项 配置项分为 公有配置 和 自定义配置 配置项格式例：BASE_DIR = ‘xxxx’ 公有配置 - Django官网提供的基础配置 ​ https://docs/djangoproject.com/en/2.2/ref/settings/ 公有配置 BASE_DIR ​ 用于绑定当前项目的绝对路径（动态计算出来的），所有文件夹都可以依赖此路径 DEBUG ​ 用于配置Django项目的启动模式，取值： ​ True表示开发环境中使用 开发调试模式（用于开发中） ​ False表示当前项目运行在 生产环境中 ALLOWED_HOSTS 设置允许访问到本项目的host头值 ​ []空列表, 表示只有请求头中host为 127.0.0.1, localhost 能访问本项目 - DEBUG = True时生效 ​ [‘*’], 表示任何请求头的host都能访问到当前项目 ​ [‘192.168.1.3’, ‘127.0.0.1’] 表示只有当前两个host头的值能访问当前项目 示例：如果要在局域网其它主机也能访问此主机的Django服务，启动方式如下： ​ python3 manage.py runserver 0.0.0.0:5000 ​ 指定网络设备如果内网环境下其它主机想正常访问该站点，需要加ALLOWED_HOSTS=[‘内网ip’] INSTALLED_APPS - 指定当前项目中安装的应用列表 MIDDLEWARE - 用于注册中间件 TEMPLATES - 用于指定模板的配置信息 DATABASES - 用于指定数据库的配置信息 LANGUAGE_CODE - 用于指定语言配置 ​ 英语: “en-us” ​ 中文: “zh-Hans” TIME_ZONE - 用于指定当前服务器端时区 ​ 世界标准时间: “UTC” ​ 中国时区: “Asia/Shanghai” ROOT_URLCONF - 用于配置主url配置 ‘mysite1.urls’ ​ ROOT_URLCONF = ‘mysite1.urls’ 12345678910111213#项目绝对路径BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))DEBUG = True# 启动模式# True - 调试模式# 1,检测代码改动后，立刻重启服务# 2,报错页面# False - 正式启动模式 / 上线模式#请求头Host头ALLOWED_HOSTS = [&#x27;127.0.0.1&#x27;]#ALLOWED_HOSTS = [&#x27;www.tedu1.com&#x27;] 自定义配置 settings.py中也可以添加 开发人员 自定义的配置 配置建议：名字尽量个性化 - 以防覆盖掉公有配置 ​ 例如：ALIPAY_KEY = ‘xxxxxx’ settings.py中的所有配置项，都可以按需的在代码中引入 引入方式：from django.conf import settings 四. URL和视图函数 URL - 结构 定义 - 即统一资源定位符 Uniform Resource Locator 作用 - 用来表示互联网上某个资源的地址 URL的一般语法格式为（注：[] 代表其中的内容可省略）： ​ protocol://hostname[:port]/path[?query][#fragment] ​ http://tts.tmooc.cn/video/showVideo?menuld=657421&amp;version=AID999#subject protocol（协议） ==http://==tts.tmooc.cn http 通过HTTP访问该资源。格式 http:// https 通过安全的HTTPS访问该资源。格式 https:// file资源是本地计算机上的文件。格式 file:/// hostname（主机名） http:// tts.tmooc.cn 是指存放资源的服务器的域名系统（DNS）主机名、域名 或 IP地址 port（端口号） http://tts.tmooc.cn :80 整数，可选，省略时使用方案的默认端口 各种传输协议都有默认的端口号，如http的默认端口为80 path（路由地址） http://tts.tmooc.cn/ video/showVideo 由零或多个 “/” 符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。路由地址决定了服务器端如何处理这个请求 query（查询） video/showVideo==?menuld=657421&amp;version=AID999== 可选，用于给动态网页传递参数，可有多个参数，用 “&amp;” 符号隔开，每个参数的名和值用 “=” 符号隔开 fragment（信息片段） Version=AID999==#subject== https://docs.djangoproject.com/en/2.2/ #the-template-layer 字符串，用于指定网络资源中的片段。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释 处理URL请求 浏览器 地址栏 -&gt; http://127.0.0.1:8000/page/2003/ ​ 1.Django从配置文件中 根据 ROOT_URLCONF 找到 主路由文件；默认情况下，该文件在 项目同名目录下的urls；例如 mysite1/mysite1/urls.py ​ 2.Django加载 主路由文件中的 urlpatterns 变量【包含很多路由的数组】 ​ 3.依次匹配 urlpatterns 中的 URL，匹配到第一个合适的中断后续匹配 ​ 4.匹配成功 - 调用对应的视图函数处理请求，返回响应 ​ 5.匹配失败 - 返回404响应 主路由 - urls.py 主路由 - urls.py 样例 12345678from django.urls import pathform . import viewsurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;page/2003/&#x27;, views.page_2003), path(&#x27;page/2004/&#x27;, views.page_2004),] 视图函数 视图函数是用于接收一个浏览器请求（HttpRequest对象）并通过HttpRequest对象返回响应的函数。此函数可以接收浏览器请求并根据业务逻辑返回相应的响应内容给浏览器 语法 ​ def xxx_view(request[, 其它参数…]): ​ return HttpResponse对象 样例 123456# file: &lt;项目同名文件夹下&gt;/views.pyfrom django.http import HttpResponsedef page1_view(request): html = &quot;&lt;h1&gt;这是第1个页面&lt;/h1&gt;&quot; return HttpResponse(html) 示例 1234567891011121314151617http://127.0.0.1:8000/page/2003/ &lt;项目同名文件夹下&gt;/urls.pyfrom . import viewsurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), #http://127.0.0.1:8000/page/2003/ path(&#x27;page/2003/&#x27;, views.page_2003_view)] &lt;项目同名文件夹下&gt;/views.pyfrom django.http import HttpResponsedef page_2003_view(request): html = &quot;&lt;h1&gt;这是第1个页面&lt;/h1&gt;&quot; return HttpResponse(html)","categories":[{"name":"Django","slug":"Django","permalink":"https://blog1.cpen.top/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://blog1.cpen.top/tags/Django/"},{"name":"MTV","slug":"MTV","permalink":"https://blog1.cpen.top/tags/MTV/"},{"name":"URL","slug":"URL","permalink":"https://blog1.cpen.top/tags/URL/"}]},{"title":"03_Java-运算符-标识符命名规则规范-键盘输入-进制","slug":"Java/03_Java-运算符-标识符命名规则规范-键盘输入-进制","date":"2022-09-23T04:00:00.000Z","updated":"2022-09-23T05:00:00.000Z","comments":true,"path":"posts/62652.html","permalink":"https://blog1.cpen.top/posts/62652.html","excerpt":"","text":"视频链接：https://www.bilibili.com/video/BV1fh411y7R8 运算符 运算符 运算符介绍 ​ 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。 算术运算符 赋值运算符 关系运算符 [比较运算符] 逻辑运算符 位运算符 [需要二进制基础] 三元运算符 一. 算术运算符 算术运算符 介绍 算术运算符是对数值类型的变量进行运算的，在 Java 程序中使用的非常多。 算术运算符一览 % 的本质 看一个公式：a % b = a - a / b * b a % b 当 a 是小数时，公式 = a - (int)a / b * b 案例演示 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 演示算术运算符的使用 */public class ArithmeticOperator &#123; //编写一个main方法 public static void main(String[] args) &#123; // /使用 System.out.println(10 / 4); //从数学来看是2.5, java中 2 System.out.println(10.0 / 4); //java是2.5 // 注释快捷键 ctrl + /, 再次输入 ctrl + / 取消注释 double d = 10 / 4;//java中10 / 4 = 2, 2=&gt;2.0 System.out.println(d);// 是2.0 // % 取模 ,取余 // 在 % 的本质 看一个公式!!!! a % b = a - a / b * b // -10 % 3 =&gt; -10 - (-10) / 3 * 3 = -10 + 9 = -1 // 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1 // -10 % -3 = (-10) - (-10) / (-3) * (-3) = -10 + 9 = -1 System.out.println(10 % 3); //1 System.out.println(-10 % 3); // -1 System.out.println(10 % -3); //1 System.out.println(-10 % -3);//-1 //++的使用 // int i = 10; i++;//自增 等价于 i = i + 1; =&gt; i = 11 ++i;//自增 等价于 i = i + 1; =&gt; i = 12 System.out.println(&quot;i=&quot; + i);//12 /* 作为表达式使用 前++：++i先自增后赋值 后++：i++先赋值后自增 */ int j = 8; //int k = ++j; //等价 j=j+1;k=j; int k = j++; // 等价 k =j;j=j+1; System.out.println(&quot;k=&quot; + k + &quot;j=&quot; + j);//8 9 &#125;&#125; 细节说明 算数运算符使用 面试题 自增，自减课堂练习, 看看输出什么 1234567891011121314151617181920212223242526272829//练习public class ArithmeticOperatorExercise01 &#123; //编写一个main方法 public static void main(String[] args) &#123; // int i = 1;//i-&gt;1 // i = i++; //规则使用临时变量: (1) temp=i;(2) i=i+1;(3)i=temp; // System.out.println(i); // 1 // int i=1; // i=++i; //规则使用临时变量: (1) i=i+1;(2) temp=i;(3)i=temp; // System.out.println(i); //2 // // 测试输出 int i1 = 10; int i2 = 20; int i = i1++; System.out.print(&quot;i=&quot;+i);//10 System.out.println(&quot;i2=&quot;+i2);//20 i = --i2; System.out.print(&quot;i=&quot;+i);//19 System.out.println(&quot;i2=&quot;+i2);//19 &#125;&#125; 课堂练习 2 //ArithmeticOperatorExercise02.java 假如还有 59 天放假，问：合 xx 个星期零 xx 天 定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度。 [234.5] 代码 1234567891011121314151617181920212223242526272829303132333435363738//课堂练习public class ArithmeticOperatorExercise02 &#123; //编写一个main方法 public static void main(String[] args) &#123; //1.需求: //假如还有59天放假，问：合xx个星期零xx天 //2.思路分析 //(1) 使用int 变量 days 保存 天数 //(2) 一个星期是7天 星期数weeks： days / 7 零xx天leftDays days % 7 //(3) 输出 //3.走代码 int days = 25911; int weeks = days / 7; int leftDays = days % 7; System.out.println(days + &quot;天 合&quot; + weeks + &quot;星期零&quot; + leftDays + &quot;天&quot;); //1.需求 //定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为 //：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度 // //2思路分析 //(1) 先定义一个double huaShi 变量保存 华氏温度 //(2) 根据给出的公式，进行计算即可5/9*(华氏温度-100) // 考虑数学公式和java语言的特性 //(3) 将得到的结果保存到double sheShi //3走代码 double huaShi = 1234.6; double sheShi = 5.0 / 9 * (huaShi - 100); System.out.println(&quot;华氏温度&quot; + huaShi + &quot; 对应的摄氏温度=&quot; + sheShi); &#125;&#125; 二. 关系运算符(比较运算符) **关系运算符(比较运算符) ** 介绍 关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false 关系表达式 经常用在 if 结构的条件中或循环结构的条件中 关系运算符一览 案例演示 案例演示关系运算符的使用(RelationalOperator.java)。 1234567891011121314151617181920//演示关系运算符的使用//public class RelationalOperator &#123; //编写一个main方法 public static void main(String[] args) &#123; int a = 9; //老韩提示: 开发中，不可以使用 a, b int b = 8; System.out.println(a &gt; b); //T System.out.println(a &gt;= b); //T System.out.println(a &lt;= b); //F System.out.println(a &lt; b); //F System.out.println(a == b); //F System.out.println(a != b); //T boolean flag = a &gt; b; //T System.out.println(&quot;flag=&quot; + flag); &#125;&#125; 细节说明 关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。 关系运算符组成的表达式，我们称为关系表达式。 a &gt; b 比较运算符&quot;==“不能误写成”=&quot; 三. 逻辑运算符 逻辑运算符 介绍 ​ 用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 值。 逻辑运算符一览 分为两组学习 短路与 &amp;&amp; ， 短路或 ||，取反 ! 逻辑与 &amp;，逻辑或 |，^ 逻辑异或 说明逻辑运算规则： a&amp;b : &amp; 叫逻辑与：规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false a&amp;&amp;b : &amp;&amp; 叫短路与：规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false a|b : | 叫逻辑或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false a||b : || 叫短路或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false !a : 叫取反，或者非运算。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false 短路与逻辑与 &amp;&amp; 和 &amp; 基本规则 名称 语法 特点 短路与&amp;&amp; 条件 1&amp;&amp;条件 2 两个条件都为 true，结果为 true,否则 false 逻辑与&amp; 条件 1&amp;条件 2 &amp;&amp; 和 &amp; 案例演示 案例演示&amp;&amp; 和 &amp; 运算符的使用(LogicOperator01.java)。 12345678910111213141516171819202122232425262728293031/** * 演示逻辑运算符的使用 */public class LogicOperator01 &#123; //编写一个main方法 public static void main(String[] args) &#123; //&amp;&amp;短路与 和 &amp; 案例演示 int age = 50; if(age &gt; 20 &amp;&amp; age &lt; 90) &#123; System.out.println(&quot;ok100&quot;); &#125; //&amp;逻辑与使用 if(age &gt; 20 &amp; age &lt; 90) &#123; System.out.println(&quot;ok200&quot;); &#125; //区别 int a = 4; int b = 9; //对于&amp;&amp;短路与而言，如果第一个条件为false ,后面的条件不再判断 //对于&amp;逻辑与而言，如果第一个条件为false ,后面的条件仍然会判断 if(a &lt; 1 &amp; ++b &lt; 50) &#123; System.out.println(&quot;ok300&quot;); &#125; System.out.println(&quot;a=&quot; + a + &quot; b=&quot; + b);// 4 10 &#125;&#125; &amp;&amp; 和 &amp; 使用区别 &amp;&amp;短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高 &amp; 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低 开发中， 我们使用的基本是使用短路与&amp;&amp;, 效率高 短路或逻辑或 || 和 | 基本规则 名称 语法 特点 短路或|| 条件 1||条件2 两个条件中只要有一个成立，结果为 true,否则为 false 逻辑或| 条件 1|条件2 只要有一个条件成立，结果为 true,否则为 false || 和 | 案例演示 案例演示&amp;&amp; || !运算符的使用(LogicOperator02.java)。 123456789101112131415161718192021222324252627282930313233//演示| || 使用public class LogicOperator02 &#123; //编写一个main方法 public static void main(String[] args) &#123; //||短路或 和 |逻辑或 案例演示 //|| 规则: 两个条件中只要有一个成立，结果为true,否则为false //| 规则: 两个条件中只要有一个成立，结果为true,否则为false int age = 50; if(age &gt; 20 || age &lt; 30) &#123; System.out.println(&quot;ok100&quot;); &#125; //|逻辑或使用 if(age &gt; 20 | age &lt; 30) &#123; System.out.println(&quot;ok200&quot;); &#125; //看看区别 //(1)||短路或：如果第一个条件为true， //则第二个条件不会判断，最终结果为true，效率高 //(2)| 逻辑或：不管第一个条件是否为true，第二个条件都要判断，效率低 int a = 4; int b = 9; if( a &gt; 1 || ++b &gt; 4) &#123; // 可以换成 | 测试 System.out.println(&quot;ok300&quot;); &#125; System.out.println(&quot;a=&quot; + a + &quot; b=&quot; + b); //4 9 &#125;&#125; || 和 | 使用区别 ||短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高 | 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低 开发中，我们基本使用 || 逻辑非逻辑异或 ! 取反 基本规则 名称 语法 特点 ! 非（取反） !条件 如果条件本身成立，结果为 false，否则为 true ! 案例演示 案例演示 !运算符的使用(InverseOperator.java)。 12345678910111213141516//!和^案例演示public class InverseOperator &#123; //编写一个main方法 public static void main(String[] args) &#123; //! 操作是取反 T-&gt;F , F -&gt; T System.out.println(60 &gt; 20); //T System.out.println(!(60 &gt; 20)); //F //a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为true, 否则为false boolean b = (10 &gt; 1) ^ ( 3 &gt; 5); System.out.println(&quot;b=&quot; + b);//T &#125;&#125; ^ 案例演示 a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false ^逻辑异或，System.out.println( (4 &lt; 1) ^ (6 &gt; 3) ); // T 逻辑运算符练习 练习题 1 请写出每题的输出结果 x ++== 6，先比较，再自增 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//验证public class Test &#123; //编写一个main方法 public static void main(String[] args) &#123; // int x = 5; // int y=5; // if(x++==6 &amp; ++y==6)&#123; //逻辑与 // x = 11; // &#125; // System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); // //6, 6 // int x = 5,y = 5; // if(x++==6 &amp;&amp; ++y==6)&#123; // x = 11; // &#125; // System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); // //6, 5 // // int x = 5,y = 5; // if(x++==5 | ++y==5)&#123; // x =11; // &#125; // System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); //11, 6 // // int x = 5,y = 5; // if(x++==5 || ++y==5)&#123; // x =11; // &#125; // System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); //11, 5 // // boolean x=true; boolean y=false; short z=46; if( (z++==46)&amp;&amp; (y=true) ) z++; if((x=false) || (++z==49)) z++; System. out.println(&quot;z=&quot;+z); //50 &#125;&#125; 练习题 2 请写输出结果 四. 赋值运算符 介绍 赋值运算符就是将某个运算后的值，赋给指定的变量。 赋值运算符的分类 基本赋值运算符 = int a = 10; 复合赋值运算符 ​ += ，-= ，*= ， /= ，%= 等 , 重点讲解一个 += ，其它的使用是一个道理 ​ a += b; [等价 a = a + b; ] ​ a -= b; [等价 a = a - b; ] 案例演示 案例演示赋值运算符的基本使用。AssignOperator.java 赋值基本案例 [int num1 = 10] += 的使用案例 1234567891011121314151617181920//演示赋值运算符的使用public class AssignOperator &#123; //编写一个main方法 public static void main(String[] args) &#123; int n1 = 10; n1 += 4;// n1 = n1 + 4; System.out.println(n1); // 14 n1 /= 3;// n1 = n1 / 3;//4 System.out.println(n1); // 4 //复合赋值运算符会进行类型转换 byte b = 3; b += 2; // 等价 b = (byte)(b + 2); b++; // b = (byte)(b+1); &#125;&#125; 赋值运算符特点 运算顺序从右往左 int num = a + b + c; 赋值运算符的左边 只能是变量,右边 可以是变量、表达式、常量值 ​ int num = 20; int num2= 78 * 34 - 10; int num3 = a; 复合赋值运算符等价于下面的效果 ​ 比如：a+=3;等价于 a=a+3; 其他类推 复合赋值运算符会进行类型转换。 ​ byte b = 2; b+=3; b++; 五. 三元运算符 基本语法 条件表达式 ? 表达式 1: 表达式 2; 运算规则： 如果条件表达式为 true，运算后的结果是表达式 1； 如果条件表达式为 false，运算后的结果是表达式 2； 口诀: [一灯大师：一真大师] 案例演示 TernaryOperator.java 1234567891011121314151617181920//三元运算符使用public class TernaryOperator &#123; //编写一个main方法 public static void main(String[] args) &#123; int a = 10; int b = 99; // 解读 // 1. a &gt; b 为 false // 2. 返回 b--, 先返回 b的值,然后在 b-1 // 3. 返回的结果是99 int result = a &gt; b ? a++ : b--; System.out.println(&quot;result=&quot; + result); System.out.println(&quot;a=&quot; + a); System.out.println(&quot;b=&quot; + b); &#125;&#125; 使用细节 TernaryOperatorDetail.java 表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换) 三元运算符可以转成 if–else 语句 ​ int res = a &gt; b ? a++ : --b; ​ if ( a &gt; b) res = a++; ​ else res = --b; 1234567891011121314//三元运算符细节public class TernaryOperatorDetail &#123; //编写一个main方法 public static void main(String[] args) &#123; //表达式1和表达式2要为可以赋给接收变量的类型 //(或可以自动转换/或者强制转换) int a = 3; int b = 8; int c = a &gt; b ? (int)1.1 : (int)3.4;//可以的 double d = a &gt; b ? a : b + 3;//可以的，满足 int -&gt; double &#125;&#125; 课堂练习 案例：实现三个数的最大值 TernaryOperatorExercise.java 12345678910111213141516171819202122232425public class TernaryOperatorExercise &#123; //编写一个main方法 public static void main(String[] args) &#123; //案例：实现三个数的最大值 int n1 = 553; int n2 = 33; int n3 = 123; //思路 //1. 先得到 n1 和 n2 中最大数 , 保存到 max1 //2. 然后再 求出 max1 和 n3中的最大数，保存到 max2 int max1 = n1 &gt; n2 ? n1 : n2; int max2 = max1 &gt; n3 ? max1 : n3; System.out.println(&quot;最大数=&quot; + max2); //使用一条语句实现, 推荐使用上面方法 //老师提示: 后面我们可以使用更好方法,比如排序 // int max = (n1 &gt; n2 ? n1 : n2) &gt; n3 ? // (n1 &gt; n2 ? n1 : n2) : n3; // System.out.println(&quot;最大数=&quot; + max); // &#125;&#125; 六. 运算符优先级 运算符优先级 运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优先于下一行。 只有单目运算符、赋值运算符是从右向左运算的。 一览表, 不要背，使用多了，就熟悉了 梳理小节：小伙伴有一个大致印象，使用多了，就熟悉 () , {} 等 单目运算 ++ – 算数运算符 位移运算符 比较运算符 逻辑运算符 三元运算符 赋值运算符 标识符命名规则和规范 七. 标识符规则 标识符的命名规则和规范 12345678910111213int abcclass = 10;int n = 40;int N = 50;System.out.println(&quot;n=&quot; + n);//40System.out.println(&quot;N=&quot; + N);//50//? abc 和 aBc 是两个不同变量int abc = 100;int aBc = 200;//int a b = 300; //x//int a-b=10;int goto1 = 10; 判断下面变量名是否正确 12345678910111213hsp //ok hsp12 //ok 1hsp //错误, 数字不能开头 h-s // 错误 , 不能有 - x h // 错误， 有空格 h$4 // ok class //错误，class 关键字 int // 错误 ,int 是关键字 double //错误 ,double 是关键字 public //错误 ,public 是关键字 static //错误 ,static 是关键字 goto //错误, goto 是保留字 stu_name //ok 八. 标识符规范 标识符命名规范[更加专业] 包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰] ​ 比如： TankShotGame 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小驼峰， 简称 驼峰法] ​ 比如： tankShotGame 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ ​ 比如 ：定义一个所得税率 TAX_RATE 后面我们学习到 类，包，接口，等时，我们的命名规范要这样遵守,更加详细的看文档. 九. 关键字保留字 关键字 关键字的定义和特点 (不用背) 定义：被 Java 语言赋予了特殊含义，用做 专门用途的字符串（单词） 特点：关键字中所有字母都为小写 保留字 介绍 ​ Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字 byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const 键盘输入 十. 键盘输入 键盘输入语句 介绍 在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。Input.java , 需要一个 扫描器(对象), 就是 Scanner 步骤 ： 导入该类的所在包, java.util.* 创建该类对象（声明变量） 调用里面的功能 案例演示： 要求：可以从控制台接收用户信息，【姓名，年龄，薪水】 123456789101112131415161718192021222324252627import java.util.Scanner;//表示把java.util下的Scanner类导入 public class Input &#123; //编写一个main方法 public static void main(String[] args) &#123; //演示接受用户的输入 //步骤 //Scanner类 表示 简单文本扫描器，在java.util 包 //1. 引入/导入 Scanner类所在的包 //2. 创建 Scanner 对象 , new 创建一个对象,体会 // myScanner 就是 Scanner类的对象 Scanner myScanner = new Scanner(System.in); //3. 接收用户输入了， 使用 相关的方法 System.out.println(&quot;请输入名字&quot;); //当程序执行到 next 方法时，会等待用户输入~~~ String name = myScanner.next(); //接收用户输入字符串 System.out.println(&quot;请输入年龄&quot;); int age = myScanner.nextInt(); //接收用户输入int System.out.println(&quot;请输入薪水&quot;); double sal = myScanner.nextDouble(); //接收用户输入double System.out.println(&quot;人的信息如下:&quot;); System.out.println(&quot;名字=&quot; + name + &quot; 年龄=&quot; + age + &quot; 薪水=&quot; + sal); &#125;&#125; 进制 十一. 四种进制介绍 进制(程序员的基本功) 进制介绍 对于整数，有四种表示方式： 二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。 十进制：0-9 ，满 10 进 1。 八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。 十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 0X 开头表示。此处的 A-F 不区分大小写。 举例说明 BinaryTest.java 1234567891011121314151617181920212223//演示四种进制//public class BinaryTest &#123; //编写一个main方法 public static void main(String[] args) &#123; //n1 二进制 int n1 = 0b1010; //n2 10进制 int n2 = 1010; //n3 8进制 int n3 = 01010; //n4 16进制 int n4 = 0X10101; System.out.println(&quot;n1=&quot; + n1); System.out.println(&quot;n2=&quot; + n2); System.out.println(&quot;n3=&quot; + n3); System.out.println(&quot;n4=&quot; + n4); System.out.println(0x23A); &#125;&#125; 进制的图示 进制的转换(基本功) 进制转换的介绍 第一组： 二进制转十进制 八进制转十进制 十六进制转十进制 第二组： 十进制转二进制 十进制转八进制 十进制转十六进制 第三组 二进制转八进制 二进制转十六进制 第四组 八进制转二进制 十六进制转二进制 其他进制转十进制 十二. 2进制转10进制 二进制转换成十进制示例 十三. 8进制转10进制 八进制转换成十进制示例 十四. 16进制转10进制 十六进制转换成十进制示例 规则：从最低位(右边)开始，将每个位上的数提取出来，乘以 16 的(位数-1)次方，然后求和。 案例：请将 0x23A 转成十进制的数 0x23A = 10 * 16^0 + 3 * 16 ^ 1 + 2 * 16^2 = 10 + 48 + 512 = 570 1System.out.println(0x23A); //570 课堂练习：请将 0b110001100 转成 十进制 02456 转成十进制 0xA45 转成十进制 十进制转其它进制 十五. 10进制转2进制 十进制转换成二进制 规则：将该数不断除以 2，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制。 案例：请将 34 转成二进制 = 0B00100010 十六. 10进制转8进制 十进制转换成八进制 规则：将该数不断除以 8，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的八进制。 案例：请将 131 转成八进制 =&gt; 0203 十七. 10进制转16进制 十进制转换成十六进制 规则：将该数不断除以 16，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的十六进制。 案例：请将 237 转成十六进制 =&gt; 0xED 课堂练习：(一定练习，使用计算器/用程序去验证) ​ 123 转成 二进制 =&gt; ? ​ 678 转成八进制 =&gt; 04126 ​ 8912 转成十六进制 =&gt; ? 二进制转换成八进制、十六进制 十八. 2进制转8进制 规则：从低位开始,将二进制数每三位一组，转成对应的八进制数即可。 案例：请将 ob11010101 转成八进制 ob11(3)010(2)101(5) =&gt; 0325 十九. 2进制转16进制 规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。 案例：请将 ob11010101 转成十六进制 ob1101(D)0101(5) = 0xD5 课堂练习：请将 ​ 0b11100101 转成 八进制 ​ 0b1110010110 转成 十六进制 =&gt; 0x396 八进制、十六进制转成二进制 二十. 8进制转2进制 规则：将八进制数每 1 位，转成对应的一个 3 位的二进制数即可。 案例：请将 0237 转成二进制 02(010)3(011)7(111) = 0b10011111 二一. 16进制转2进制 规则：将十六进制数每 1 位，转成对应的 4 位的一个二进制数即可。 案例：请将 0x23B 转成二进制 0x2(0010)3(0011)B(1011) = 0b001000111011 课堂练习：请将 01230 转成 二进制 0xAB29 转成二进制 =&gt; 0xA(1010)B(1011)2(0010)9(1001) =&gt;0b1010101100101001 二二. 位运算思考题 位运算的思考题 请看下面的代码段，回答 a,b,c,d,e 结果是多少? 1234567891011121314151617181920212223242526public static void maiin(String []args) &#123; int a=1&gt;&gt;2; // 1 向右位移 2 位 int b=-1&gt;&gt;2;//算术右移 int c=1&lt;&lt;2;//算术左移 int d=-1&lt;&lt;2;// int e=3&gt;&gt;&gt;2;//无符号右移 //a,b,c,d,e 结果是多少 System.out.println(&quot;a=&quot;+a); System.out.println(&quot;b=&quot;+b); System.out.println(&quot;c=&quot;+c); System.out.println(&quot;d=&quot;+d); System.out.println(&quot;e=&quot;+e); &#125; 请回答在 java 中，下面的表达式运算的结果是: (位操作)， 晚上练习 12345678910111213~2=? // 按位取反 2&amp;3=? // 2 按位与 3 2|3=? ~-5=? 13&amp;7=? 5|4=? -3^3=? //^ 按位异或 二三. 原码反码补码 二进制在运算中的说明 原码、反码、补码(重点 难点) 第 7 点，因为补码把正数、负数统一起来了 二四. 位运算 位运算符 java 中有 7 个位运算(&amp;、|、^、~、&gt;&gt;、&lt;&lt;和 &gt;&gt;&gt;) 123456789101112131415161718192021222324252627282930313233343536373839//位运算public class BitOperator &#123; //编写一个main方法 public static void main(String[] args) &#123; // 2&amp;3 //看老师的推导过程 //1. 先得到 2的补码 =&gt; 2的原码 00000000 00000000 00000000 00000010 // 2的补码 00000000 00000000 00000000 00000010 //2. 3的补码 3的原码 00000000 00000000 00000000 00000011 // 3的补码 00000000 00000000 00000000 00000011 //3. 按位&amp; // 00000000 00000000 00000000 00000010 // 00000000 00000000 00000000 00000011 // 00000000 00000000 00000000 00000010 &amp; 运算后的补码 // 运算后的原码 也是 00000000 00000000 00000000 00000010 // 结果就是 2 System.out.println(2&amp;3);//2 // ~-2 //推导 //1. 先得到 -2的原码 10000000 00000000 00000000 00000010 //2. -2的 反码 11111111 11111111 11111111 11111101 //3. -2的 补码 11111111 11111111 11111111 11111110 //4. ~-2操作 00000000 00000000 00000000 00000001运算后的补码 //5. 运算后的原码 就是 00000000 00000000 00000000 00000001 =&gt; 1 System.out.println(~-2);//1 //推导 //1. 得到2的补码 00000000 00000000 00000000 00000010 //2. ~2操作 11111111 11111111 11111111 11111101 运算后的补码 //3. 运算后的反码 11111111 11111111 11111111 11111100 //4. 运算后的原码 10000000 00000000 00000000 00000011=&gt;-3 System.out.println(~2); //-3 &#125;&#125; 位运算符 还有 3 个位运算符 &gt;&gt;、&lt;&lt; 和 &gt;&gt;&gt; , 运算规则: 算术右移 &gt;&gt;：低位溢出,符号位不变,并用符号位补溢出的高位 算术左移 &lt;&lt;: 符号位不变,低位补 0 &gt;&gt;&gt; 逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0 特别说明：没有 &lt;&lt;&lt; 符号 应用案例 BitOperator02.java int a=1&gt;&gt;2; //1 =&gt; 00000001 =&gt; 00000000 本质 1 / 2 / 2 =0 int c=1&lt;&lt;2; //1 =&gt; 00000001 =&gt; 00000100 本质 1 * 2 * 2 = 4 123456789101112public class BitOperator02 &#123; //编写一个main方法 public static void main(String[] args) &#123; System.out.println(1 &gt;&gt; 2); //0 System.out.println(1 &lt;&lt; 2); //4 System.out.println(4 &lt;&lt; 3); // 4 * 2 * 2 * 2 = 32 System.out.println(15 &gt;&gt; 2); // 15 / 2 / 2 = 3 &#125;&#125; 完成前面的案例 建议：掌握老师讲解的即可，不用再深入 本章作业 1234System.out.println(-10.4%3); // -1.4近似值int i=66;System.out.println(++i+i); //134","categories":[{"name":"Java","slug":"Java","permalink":"https://blog1.cpen.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog1.cpen.top/tags/Java/"},{"name":"运算符","slug":"运算符","permalink":"https://blog1.cpen.top/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"进制","slug":"进制","permalink":"https://blog1.cpen.top/tags/%E8%BF%9B%E5%88%B6/"}]},{"title":"02_Java-变量-数据类型","slug":"Java/02_Java-变量-数据类型","date":"2022-09-22T04:00:00.000Z","updated":"2022-09-22T05:00:00.000Z","comments":true,"path":"posts/47697.html","permalink":"https://blog1.cpen.top/posts/47697.html","excerpt":"","text":"视频链接：https://www.bilibili.com/video/BV1fh411y7R8 一. 变量 变量原理 变量 为什么需要变量 一个程序就是一个世界 变量是程序的基本组成单位 简单的原理示意图 变量概念 **变(变化)量(值)的介绍 ** 概念 ​ 变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房 间，而通过变量名可以访问到变量(值)。 变量使用的基本步骤 声明变量 ​ int a; 赋值 ​ a = 60; //应该这么说: 把 60 赋给 a 使用 System.out.println(a); ​ //也可以一步到位 [int a = 60; 通常我们是一步完成] 123456789101112131415public class Var01 &#123; //编写一个main方法 public static void main(String[] args) &#123; //声明变量 int a; a = 100; System.out.println(a); //还可以这样使用 int b = 800; System.out.println(b); &#125;&#125; 变量入门 变量快速入门 变量使用入门案例 看演示并对代码进行说明， 演示记录 人的信息的代码 123456789101112131415161718public class Var02 &#123; //编写一个main方法 public static void main(String[] args) &#123; //记录人的信息 int age = 30; double score = 88.9; char gender = &#x27;男&#x27;; String name = &quot;king&quot;; //输出信息, 快捷键 System.out.println(&quot;人的信息如下:&quot;); System.out.println(name); System.out.println(age); System.out.println(score); System.out.println(gender); &#125;&#125; 变量细节 变量使用注意事项 123456789101112131415161718192021222324public class VarDetail &#123; //编写一个main方法 public static void main(String[] args) &#123; //变量必须先声明，后使用, 即有顺序 int a = 50;//int System.out.println(a);//50 //该区域的数据/值可以在同一类型范围内不断变化 //a = &quot;jack&quot;; //× a = 88; //对 System.out.println(a);//88 //变量在同一个作用域内不能重名 //int a = 77;//错误 &#125;&#125;class Dog &#123; public static void main(String[] args) &#123; int a = 666;//对 &#125;&#125; 加号使用 程序中 +号的使用 123456789101112public class Plus &#123; //编写一个main方法 public static void main(String[] args) &#123; System.out.println(100 + 98); //198 System.out.println(&quot;100&quot; + 98);//10098 System.out.println(100 + 3 + &quot;hello&quot;);//103hello System.out.println(&quot;hello&quot; + 100 +3); //hello1003 &#125;&#125; 二. 数据类型 数据类型 每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。 上图说明 [老韩要求小伙伴，背下来!!!!] java 数据类型分为两大类 基本数据类型， 引用类型 **基本数据类型有 8 种 数值型 [byte , short , int , long , float ,double] char , boolean ** 引用类型 [类，接口， 数组] 整型 整数类型 基本介绍 Java 的整数类型就是用于存放整数值的，比如 12 , 30, 3456 等等 案例演示： byte n1 = 10; short n2 = 10; int n3 = 10;//4 个字节 long n4 = 10; //8 个字节 整型的类型 整型的使用细节 IntDetail.java bit：计算机中的最小存储单位 ；byte：计算机中基本存储单位 123456789101112public class IntDetail &#123; //编写一个main方法 public static void main(String[] args) &#123; //Java的整型常量（具体值）默认为 int 型，声明long型常量须后加‘l’或‘L’ int n1 = 1;//4个字节 //int n2 = 1L; //不对 long n3 = 1L; //对 &#125;&#125; 浮点数 浮点类型 基本介绍 Java 的浮点类型可以表示一个小数，比如 123.4 ，7.8 ，0.12 等等 案例演示 浮点型的分类 说明一下 关于浮点数在机器中存放形式的简单说明,浮点数=符号位+指数位+尾数位 尾数部分可能丢失，造成精度损失(小数都是近似值)。 浮点数细节 浮点型使用细节 FloatDetail.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class FloatDetail &#123; //编写一个main方法 public static void main(String[] args) &#123; //Java 的浮点型常量(具体值)默认为double型，声明float型常量，须后加‘f’或‘F&#x27; //float num1 = 1.1; //错误 float num2 = 1.1F; //对的 double num3 = 1.1; //对 double num4 = 1.1f; //对 //十进制数形式：如：5.12 512.0f .512 (必须有小数点） double num5 = .123; //等价 0.123 System.out.println(num5); //科学计数法形式:如：5.12e2 [5.12 * 10的2次方 ] 5.12E-2 [5.12 / 10的2次方] System.out.println(5.12e2);//512.0 System.out.println(5.12E-2);//0.0512 //通常情况下，应该使用double型，因为它比float型更精确。 //[举例说明]double num9 = 2.1234567851;float num10 = 2.1234567851F; double num9 = 2.1234567851; float num10 = 2.1234567851F; System.out.println(num9); System.out.println(num10); //浮点数使用陷阱: 2.7 和 8.1 / 3 比较 //看看一段代码 double num11 = 2.7; double num12 = 2.7; //8.1 / 3; //2.7 System.out.println(num11);//2.7 System.out.println(num12);//接近2.7的一个小数，而不是2.7 //得到一个重要的使用点: 当我们对运算结果是小数的进行相等判断是，要小心 //应该是以两个数的差值的绝对值，在某个精度范围内判断 if( num11 == num12) &#123; System.out.println(&quot;num11 == num12 相等&quot;); &#125; //正确的写法 , ctrl + / 注释快捷键, 再次输入就取消注释 if(Math.abs(num11 - num12) &lt; 0.000001 ) &#123; System.out.println(&quot;差值非常小，到我的规定精度，认为相等...&quot;); &#125; // 可以通过java API 来看 下一个视频介绍如何使用API System.out.println(Math.abs(num11 - num12)); //细节:如果是直接查询得的的小数或者直接赋值，是可以判断相等 &#125;&#125; Java API文档 Java API 文档 字符型 字符类型(char) 基本介绍 ​ 字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符我们用字符串 String(我们后面详细讲解 String) 案例演示 Char01.java 12345#代码 char c1 = &#x27;a&#x27;; char c2 = &#x27;\\t&#x27;; char c3 = &#x27;韩&#x27;; char c4 = 97; 123456789101112131415161718//演示char的基本使用public class Char01 &#123; //编写一个main方法 public static void main(String[] args) &#123; char c1 = &#x27;a&#x27;; char c2 = &#x27;\\t&#x27;; char c3 = &#x27;韩&#x27;; char c4 = 97; //说明: 字符类型可以直接存放一个数字 System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4);//当输出c4时候，会输出97表示的字符 =&gt; 编码的概念 （输出为 a） &#125;&#125; 字符型细节 字符类型使用细节 123456789101112131415161718192021222324252627public class CharDetail &#123; //编写一个main方法 public static void main(String[] args) &#123; //在java中，char的本质是一个整数，在默认输出时，是unicode码对应的字符 //要输出对应的数字，可以(int)字符 char c1 = 97; System.out.println(c1); // a char c2 = &#x27;a&#x27;; //输出&#x27;a&#x27; 对应的 数字 System.out.println((int)c2); //强转为 int类型 char c3 = &#x27;韩&#x27;; System.out.println((int)c3);//38889 char c4 = 38889; System.out.println(c4);//韩 //char类型是可以进行运算的，相当于一个整数，因为它都对应有Unicode码. System.out.println(&#x27;a&#x27; + 10);//107 //课堂小测试 char c5 = &#x27;b&#x27; + 1;//98+1==&gt; 99 System.out.println((int)c5); //99 System.out.println(c5); //99 -&gt; 对应的字符 -&gt; 编码表ASCII(规定好的) =&gt; c &#125;&#125; ASCII码对照表： 字符型本质 字符类型本质探讨 常用编码 ASCII 码介绍(了解) Unicode 编码介绍(了解) UTF-8 编码介绍(了解) 布尔类型 布尔类型 布尔类型：boolean 12345678910111213public class Boolean01 &#123; //编写一个main方法 public static void main(String[] args) &#123; //演示判断成绩是否通过的案例 //定义一个布尔变量 boolean isPass = true;// if(isPass == true) &#123; System.out.println(&quot;考试通过，恭喜&quot;); &#125; else &#123; System.out.println(&quot;考试没有通过，下次努力&quot;); &#125; &#125;&#125; 基本数据类型转换 自动类型转 自动类型转换基础 自动类型转换 123456789101112public class AutoConvert &#123; //编写一个main方法 public static void main(String[] args) &#123; //演示自动转换 int num = &#x27;a&#x27;; //ok char -&gt; int double d1 = 80; //ok int -&gt; double System.out.println(num); //97 System.out.println(d1); //80.0 &#125;&#125; 自动类型转换细节 自动类型转换注意和细节 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//自动类型转换细节public class AutoConvertDetail &#123; //编写一个main方法 public static void main(String[] args) &#123; //细节1： 有多种类型的数据混合运算时， //系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算 int n1 = 10; //ok //float d1 = n1 + 1.1; //错误 n1 + 1.1 =&gt; 结果类型是 double //double d1 = n1 + 1.1; //对 n1 + 1.1 =&gt; 结果类型是 double float d1 = n1 + 1.1F; //对 n1 + 1.1 =&gt; 结果类型是 float //细节2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时， //就会报错，反之就会进行自动类型转换。 // //int n2 = 1.1;//错误 double -&gt; int //细节3: (byte, short) 和 char之间不会相互自动转换 //当把具体数赋给 byte 时，(1)先判断该数是否在byte范围内，如果是就可以 byte b1 = 10; //对 , -128-127 // int n2 = 1; //n2 是int // byte b2 = n2; //错误，原因： 如果是变量赋值，判断类型 // // char c1 = b1; //错误， 原因 byte 不能自动转成 char // // //细节4: byte，short，char 他们三者可以计算，在计算时首先转换为int类型 byte b2 = 1; byte b3 = 2; short s1 = 1; //short s2 = b2 + s1; //错, b2 + s1 =&gt; int int s2 = b2 + s1; //对, b2 + s1 =&gt; int //byte b4 = b2 + b3; //错误: b2 + b3 =&gt; int // //boolean 不参与转换 boolean pass = true; //int num100 = pass;// boolean 不参与类型的自动转换 //自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型 //看一道题 byte b4 = 1; short s3 = 100; int num200 = 1; float num300 = 1.1F; double num500 = b4 + s3 + num200 + num300; //float -&gt; double &#125;&#125; 强制类型转换 强制类型转换 介绍 ​ 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成 精度降低或溢出,格外要注意。 案例演示 ForceConvert.java 1234567891011121314public class ForceConvert &#123; //编写一个main方法 public static void main(String[] args) &#123; //演示强制类型转换 int n1 = (int)1.9; System.out.println(&quot;n1=&quot; + n1);//1, 造成精度损失 int n2 = 2000; byte b1 = (byte)n2; System.out.println(&quot;b1=&quot; + b1);//造成 数据溢出 &#125;&#125; 强制类型转换细节说明 123456789101112131415161718192021public class ForceConvertDetail &#123; //编写一个main方法 public static void main(String[] args) &#123; //演示强制类型转换 //强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级 //int x = (int)10*3.5+6*1.5; //编译错误： double -&gt; int int x = (int)(10*3.5+6*1.5); // (int)44.0 -&gt; 44 System.out.println(x);//44 char c1 = 100; //ok int m = 100; //ok //char c2 = m; //错误 char c3 = (char)m; //ok System.out.println(c3);//100对应的字符, d字符 &#125;&#125; 类型转换练习 基本数据类型转换-练习题 基本数据类型和String类型的转换 基本数据类型和 String 类型的转换 介绍和使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class StringToBasic &#123; //编写一个main方法 public static void main(String[] args) &#123; //基本数据类型 -&gt; String int n1 = 100; float f1 = 1.1F; double d1 = 4.5; boolean b1 = true; String s1 = n1 + &quot;&quot;; String s2 = f1 + &quot;&quot;; String s3 = d1 + &quot;&quot;; String s4 = b1 + &quot;&quot;; System.out.println(s1 + &quot; &quot; + s2 + &quot; &quot; + s3 + &quot; &quot; + s4); // 100 1.1 4.5 true //String -&gt; 对应的基本数据类型 String s5 = &quot;123&quot;; //会在OOP 讲对象和方法的时候回详细 //解读 使用 基本数据类型对应的包装类，的相应方法，得到基本数据类型 int num1 = Integer.parseInt(s5); double num2 = Double.parseDouble(s5); float num3 = Float.parseFloat(s5); long num4 = Long.parseLong(s5); byte num5 = Byte.parseByte(s5); boolean b = Boolean.parseBoolean(&quot;true&quot;); short num6 = Short.parseShort(s5); System.out.println(&quot;===================&quot;); System.out.println(num1);//123 System.out.println(num2);//123.0 System.out.println(num3);//123.0 System.out.println(num4);//123 System.out.println(num5);//123 System.out.println(num6);//123 System.out.println(b);//true //怎么把字符串转成字符char -&gt; 含义是指 把字符串的第一个字符得到 //解读 s5.charAt(0) 得到 s5字符串的第一个字符 &#x27;1&#x27; System.out.println(s5.charAt(0)); &#125;&#125; String转基本类型细节 注意事项 案例演示: StringToBasicDetail.java 在将 String 类型转成 基本数据类型时，要确保 String 类型能够转成有效的数据，比如 我们可以把 “123” , 转成一个整数，但是不能把 “hello” 转成一个整数 如果格式不正确，就会 抛出异常，程序就会终止， 这个问题在异常处理章节中，会处理 1234567891011121314/** * 演示字符串转基本数据类型的细节 */public class StringToBasicDetail &#123; //编写一个main方法 public static void main(String[] args) &#123; String str = &quot;hello&quot;; //转成int int n1 = Integer.parseInt(str); // 抛异常 System.out.println(n1); &#125;&#125; 本章作业 本章作业 123456789101112131415161718public class Homework01 &#123; //编写一个main方法 public static void main(String[] args) &#123; int n1; n1 = 13; int n2; n2 = 17; int n3; n3 = n1 + n2; System.out.println(&quot;n3 = &quot; + n3);//30 int n4 = 38; int n5 = n4 - n3; System.out.println(&quot;n5 = &quot; + n5);//8 &#125;&#125; 123456789101112131415161718192021public class Homework02 &#123; //编写一个main方法 public static void main(String[] args) &#123; //使用 char 类型，分别保存 \\n \\t \\r \\\\ 1 2 3等字符，并打印输出 char c1 = &#x27;\\n&#x27;; //换行 char c2 = &#x27;\\t&#x27;; //制表位 char c3 = &#x27;\\r&#x27;; //回车 char c4 = &#x27;\\\\&#x27;; //输出\\ char c5 = &#x27;1&#x27;; //换行 char c6 = &#x27;2&#x27;; //换行 char c7 = &#x27;3&#x27;; //换行 System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); System.out.println(c5); System.out.println(c6); System.out.println(c7); &#125;&#125; 12345678910111213141516171819202122public class Homework03 &#123; //编写一个main方法 public static void main(String[] args) &#123; //编程，保存两本书名，用+拼接，看效果。保存两个性别， //用加号拼接，看效果。保存两本书价格，用加号拼接，看效果 String book1 = &quot;天龙八部&quot;; String book2 = &quot;笑傲江湖&quot;; System.out.println(book1 + book2);//天龙八部笑傲江湖 //性别应该使用char保存 char c1 = &#x27;男&#x27;; char c2 = &#x27;女&#x27;; System.out.println(c1 + c2);//得到 男 字符码值 + 女 字符码值 //保存两本书价格 double price1 = 123.56; double price2 = 100.11; System.out.println(price1 + price2);//就是 123.56+100.11 &#125;&#125; 1234567891011121314151617181920212223242526public class Homework04 &#123; //编写一个main方法 public static void main(String[] args) &#123; /* 姓名 年龄 成绩 性别 爱好 xx xx xx xx xx 要求： 1) 用变量将姓名、年龄、成绩、性别、爱好存储 2) 使用+ 3) 添加适当的注释 4) 添加转义字符, 使用一条语句输出 */ //姓名 String name = &quot;jack&quot;; int age = 20; double score = 80.9; char gender = &#x27;男&#x27;; String hobby = &quot;打篮球&quot;; //输出了信息, 可以使用换行 System.out.println(&quot;姓名\\t年龄\\t成绩\\t性别\\t爱好\\n&quot; + name + &quot;\\t&quot; + age + &quot;\\t&quot; + score + &quot;\\t&quot; + gender + &quot;\\t&quot; + hobby); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://blog1.cpen.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog1.cpen.top/tags/Java/"},{"name":"编码","slug":"编码","permalink":"https://blog1.cpen.top/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"01_Java-特性-jdk-运行机制-转义字符-注释-代码规范","slug":"Java/01_Java-特性-jdk-运行机制-转义字符-注释-代码规范","date":"2022-09-21T04:00:00.000Z","updated":"2022-09-21T05:00:00.000Z","comments":true,"path":"posts/12907.html","permalink":"https://blog1.cpen.top/posts/12907.html","excerpt":"","text":"视频链接：https://www.bilibili.com/video/BV1fh411y7R8 一. 就业方向 二. 开发场景 Java 开发场景举例 1-SSM Java 开发场景举例 2：Android 核心代码 Java 开发场景举例 3：大数据-hadoop 三. 应用领域 企业级应用 主要指复杂的大企业的**软件系统、各种类型的网站**。应用领域包括金融、电信、交通、电子商务等。 Android 平台应用 Android 应用程序使用 Java 语言编写。Android 开发水平的高低很大程度上取决于 Java 语言核心能力是否扎实。 移动领域应用 主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括机顶盒、车载的大屏影音娱乐设备、汽车通信设备、扫码的 POS 机等。 四. 程序举例 什么是程序 程序：计算机执行某些操作或解决某个问题而 编写的一系列有序指令的集合 举例说明: 123456789//老师写的最简单的程序，完成 1+1, 体会public class Test &#123; public static void main(String[] args) &#123; int res = 1 + 1; // 显示 System.out.print(&quot;结果=&quot; + res); &#125;&#125; 五. 故事 Java 诞生小故事 1995年 第1个版本 Java之父 gosling 最新版本：15 公司里用的最多的版本：8、11 Java 所有权：甲骨文 Java 技术体系平台 标准版、企业版、小型版 Java SE、Java EE、Java ME 六. 特性 Java 重要特点 Java 语言是面向对象的(oop) Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证 Java 语言是**跨平台性的**。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台] Java 语言是解释型的[了解] ​ 解释性语言：javascript,PHP, java 编译性语言: c / c++ ​ 区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行, c /c++ Java 的开发工具 工具选择 如何选择开发工具 ​ 我们先选择用文本编辑器本 sublime，到大家对 java 有一定了解后，我们再使用 IDEA 和 Eclipse 开发工具。 这是为什么呢 ​ 更深刻的理解 java 技术,培养代码感。【面试时，往往程序员手写代码】 ​ 有利于公司面试 七. jdk介绍、安装、配置 Java 运行机制及运行过程 Java 语言的特点：跨平台性 Java 核心机制-Java 虚拟机 [JVM java virtual machine] Java 核心机制-Java 虚拟机 [JVM java virtual machine] 基本介绍 JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在 JDK 中. 对于不同的平台，有不同的虚拟机。 Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次**编译，到处运行**” [说明] 示意图 123//指令 javac // 编译 java // 运行 什么是 JDK，JRE JDK 基本介绍 JDK 的全称(Java Development Kit Java 开发工具包) ​ JDK = JRE + java 的开发工具 [java, javac,javadoc,javap 等] JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。 JRE 基本介绍 JRE(Java Runtime Environment Java 运行环境) ​ JRE = JVM + Java 的核心类库[类] 包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。 JDK、JRE 和 JVM 的包含关系 JDK = JRE + 开发工具集（例如 Javac,java 编译工具等) JRE = JVM + Java SE 标准类库（java 核心类库） 如果只想运行开发好的 .class 文件 只需要 JRE 下载、安装 JDK https://www.oracle.com/java/technologies/downloads/ 配置环境变量 path 为什么要配置 path 配置环境变量 path 的步骤 安装 JDK 的练习 请同学们安装好 JDK，配置好 path 环境变量。可以在控制台下正确的执行, (10min) 环境变量配置细节说明: 八. 快速入门 需求说明 要求开发一个 Hello.java 程序，可以输出 “hello,world!” 开发步骤 将 Java 代码编写到扩展名为 Hello.java 的文件中。[代码说明] 通过 javac 命令对该 java 文件进行编译，生成 .class 文件。 通过 java 命令对生成的 class 文件进行运行。 运行原理示意图 12345678910111213141516171819202122232425262728293031323334353637//这是java的快速入门， 演示java的开发步骤//对代码的相关说明//1. public class Hello 表示Hello是一个类,是一个public公有的类//2. Hello&#123; &#125; 表示一个类的开始和结束//3. public static void main(String[] args) 表示一个主方法,即我们程序的入口//4. main() &#123;&#125; 表示方法的开始和结束//5. System.out.println(&quot;hello,world~&quot;); 表示输出&quot;hello,world~&quot;到屏幕//6. ;表示语句结束public class Hello &#123; //编写一个main方法 public static void main(String[] args) &#123; System.out.println(&quot;韩顺平教育 hello&quot;); &#125;&#125;//一个源文件中最多只能有一个public类。其它类的个数不限。[演示]//Dog 是一个类//编译后，每一个类，都对于一个.classclass Dog &#123; //一个源文件中最多只能有一个public类。其它类的个数不限，也可以将main方法写在非public类中， //然后指定运行非public 类，这样入口方法就是非public 的main方法 public static void main(String[] args) &#123; System.out.println(&quot;hello, 小狗狗~&quot;); &#125;&#125;class Tiger &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello, 小老虎~&quot;); &#125;&#125; 九. 运行机制 Java 开发快速入门 Java执行流程分析 .java文件 源文件 .class文件 字节码文件 什么是编译 什么是运行 十. 开发细节 Java开发注意事项和细节说明 1234567891011121314151617181920212223242526public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;韩顺平教育 hello&quot;); &#125;&#125;//一个源文件中最多只能有一个public类。其它类的个数不限。[演示]//Dog 是一个类//编译后，每一个类，都对于一个.classclass Dog &#123; //一个源文件中最多只能有一个public类。其它类的个数不限，也可以将main方法写在非public类中， //然后指定运行非public 类，这样入口方法就是非public 的main方法 public static void main(String[] args) &#123; System.out.println(&quot;hello, 小狗狗~&quot;); &#125;&#125;class Tiger &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello, 小老虎~&quot;); &#125;&#125; 十一. 学习方法 老韩聊: 如何快速掌握技术或知识点 十二. 转义字符 Java 转义字符 Java 常用的转义字符 在控制台，输入 tab 键，可以实现命令补全 \\t ：一个制表位，实现对齐的功能 \\n ：换行符 \\\\ ：一个\\ \\&quot; :一个&quot; \\' ：一个' \\r :一个回车 System.out.println(“韩顺平教育\\r 北京”); 说明 应用实例 12345678910111213141516171819202122232425//演示转义字符的使用public class ChangeChar &#123; //编写一个main方法 public static void main(String[] args) &#123; // \\t ：一个制表位，实现对齐的功能 System.out.println(&quot;北京\\t天津\\t上海&quot;); // \\n ：换行符 System.out.println(&quot;jack\\nsmith\\nmary&quot;); // \\\\ ：一个\\ \\\\ System.out.println(&quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;); // \\&quot; :一个&quot; System.out.println(&quot;老韩说:\\&quot;要好好学习java,有前途\\&quot;&quot;); // \\&#x27; ：一个&#x27; System.out.println(&quot;老韩说:\\&#x27;要好好学习java,有前途\\&#x27;&quot;); // \\r :一个回车 System.out.println(&quot;韩顺平教育\\r北京&quot;); // 解读 // 1. 输出 韩顺平教育 // 2. \\r表示回车 System.out.println(&quot;韩顺平教育\\r北京&quot;); // 北京平教育 &#125;&#125; 课堂练习 要求：请使用一句输出语句，达到输入如下图形的效果 2min 123456789101112131415161718public class ChangeCharExer01 &#123; //编写一个main方法 public static void main(String[] args) &#123; //完成代码 System.out.println(&quot;书名\\t作者\\t价格\\t销量\\n三国\\t罗贯中\\t120\\t1000&quot;); //示意 =&gt; 可读性很好 //下面代码完成 两个数相加 //定义变量 int n1 = 10; int n2 = 30; //求和 int sum = n1 + n2; //输出结果 System.out.println(&quot;结果=&quot; + sum); &#125;&#125; 十三. 易犯错误 十四. 注释 注释(comment) 介绍： ​ 用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性（可读性）；注释是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。 [举例] Java 中的注释类型 单行注释 // 多行注释 /* */ 文档注释 /** */ 单行注释： 基本格式 格式： //注释文字 多行注释： 基本格式 格式： /* 注释文字 */ 123456789101112131415161718192021222324252627//演示注释使用public class Comment01 &#123; //编写一个main方法 public static void main(String[] args) &#123; //单行注释 //多行注释 /* 示意 =&gt; 可读性很好 下面代码完成 两个数相加 定义变量 注释 注释 int n1 = 10;... System.out.println(&quot;ok~~&quot;); */ int n1 = 10; int n2 = 30; //求和 int sum = n1 + n2; //输出结果 System.out.println(&quot;结果=&quot; + sum); &#125;&#125; 使用细节 被注释的文字，不会被 JVM（java 虚拟机）解释执行 多行注释里面不允许有多行注释嵌套 文档注释： 12345678910/** * @author 韩顺平 * @version 1.0 */public class Comment02 &#123; //编写一个main方法 public static void main(String[] args) &#123; &#125;&#125; javadoc 标签 javadoc 工具软件识别以下标签： 标签 描述 示例 @author 标识一个类的作者 @author description @deprecated 指名一个过期的类或成员 @deprecated description 指明当前文档根目录的路径 Directory Path @exception 标志一个类抛出的异常 @exception exception-name explanation 从直接父类继承的注释 Inherits a comment from the immediate surperclass. 插入一个到另一个主题的链接 插入一个到另一个主题的链接，但是该链接显示纯文本字体 Inserts an in-line link to another topic. @param 说明一个方法的参数 @param parameter-name explanation @return 说明返回值类型 @return explanation @see 指定一个到另一个主题的链接 @see anchor @serial 说明一个序列化属性 @serial description @serialData 说明通过writeObject( ) 和 writeExternal( )方法写的数据 @serialData description @serialField 说明一个ObjectStreamField组件 @serialField name type description @since 标记当引入一个特定的变化时 @since release @throws 和 @exception标签一样. The @throws tag has the same meaning as the @exception tag. 显示常量的值，该常量必须是static属性。 Displays the value of a constant, which must be a static field. @version 指定类的版本 @version info 代码演示 十五. 代码规范 Java 代码规范 十六. DOS原理-路径-DOS指令 DOS 命令(了解) DOS 介绍 Dos： Disk Operating System 磁盘操作系统, 简单说一下 windows 的目录结构。[原理图] 原理图 相关的知识补充: 相对路径， 绝对路径 常用的 dos 命令 查看当前目录是有什么内容 dir ​ dir dir d:\\abc2\\test200 切换到其他盘下：盘符号 cd : change directory ​ 案例演示：切换到 c 盘 cd /D c: 切换到当前盘的其他目录下 (使用相对路径和绝对路径演示), …\\表示上一级目录 ​ 案例演示： cd d:\\abc2\\test200 cd …\\…\\abc2\\test200 切换到上一级： ​ 案例演示： cd .. 切换到根目录：cd \\ ​ 案例演示：cd \\ 查看指定的目录下所有的子级目录 tree 清屏 cls 退出 DOS exit 说明: 因为小伙伴后面使用 DOS 非常少，所以对下面的几个指令，老韩给大家演示下, 大家了解即可 (md[创建目录],rd[删除目录],copy[拷贝文件],del[删除文件],echo[输入内容到文件],type,move[剪切]) =&gt; Linux, 十七. 本章作业 本章作业 1 12345678public class Homework01 &#123; //编写一个main方法 public static void main(String[] args) &#123; //编写hello, world程序 System.out.println(&quot;hello,world&quot;); &#125;&#125; 2 12345678910//将个人的基本信息（姓名、性别、籍贯、住址）打印到控制台上输出。各条信息分别占一行//public class Homework02 &#123; //编写一个main方法 public static void main(String[] args) &#123; //考察对转义字符 System.out.println(&quot;姓名\\t性别\\t籍贯\\t住址\\n顺平\\t男\\t四川\\t北京&quot;); &#125;&#125; 3 12345//JDK,JRE,JVM的关系//答：1. JDK = JRE + java开发工具2. JRE = JVM + 核心类库 4 1234//环境变量path配置及其作用1. 环境变量的作用是为了在 dos 的任意目录，可以去使用 java 和 javac 命令2. 先配置 JAVA_HOME = 指向 jdk 安装的主目录3. 编辑 path 环境变量，增加 %JAVA_HOME%\\bin 5 1234//Java编写步骤1. 编写java的源代码2. javac 编译 ,得到对应的 .class 字节码文件3. java 运行, 本质就是把 .class 加载到 jvm 运行 6 12345678//Java编写7个规范1. 类,方法的注释，使用javadoc的方式，即文档注释2. 非javadoc注释，往往是对代码的说明(给程序的维护者),说明如何修改，注意事项3. 使用tab ，整体将代码右移, 使用 shift+tab 整体左移4. 运算符和 = 的两边，给空格，代码看上去清楚 int n = 1 + 4;5. 源码文件使用 utf-8 编码6. 行宽字符不要超过 807. 代码编程风格有两种 次行风格，行尾风格(推荐) 7 12345678//初学者java易犯错误 1. 编译或者运行时，找不到文件 javac Hell0.java, 把文件名或者目录找对2. 主类名和文件名不一致 , 修改时保持一致即可3. 缺少;4. 拼写错误，比如 1 -&gt; l 0-&gt;0, void -&gt; viod , 要求写代码时，一定要小心强调: 先思考-&gt;自己练习-&gt;看老师评讲","categories":[{"name":"Java","slug":"Java","permalink":"https://blog1.cpen.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog1.cpen.top/tags/Java/"}]},{"title":"01_Hexo-Hexo + Pure搭建博客-自定义","slug":"Hexo/01_Hexo-Hexo+hexo-theme-pure搭建博客","date":"2022-09-20T04:00:00.000Z","updated":"2022-09-20T05:00:00.000Z","comments":true,"path":"posts/8236.html","permalink":"https://blog1.cpen.top/posts/8236.html","excerpt":"","text":"Hexo 搭建私人博客 一. 介绍 1.1 Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo 官网 1.2 Pure 主题 https://github.com/cofess/hexo-theme-pure https://blog.cofess.com/ 二. 参考 Hexo 官网 https://hexo.io/zh-cn/docs/index.html Pure 项目地址 https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md 搭建 &amp; 魔改 Pure 项目中文文档 https://hwame.top 作者: Hexo博客主题pure使用说明 https://www.cnblogs.com/zzk31/p/14062887.html https://blog.csdn.net/qq_42983502/article/details/106745567 gitalk https://www.jianshu.com/p/b1161eb3f848 https://cors-anywhere.herokuapp.com/corsdemo https://www.cnblogs.com/qisi007/p/13731562.html https://www.jianshu.com/p/02fc71f3633f 三. 命令 1hexo clean ; hexo g ; hexo d ; hexo s 四. 评论 &amp; 收录 Valine 评论 https://www.leancloud.cn/ Valine 评论 https://www.leancloud.app/ 国外站点，国内账号受限，域名没白嫖成功，可能是这个原因 → https://forum.leancloud.cn/t/2022-8/25408 谷歌收录 https://search.google.com/search-console 百度收录 https://ziyuan.baidu.com MD5 在线加密 https://md5jiami.bmcx.com/ 评论区通过密文，识别博主身份 五. 相关路径 123456789101112131415161718[文章路径]: \\source\\_posts[站点配置文件]: \\_config.yml[主题配置文件]: \\themes\\pure\\_config.yml &quot;关于、个人介绍、公告&quot;[友链文件]: \\source\\_data\\links.yml[语言]: \\themes\\pure\\languages[左下角运行时间]: \\themes\\pure\\layout\\_common\\footer.ejs &quot;时间、版权&quot;[评论角色配置]: \\themes\\pure\\layout\\_script\\_comment\\valine.ejs[css样式]: \\themes\\pure\\source\\css\\style.css[搜索栏限制]: \\themes\\pure\\source\\js\\insight.js &quot;160行&quot; 六. 内容样例 12345678910111213---title: Testdate: 2022-08-28 00:09:00updated: 2022-08-28 00:09:01thumbnail: https://cdn.iocdn.cc/npm/mycpen-image-bed@0.0.0-elcfumuvhm/image/test.pngtags: - Testcategory: - Testtoc: truetop: true---描述&lt;!-- more --&gt; 文章指定多个 category 多个分类 如果我们的要求是将文章同时分到两个或者多个不同的类目下呢？官方给出的方法是： 123categories: - [Sports] - [Baseball] 参考文章：Hexo 一篇文章多个 categories https://www.jianshu.com/p/4438c417611e 七. 自定义 7.1 搜索框索引突破 5 F12 定位到搜索框的 类选择器 为 ins-section-header grep，定位到配置文件为 \\themes\\pure\\source\\js\\insight.js Ctrl + F，搜索 5，定位到第 160 行，修改限制 7.2 左侧头像链接，target 修改为 _self a 标签，修改 target: ‘_blank’ → ‘_self’ 7.3 文章目录，一级标题不跳转 有时发现一级标题不会跳转 配置文件 \\node_modules\\hexo\\lib\\plugins\\helper\\toc.js 更新下 \\node_modules\\hexo\\lib\\plugins\\helper\\toc.js 文件，又正常了。时灵时不灵的。。。 参考 https://hwame.top/如何取消文章目录的自动编号 修改 “.\\node_modules\\hexo-renderer-markdown-it\\index.js” level 为 1 参考文章： https://blog.csdn.net/Fosu_Chenai/article/details/111192850 评论 7.4 滚动条加粗 + 加小箭头 修改 css 样式，路径 .\\hexo-source\\themes\\pure\\source\\css\\style.css Ctlrl + F 定位 scrollbar； 调高 height，使代码框 右拉滚动条加粗； 右侧下拉条变粗； 7.4.1 代码框加粗 123456789/* * scrollbar */::-webkit-scrollbar &#123; width: 15px; height: 14px; # 调高 background: transparent;&#125; 7.4.2 右侧下拉条变粗 + 添加小箭头 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 滚动条箭头 */::-webkit-scrollbar-button &#123; width: 0px; height: 4px; display: block; background-color: #c3c3c3;&#125;::-webkit-scrollbar &#123; width: 16px; border: 5px solid white;&#125;::-webkit-scrollbar-thumb &#123; background-color: #b0b0b0; background-clip: padding-box; border: 0.05em solid #eeeeee;&#125;::-webkit-scrollbar-track &#123; background-color: #bbbbbb;&#125;/* Buttons */::-webkit-scrollbar-button:single-button &#123; background-color: #bbbbbb; display: block; border-style: solid; height: 13px; width: 16px;&#125;/* Up */::-webkit-scrollbar-button:single-button:vertical:decrement &#123; border-width: 0px 8px 8px 8px; border-color: transparent transparent #555555 transparent;&#125;::-webkit-scrollbar-button:single-button:vertical:decrement:hover &#123; border-color: transparent transparent #777777 transparent;&#125;/* Down */::-webkit-scrollbar-button:single-button:vertical:increment &#123; border-width: 8px 8px 0 8px; border-color: #555555 transparent transparent transparent;&#125;::-webkit-scrollbar-button:vertical:single-button:increment:hover &#123; border-color: #777777 transparent transparent transparent;&#125; 参考文章 右侧下拉条新增箭头 :-webkit-scrollbar 滚动条整体部分 https://www.php.cn/css-tutorial-475268.html 7.5 Valine 评论框添加一言 参考文章 https://blog.justlovesmile.top/posts/27831.html 偶然看到的文章，然后自己就加了这个功能。 路径：.\\themes\\pure\\layout\\_script\\_comment\\valine.ejs； 加到最后 &lt;/script&gt; 标签之前；c=j 请求获得网易云的句子，开始网抑云吧； 123456fetch(&#x27;https://v1.hitokoto.cn/?c=j&#x27;).then(response =&gt; response.json()).then(data =&gt; &#123; document.getElementById(&quot;veditor&quot;).setAttribute(&quot;placeholder&quot;,data.hitokoto+&quot;__&quot;+data.from);&#125;).catch(console.error) 修改方法： 找到博客对应添加valine的位置，例如Ayer主题的位于hexo\\themes\\ayer\\layout_partial\\post\\valine.ejs 在内部添加一段代码： 12345678&lt;script type=&quot;text/javascript&quot;&gt; fetch(&#x27;https://v1.hitokoto.cn&#x27;) .then(response =&gt; response.json()) .then(data =&gt; &#123; document.getElementById(&quot;veditor&quot;).setAttribute(&quot;placeholder&quot;,data.hitokoto+&quot;__&quot;+data.from); &#125;) .catch(console.error)&lt;/script&gt; Api接口说明： （1）https://v1.hitokoto.cn/ （从7种分类中随机抽取） （2）https://v1.hitokoto.cn/?c=b （请求获得一个分类是漫画的句子） 参数 说明 a 动画 b 漫画 c 游戏 d 文学 e 原创 f 来自网络 g 其他 h 影视 i 诗词 j 网易云 k 哲学 l 抖机灵 其他 作为动画类型处理 可选择多个分类，例如： ?c=a&amp;c=c （3）https://v1.hitokoto.cn/?c=f&amp;encode=text （请求获得一个来自网络的句子，并以纯文本格式输出） 返回的格式说明 返回参数名称 描述 id 一言标识 hitokoto 一言正文。编码方式 unicode。使用 utf-8。 type 类型 from 一言的出处 from_who 一言的作者 creator 添加者 creator_uid 添加者用户标识 reviewer 审核员标识 uuid 一言唯一标识；可以链接到 https://hitokoto.cn?uuid=[uuid] 查看这个一言的完整信息 commit_from 提交方式 created_at 添加时间 length 句子长度 例如：返回的data,通过data.hitokoto获取句子正文 作者: Justlovesmile 链接: https://blog.justlovesmile.top/posts/27831.html 来源: Justlovesmile’s BLOG 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 PS：这位大佬的博客真好看~~ 7.6 左侧 归档、分类 改为默认收起 默认是展开的 修改以下文件，改为收起状态。如图 style=“height: 0px” 应该可以不用写，收起状态默认就是 0 ~~ .\\themes\\pure\\layout\\categories.ejs .\\themes\\pure\\layout\\_partial\\archive.ejs 八. 未解决的小需求 （已解决，#7.3）一级目录，右侧导航栏 有时跳转失败； Valine 评论系统，下面的评论 被@后，未显示 @信息，而别人的是成功的； 我的 其他大佬的 引用时 使用 #，会被导航目录误认为 一级标题； （已解决）生成在 /public 目录的静态文件都被压缩了，我看别人的没被压缩，不清楚啥原因。 因为配置了这个 https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md 博客优化 压缩了文件 （已解决）文章内部一级、二级…标题左侧无锚点 理想效果图 似乎是环境配置问题，我用虚拟机推送静态文件，就有显示；用真实 win机 推送 就没有锚点，重装 git 也没显示（可能不是 git 的问题）。。。 因为压缩了静态文件，全部注释 hexo-neat 配置。 参考 https://github.com/cofess/hexo-theme-pure#hexo-neat https://github.com/rozbo/hexo-neat#options 无伤大雅，我一般一级标题写的是文章标题；评论区也就是个摆设；静态文件被压缩，可能别人还觉得我是故意，嘿~~ 最后总结：魔改要适量，太费时 还得不到提升，不如多看几个前端视频 多写几篇文章。。。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"},{"name":"Pure","slug":"Pure","permalink":"https://blog1.cpen.top/tags/Pure/"}]},{"title":"22_Linux基础-ansible1","slug":"Linux_基础/22_Linux基础-ansible1","date":"2022-09-19T04:00:00.000Z","updated":"2022-09-19T05:00:00.000Z","comments":true,"path":"posts/22091.html","permalink":"https://blog1.cpen.top/posts/22091.html","excerpt":"","text":"一. selinux、established 123456789101112131415161718192021222324252627282930313233343536373839示例1：永久修改selinux--------------------------------------------------------------------------------------------[root@cPen_A ~]# vim /etc/selinux/config SELINUX=disabled============================================================================================示例：排查连接不上 4.00 - 9.00没写完ps -ef igrep sshdlsof -i:2233cat /etc/services[root@cPen_B ~]# netstat -anplut igrep sshActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:2233 0.0.0.0:* LISTEN 911/sshd tcp 0 36 192.168.0.31:2233 192.168.0.42:54290 ESTABLISHED 1402/sshd: root [pr tcp6 0 0 :::2233 :::* LISTEN 911/sshd udp 0 0 192.168.0.31:68 192.168.0.250:67 ESTABLISHED 893/NetworkManager [root@cPen_B ~]# netstat -aplut igrep sshActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:infocrypt 0.0.0.0:* LISTEN 911/sshd tcp 0 36 cPen_B:infocrypt 192.168.0.42:54290 ESTABLISHED 1402/sshd: root [pr tcp6 0 0 [::]:infocrypt [::]:* LISTEN 911/sshd udp 0 0 cPen_B:bootpc 192.168.0.250:bootps ESTABLISHED 893/NetworkManager ##############################################################################################################示例2：看当前系统有多少连接 (establish)--------------------------------------------------------------------------------------------[root@cPen_B ~]# netstat -anplut|grep -E &quot;ESTABLISHED|LISTEN|TIME_WAIT&quot;|awk -F&quot; &quot; &#123;&#x27;print $6&#x27;&#125;|sort|uniq -c 2 ESTABLISHED 2 LISTEN#-------------------------------------------------------------------------------[root@cPen_B ~]# netstat -anplutActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:2233 0.0.0.0:* LISTEN 911/sshd tcp 0 232 192.168.0.31:2233 192.168.0.42:54290 ESTABLISHED 1402/sshd: root [pr #-------------------------------------------------------------------------------------------------------------# pstree 查看进程之间的关系# netstat 查看当前网络连接 二. SSH访问控制 SSH使用TCP Wrappers实现访问控制 # 注：做访问控制 主要配置文件 /etc/hosts.allow /etc/hosts.deny TCP Wrappers可以控制哪些服务 受super daemon（xinetd）管理的服务 # 注：守护进程的服务 支持libwrap.so模块的服务 TCP Wrappers的访问控制原则 首先检查 hosts.allow 文件，若找到相匹配的策略，则允许访问 否则继续检查 hosts.deny 文件，若找到相匹配的策略，则拒绝访问 如果两个文件中都没有相匹配的策略，则允许访问 #注：守护进程层面的控制 12345示例：/etc/hosts.deny---------------------------------------------------------------------------------------------------------------------------------[root@cPen_A ~]# vim /etc/hosts.deny sshd:192.168.0.31 # 注：访问控制，拒绝192.168.0.31 不需要重启服务，有守护进程帮它控制 #注：主机公钥在 /etc/ssh/下面 默认使用ecdsa模式 #注：known_hosts文件里有什么 前面是ip地址，后面是公钥 #注：authorized_keys 放受信任的公钥 三. ssh隧道 #注：本地端口转发 CSDN https://www.cnblogs.com/keerya/p/7612715.html 端口转发：A、C、B主机。主机B起了个nginx服务 端口号80；主机A不能直接访问主机B，但主机A可以访问主机C，主机C可以访问主机B (A–&gt;C–&gt;B)；A可以ssh到C，A跳到C，然后访问B的80端口 (nginx)。现在 在主机C上面建立一个隧道，隧道开启15577端口连接B的80端口，A去访问15577端口相当于去访问B的80映射 #注：ssh隧道 第一个用于不能直接访问的情况；第二个考虑密文传输 12345678910[root@cPen_C ~]# lsof -i:15577 # 注：在C主机上操作，15577端口未被占用[root@cPen_C ~]# ssh -g -L 15577:192.168.0.39:80 sanchuang@192.168.0.39 -p 2233#注：192.168.0.39 右边B主机ip地址 # 注：在C主机上开通一个隧道 端口为15577[root@cPen_A ~]# curl 192.168.0.48:15577 # 注：模仿网络访问 (80端口nginx网页使用curl访问)&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt; # 注：返回的内容#注：192.168.0.48 中间C主机ip地址 # 注：注意防火墙 iptables -F#注：访问中间C主机的15577端口 转接成右边B主机的80端口#注：注意 不能绑定到本地的回环地址 127.0.0.1 只能访问自己 (所以 -g) -g作用 本地所有ip都是访问#注：- L是本地端口转发#注：一般可以开启65535个端口 #总结：ssh隧道 端口转发 1、关闭防火墙 2、关闭selinux #本地端口转发 # ssh -g -L 15577:192.168.0.39:80 192.168.0.39 -p 2233 # 注：C主机上执行 把B主机80端口映射本地15577端口* ​ B主机80端口 B主机 实验环境： A主机：192.168.0.132 C主机：192.168.0.48 B主机：192.168.0.39 在C主机上执行：[root@cPen_C ~]# ssh -g -L 15577:192.168.0.39:80 192.168.0.39 -p 2233 把B主机的80端口映射到本地的15577端口 访问C主机的15577端口就是访问B主机的80端口 #远程端口转发 # ssh -R 15566:192.168.0.39:80 -fN 192.168.0.132 -p 2233 # 注：C主机上 把B主机80端口 映射到 A主机15566端口 ​ B主机 80端口 A主机 远程端口转发：在C主机上执行：[root@C .ssh]# ssh -R 15566:192.168.0.39:80 -fN 192.168.0.132 -p 2233 把B主机的80端口映射到A主机的15566端口 访问A主机的15566就是访问B主机的80 #注：A主机 192.168.0.132 #注：B主机 192.168.0.39 #注：在C主机上建立远程通道，在C主机上为A主机启动15566端口，映射到B主机 12345[root@cPen_A ~]# lsof -i:15566 # 注：A主机开启15566端口sshd 2067 root 8u IPv6 38604 0t0 TCP localhost:15566 (LISTEN) # 注：监听的是本地回环地址sshd 2067 root 9u IPv4 38605 0t0 TCP localhost:15566 (LISTEN)[root@cPen_A ~]# curl 127.0.0.1:15566 # 注：访问本地15566端口映射到B主机的80端口&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt; # 返回的内容 四. ansible服务 ansible是一个自动化运维工具的名称 基于Python开发，集合了众多运维工具的优点（puppet,fabric,slatstack），实现批量系统配置，程序的部署，批量运行命令等 .-------------------------------------------------------------------------------------------------------------------------------------------- Linux运维：自动化（脚本），智能化，平台化 Linux运维人员，人肉运维不可取 诞生了一系列的运维工具，ansible就是其中之一 .-------------------------------------------------------------------------------------------------------------------------------------------- 日常运维： 1、软件安装 2、服务的配置 3、运行脚本 4、升级 5、备份 .-------------------------------------------------------------------------------------------------------------------------------------------- ansible基于Python开发，依赖于：paramiko,PyYaml和jinja三个关键组件 基于ssh协议，只要……没写完 #其他服务需要部署agent，而ansible只需要部署到server，只要十万台的key都上传到其他机器上 #注：glibc 内核底层的库 .-------------------------------------------------------------------------------------------------------------------------------------------- #实验环境 a： 192.168.0.132（ansible） c: 192.168.0.48 b: 192.168.0.39 实验前提，做好免密码认证，详见ssh服务 a --&gt; b , a --&gt; c a可以免密码登录到b和c 1、在a上安装ansible [root@cPen_A .ssh]# yum install epel-release # 注：安装epel源 [root@cPen_A .ssh]# yum install ansible # 注：安装ansible 2、配置 配置目录： /etc/ansible/ansible.cfg ansible的主配置文件，这个文件主要定义了roles_path路径,主机清单路径,连接清单中的主机方式等配置,这些大部的默认配置已经足够我们平时使用,如需要特别配置可以自行去修改 /etc/ansible/hosts 这个配置文件就是默认的主机清单配置文件，可以通过ansible.cfg重新定义 备份/etc/ansible/hosts文件 编辑/etc/ansible/hosts文件 #将需要管理的主机添加到webser组 #如果通过ssh登录的端口不是22号端口，就需要在配置文件中指明端口号 12345678[root@cPen_A ansible]# cp hosts&#123;,.bak&#125; # 注：备份[root@cPen_A ansible]# lsansible.cfg hosts hosts.bak roles[root@cPen_A ansible]# &gt;hosts # 注：老的清空[root@cPen_A ansible]# vim hosts [webser]192.168.0.31:2233192.168.0.55 ansible组成： ​ 1、host inventory --#定义客户机，可以对客户机进行分类：db类，web类…等等 ​ 2、playbook --#剧本 让主机按照我给定的剧本去完成一些事情 ​ 3、module --#模块 实现一个个功能的程序 ​ 4、pluging --#插件 实现一些额外的小功能 .-------------------------------------------------------------------------------------------------------------------------------------------- 1234567891011121314151617181920212223242526272829[root@cPen_A /]# cd /etc[root@cPen_A etc]# ls |grep ansibleansible[root@cPen_A etc]# cd ansible[root@cPen_A ansible]# lsansible.cfg hosts roles # 注：host定义主机清单[root@cPen_A ansible]# less ansible.cfg #inventory = /etc/ansible/hosts # 注：主机清单#library = /usr/share/my_modules/#module_utils = /usr/share/my_module_utils/#remote_tmp = ~/.ansible/tmp……[root@cPen_A ansible]# less hosts ## [webservers] # 注：[中括号]里webservers 组名 对这个组进行访问控制## alpha.example.org## beta.example.org## 192.168.1.100## 192.168.1.1103、ansible使用-m 指定模块名HOST-PATTERN #匹配主机模式,如all表示所有主机-m MOD_NAME #模块名 如:ping-a MOD_ARGS #模块执行的参数-f FORKS #生成几个子进行程执行-C #(不执行，模拟跑)-u Username #某主机的用户名-c CONNection #连接方式（default smart） .-------------------------------------------------------------------------------------------------------------------------------------------- ansible 主执行程序,一般用于命令行下执行 ansible-playbook 执行playbook中的任务 ansible-doc 获取各模块的帮助信息 .-------------------------------------------------------------------------------------------------------------------------------------------- 12345678910111213141516171819[root@cPen_A ~]# ansible -h # 注：ansible -h帮助文档#-------------------------------------------------------------------------[root@cPen_A ~]# ansible………………ansible: error: too few arguments[root@cPen_A ~]# which ansible/usr/bin/ansible[root@cPen_A ~]# ls -al /bin/ansiblelrwxrwxrwx 1 root root 20 11月 24 16:41 /bin/ansible -&gt; /usr/bin/ansible-2.7Ansible[root@cPen_A ~]# ansible all -m shell -a &quot;ip a&quot; # 注：匹配所有主机 使用shell模块 执行ip a#注：指定ansible……没写完都执行命令[root@cPen_A ~]# ansible all -m shell -a &quot;mkdir /tmp/sc&quot;……192.168.0.55 | CHANGED | rc=0 &gt;&gt; # 注：返回0 执行执行成功……[root@cPen_A ~]# ansible webser -m shell -a &quot;mkdir /tmp/sc&quot; # 注：匹配webser组192.168.0.55 | FAILED | rc=1 &gt;&gt; # 注：返回1 表示执行失败","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Ansible","slug":"Ansible","permalink":"https://blog1.cpen.top/tags/Ansible/"}]},{"title":"21_Linux基础-ssh服务3","slug":"Linux_基础/21_Linux基础-ssh服务3","date":"2022-09-18T04:00:00.000Z","updated":"2022-09-18T05:00:00.000Z","comments":true,"path":"posts/57744.html","permalink":"https://blog1.cpen.top/posts/57744.html","excerpt":"","text":"一. 回顾 1.1 ssh ssh secure shell 远程登录连接，控制主机 数据的传输都是加密的 基于非对称加密技术 1.2 加密技术 加密技术 对称加密 双方共同拥有一把钥匙，其中一方拿着加密，另外一方就拿着解密 弊端：这个公钥的钥匙很容易被有心人获取 非对称加密 使用公钥对进行加解密 生成一对钥匙，其中一方作为私钥，另一方就是公钥 私钥是只有自己知道，私钥保存在本地 公钥是给需要通信的人，公钥可以给其他人 使用公钥加密，私钥解密，一般用在数据加密传输 (A、B 2个人，B给A用加密的方式传输数据，私钥在A手里，B用A的公钥对数据加密) 使用私钥加密，公钥解密，一般用于认证 (A向B发送数据，B用于确认是不是A发送的数据，客户端A用A的私钥对数据进行加密，服务端B拿A的公钥进行解密。只管认证，不管加密性) 1.3 ssh登录 ssh登录 登录方式 密码登录 流程 1、客户端发送登录请求 2、服务器发送机器的公钥发送给客户端 3、客户端用服务器的公钥对密码进行加密，发送给服务端 4、服务器收到密文之后，用私钥进行解密，与/etc/shadow进行验证 5、返回验证结果 密钥登录，公钥认证 1、客户端生成公钥对 2、将客户端的用户公钥发送给服务器，保存在目标用户~/.ssh/authorized_keys 3、客户端发送请求，服务器返回1个随机字符串 4、客户端收到随机字符串之后，用自己的私钥加密，发送给服务器 5、服务器收到密文之后，用客户端的公钥进行解密，拿到随机字符串与生成的字符串比较。返回认证结果(随机字符串其他人拿到了就拿到了，没有任何关系，因为A的公钥很多人都可以有) 弊端 第三方攻击 A无法判定收到的这个公钥是不是B的 为了解决这个问题 第一次登录的时候会进行人为确认 确认了之后，将B机器主机公钥存放在~/.ssh/known_hosts，以后每次登录都会进行对比 (如果系统重装后，登录不上，提示known_hosts……，将known_hosts删掉) 公钥认证 1、使用命令生成公钥对 ​ ssh-keygen ​ -t 选项 指定生成的加密算法 ​ 默认是rsa算法加密，过程中一直敲回车就可以了 2、客户端将公钥发送给服务器 ​ 保存在目标用户的~/.ssh/authorized_keys 3、检测权限 ​ authorized_keys 600权限 ​ .ssh 以及家目录都给755以下权限 或者 允许密码验证登录时(前提条件) # ssh-copy-id wy@192.168.0.39 -p 2233 把公钥发送过去 [root@cPen_python ~]# ssh-copy-id wy@192.168.0.39 -p 2233 # 注：需要可以支持密码登录 1.4 ssh远程操作工具 ssh远程操作工具 ssh 远程执行命令，远程登录 登录方式 ssh 服务器ip地址 使用当前用户和默认端口登录 使用客户端的当前用户名，登录到远端服务器的同名用户下，默认端口22 (没有同名用户，登录失败) ssh 用户名@服务器ip地址 登录到远端服务器的指定用户下，使用默认端口22登录 ssh 服务器地址 -l 用户名 -p 端口号 指定用户名和端口去登录 ssh -o 接一些配置选项 服务器的ip地址 #无序输入yes，自动保存hostkey ssh -o StrictHostKeyChecking=no 192.168.0.132 -p 223 ssh -i /tmp/id_rsa 指定私钥认证文件 默认情况在~/.ssh/这下面找私钥 ssh -vvv 打印登录过程的详细信息 1.5 服务配置 服务配置 服务安装包 oepnssh [root@cPen_python ~]# which ssh /usr/bin/ssh [root@cPen_python ~]# rpm -qf /usr/bin/ssh openssh-clients-7.4p1-21.el7.x86_64 配置文件 /etc/ssh/sshd_config 服务端配置文件 /etc/ssh/ssh_config 客户端配置 主程序 服务端 /usr/sbin/sshd 客户端 /usr/bin/ssh 重新加载配置 重启服务 service sshd restart/reload kill -1 sshd的pid kill -HUP sshd的pid号 1.6 查看ssh服务启动情况 查看ssh服务启动情况 1、ps -aux/-ef 2、pidof sshd 3、netstat -autpln 所有接口(a)的udp tcp连接，显示出所有程序(p) 监听状态(l) n数字显示端口号 ​ # 注：查看网络连接状态 ​ # ps -eo pid,uid,comm|grep sshd # 注：-eo查看特定字段信息 4、lsof -i:22 打印出程序所需要的文件 1234567891011[root@localhost ~]# ps aux |grep sshdroot 1066 0.0 0.1 112924 4316 ? Ss 09:41 0:00 /usr/sbin/sshd -Droot 1608 0.0 0.1 158928 5608 ? Ss 09:43 0:00 sshd: root@pts/0root 9546 0.0 0.0 112824 980 pts/0 S+ 11:26 0:00 grep --color=auto sshd[root@localhost ~]# ps -ef |grep sshdroot 1066 1 0 09:41 ? 00:00:00 /usr/sbin/sshd -Droot 1608 1066 0 09:43 ? 00:00:00 sshd: root@pts/0root 9550 1612 0 11:26 pts/0 00:00:00 grep --color=auto sshd[root@localhost ~]# ps -eo pid,uid,comm|grep sshd # 注：-eo查看特定字段信息 1066 0 sshd 1608 0 sshd 1.7 ssh-agent ssh-agent ​ 管理密钥 ​ 在你自己的机器上开启这个服务 ​ 配置: xshell–&gt; 主机属性–》ssh --》勾选 使用xagent进行身份验证 ;勾选 使用代理转发 #注：自己的机器是Windows，在Windows上开启ssh-agent服务，现在有A、B 2台机器，A、B两台机器都有Windows的公钥，这种情况开启ssh-agent(xshell里面开启)，A登录B时默认情况会拿windows的公钥进行加密，B机器用Windows的私钥进行解密 必须在xshell里进行操作，这都是xshell的行为 二. 跳板机 #注：跳板机给办公人员用的 跳板机/堡垒机 为了保护系统的安全 #注：使用ssh-agent 访问跳板机和想要访问的主机 #注：使用场景 阿里的业务 本来有10万台主机(在局域网里面，没有外网，外部不能访问)，我在家里，十万台机器捞出一台，这1台主机可以访问外网(跳板机/堡垒机)，这1台跳板机的配置尤其重要 开启ssh-agent，把自己主机的公钥添加到目标主机和堡垒机下 (目标主机的权限和堡垒机的权限) #注：连到A上，从A跳到B上，B不一定有当前主机的公私钥 #跳板机 安全加固： 不能使用root直接登录，使用sudo赋予相应权限 不能使用默认端口登录 不能使用密码登录，都使用公钥登录 添加防火墙配置 总结： #跳板机 #安全加固 ​ 1、不能使用密码登录 ​ 2、不能使用root登录 ​ 3、修改默认端口 ​ 4、添加防火墙配置 ​ 5、使用跳板机登录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228示例1：查看路由 ip r--------------------------------------------------------------------------------------------[root@cPen_python ~]# ip r # 注：查看路由default via 192.168.0.1 dev ens33 proto dhcp metric 100 192.168.0.0/24 dev ens33 proto kernel scope link src 192.168.0.32 metric 100 [root@cPen_python ~]# ip r delete default via 192.168.0.1 # 注：删除网关[root@cPen_python ~]# ip r192.168.0.0/24 dev ens33 proto kernel scope link src 192.168.0.32 metric 100 [root@cPen_python ~]# ping www.baidu.com # 注：删除后ping不通外网connect: 网络不可达[root@cPen_python ~]# ping 8.8.8.8connect: 网络不可达[root@cPen_python ~]# ip r add default via 192.168.0.1 # 注：还原============================================================================================示例2：A机器登录到B机器(简化登录) vim .ssh/config#以后会遇到很多机器，ip地址是记不住的--------------------------------------------------------------------------------------------#A机器登录到B机器，操作前需要先把A机器公钥放到B机器上 进行授权#不修改全全局配置，只修改个人配置：在用户家目录下创建.隐藏文件#在客户端上配置(配到自己的主机上)#注：意思是将机器root@192.168.0.31 -p 2233 取个别名叫B#ForwardAgent yes # 注：转发 开启#StrictHostKeyChecking no # 注：不需要输入yes 直接把key保存在known_hosts里面#ServerAliveInterval 60 # 注：存活状态，检测服务存活状态#IdentityFile ~/.ssh/id_rsa # 注：指定认证私钥#示例如下[root@cPen_python ~]# vim .ssh/config###############################################ForwardAgent yesStrictHostKeyChecking noServerAliveInterval 60IdentityFile ~/.ssh/id_rsa###############################################Host B HostName 192.168.0.31 User cPen Port 2233[root@cPen_python .ssh]# chmod 600 config # 注：授予权限 不执行这条语句 可能会报错[root@cPen_python .ssh]# ssh BLast login: Mon Nov 23 15:05:16 2020 from 192.168.0.32 # 注：登录成功[root@cPen_centos8 ~]# #注：即简化 # ssh 192.168.0.31 -l root -p 2233 操作 (比如登录到ftp服务器 ssh ftp)============================================================================================示例3：查看端口连接状态 (客户机想访问服务器的时候使用 客户机上telnet) telnet 192.168.0.31 2233#注：这个命令只能测tcp的 udp的测不了，但是大部分服务都是tcp的#查看端口是否可以访问(即服务是否可达) telnet 192.168.0.31 2233--------------------------------------------------------------------------------------------#ping命令 是查看2台机器网络是否连通#查看服务是否可达使用 telnet命令#示例：查看端口是否可达(服务是否可达)[root@cPen_python .ssh]# yum install telnet -y[root@cPen_python .ssh]# telnet 192.168.0.31 2233Trying 192.168.0.31... Connected to 192.168.0.31. # 注：服务可达Escape character is &#x27;^]&#x27;.SSH-2.0-OpenSSH_8.0============================================================================================示例4：提示主机不被信任 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!--------------------------------------------------------------------------------------------#注：提示WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!将~/.ssh/known_hosts 删掉============================================================================================示例5：永久修改主机名 hostnamectl set-hostname &quot;A&quot;--------------------------------------------------------------------------------------------#方法1[root@cPen_python .ssh]# hostnamectl set-hostname &quot;A&quot;#注：其实是修改 /etc/hostname[root@A ~]# less /etc/hostname #方法2#或者直接修改 /etc/hostname#临时修改主机名[root@B ~]# hostname cp============================================================================================示例6：查看进程数 pstree -p--------------------------------------------------------------------------------------------#注：看程序树状结构 pstree -p[root@cPen_python .ssh]# pstree -p |grep sshd |-sshd(1065)-+-sshd(3782)---bash(3784) | |-sshd(3980)---bash(3982)-+-grep(4318) | |-sshd(4059)---bash(4061) | `-sshd(4288)---bash(4290)#注：前面是父程序，后面是父程序创造出来的子程序，子程序分配新的bash环境，bash环境在操作命令grep#注：父进程创造出子进程，子进程有创造出一个子进程，子进程创造出一个新的bash环境#-------------------------------------------------------------------------------------------#注：连接到B机器后bash环境多了一个ssh子进程去处理B机器[root@a ~]# ssh BLast login: Mon Nov 23 15:52:16 2020 from 192.168.0.32[root@a .ssh]# pstree -p |grep sshd |-sshd(1065)-+-sshd(3782)---bash(3784) | |-sshd(3980)---bash(3982)-+-grep(4325) | |-sshd(4059)---bash(4061)---ssh(4323) | `-sshd(4288)---bash(4290)============================================================================================示例7：修改客户端配置 ~/.ssh/config#配置文件：~/.ssh/config#工作中使用跳板机代理登录 (客户端的配置，方便开发配置)--------------------------------------------------------------------------------------------#注：假设现在有A、B、C三台机器，B是跳板机，假设A C不通，A通B，B通C，B通D，B通E…………#注：B机器当做跳板机，A是自己的本地机，A机器做代理，B机器自动做转发#注：在本地机A机器中操作[root@a ~]# vim ~/.ssh/config ###############################################ForwardAgent yesStrictHostKeyChecking noServerAliveInterval 60IdentityFile ~/.ssh/id_rsa###############################################Host B HostName 192.168.0.31 User sanchuang Port 2233Host 192.168.0.54 User sanchuang Port 2233 ProxyCommand ssh 192.168.0.31 -W %h:%p -l sanchuang -p 2233#注：ProxyCommand表示 A通过跳板机(192.168.0.31)B登录到#-------------------------------------------------------------------------------------------Host * /ftp* /10.* 以10网段开头的ip地址 ssh 10.0.0.1 跳到这个配置执行 User sanchuang Port 2233 ProxyCommand ssh B nc %h %p -w 10 2&gt;/dev/null#注：上课时冲突 前面写Host *与ssh B冲突============================================================================================示例8：远程执行命令 ssh B--------------------------------------------------------------------------------------------#不登录B机器，执行B机器上的命令 (一般用于脚本)[root@a ~]# ssh B ifconfig # 注：登录到B执行 ifconfig命令[root@a ~]# ssh B ip a # 注：登录到B执行 查看ip地址 命令 ；命令的返回是B机器给的[root@a ~]# ssh B &quot;/usr/sbin/ip a&quot; # 注：脚本里建议使用命令的绝对路径============================================================================================示例9：远程传输 scp (前提ssh可以连接)--------------------------------------------------------------------------------------------#注：传输文件[root@a ~]# touch ahost[root@a ~]# scp ahost B:/tmp # 注：将A机器 当前路径ahost文件cp到B机器下的/tmp路径下ahost 100% 0 0.0KB/s 00:00 [root@a ~]# scp B:/tmp/bhost ./ # 注：将B机器 /tmp/bhost文件cp到当前路径bhost 100% 0 0.0KB/s 00:00 [root@a ~]# scp B:tmp/testhost ./ # 注：将B机器 家目录下 tmp/testhost文件cp到当前路径#注：传输目录 [root@a ~]# scp -r adir B: # 注：将A机器当前路径下 adir文件夹 cp到B机器家目录下[root@a ~]# scp -r adir B:bdir # 注：复制文件夹并改名[root@a ~]# scp -r adir B:bdir/ # 注：和上面的没有区别============================================================================================示例10：sftp传输文件 (前提ssh可以连接)--------------------------------------------------------------------------------------------#注：ftp文件传输#注：sftp 传输文件 本地和异地传输文件#注：格式 sftp 用户名@主机名[sanchuang@a ~]$ sftp BConnected to B.sftp&gt; ls # 注：显示远程目录列表2q aa adir bb bdir testdir testdir2 testhost sftp&gt; get bdirFetching /home/sanchuang/bdir/ to bdirCannot download non-regular file: /home/sanchuang/bdir/sftp&gt; mget bdirFetching /home/sanchuang/bdir/ to bdirCannot download non-regular file: /home/sanchuang/bdir/sftp&gt; get 2q # 注：get 远程路径 下载文件Fetching /home/sanchuang/2q to 2q/home/sanchuang/2q 100% 226 107.5KB/s 00:00 sftp&gt; exit============================================================================================示例11：pssh pscp命令 (前提ssh可以连接)--------------------------------------------------------------------------------------------#批量处理pssh -h 指定主机文件列表，内容格式”[user@]host[:Port]” -i 指定每个服务器的处理信息[root@a ~]# yum install pssh -y # 注：没有的话需要安装epel源[root@a ~]# cat ip.txt 192.168.0.31:2233192.168.0.54:22[root@a ~]# pssh -h ip.txt -i &quot;/usr/sbin/ip a&quot;[1] 17:18:13 [FAILURE] 192.168.0.54:22 Exited with error code 255、Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).…… # 注：需要保证ssh能不能过去[2] 17:18:13 [SUCCESS] 192.168.0.31:2233 # 注：返回SUCCESS表示执行成功……1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000……2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen ……#-------------------------------------------------------------------------------------------#ip.txt里面可以这样写[root@a ~]# vim ip.txt sanchuang@192.168.0.31:2233sanchuang@192.168.0.54:2233============================================================================================示例12：pscp.pssh 批量传输文件 (前提ssh可以连接)--------------------------------------------------------------------------------------------[root@a ~]# pscp.pssh -h ip.txt pscptest /tmp# 注：把当前目录下的pscptest文件传送到目标主机的/tmp目录下[root@a ~]# vim ip.txt sanchuang@192.168.0.31:2233sanchuang@192.168.0.54:2233[root@a ~]# pscp.pssh -h ip.txt pscptest /tmp[1] 17:41:31 [FAILURE] sanchuang@192.168.0.54:2233 Exited with error code 1[2] 17:41:31 [SUCCESS] sanchuang@192.168.0.31:2233============================================================================================示例13：fping 批量ping(前提ssh可以连接)--------------------------------------------------------------------------------------------#注：批量ping 使用fping命令[root@a ~]# yum install fping -y[root@a ~]# fping -g 192.168.0.1/24 # 注：-g 根据网段去ping192.168.0.1 is alive……192.168.0.254 is unreachable[root@a ~]# fping -f ip.txt # 注：-f根据文件指定ip去ping192.168.0.31 is alive192.168.0.54 is alive[root@a ~]# vim ip.txt 192.168.0.31192.168.0.54 三. ssh服务补充 3.1 ssh ssh --&gt; secure shell 作用：远程登录和操作远程的服务器 --&gt; 信息加密 --&gt; 非常安全的远程登录协议 #注：远程登录远程操控 省成本 ssh协议 属于应用层的协议 Linux：openssh --&gt; centos7/8自带 Windows 没有ssh协议 3.2 命令 命令： ​ ssh ​ scp # 注：远程copy ​ sftp ​ ssh-keygen ​ ssh-copy-id 3.3 登录方式 登录方式： ​ Xshell # 注：不开源 ​ putty # 注：开源 ​ secureCRT # 注：开源 用户名和密码 ​ /etc/passwd # 注：放用户名 ​ /etc/shadow # 注：放密码 密钥 ​ 公钥和私钥 ​ public key --&gt; 公开 # 注：给别人 ​ private key # 注：自己所有 3.4 安全加固措施 安全加固措施： 修改端口号 22 ​ nmap # 注：端口扫描 ​ nc # 注：端口扫描 禁用root su # 注：su 切换到root 密码复杂性 启用密钥 # 注：禁止密码认证 打补丁 或者 安装最新版本的ssh软件 iptables防火墙 #注：免密通道（密钥登录） 3.5 免密通道 免密通道： ​ 单向信任 # 注：把密钥给其他主机 ​ 双向信任 # 注：双方互给公钥 #注：一般用root用户，为了安全起见用普通用户 3.6 ansible ansible：自动化运维的工具：批量管理和操作 #注：ansible批量管理 批量部署的软件；底层用的ssh协议，推荐建立免密通道 #注：ansible软件 用Python写的 3.7 日志文件：/var/log/secure 12345678910日志文件：/var/log/secure[root@cPen_centos8 ssh]# vim /etc/ssh/sshd_config # Logging#SyslogFacility AUTHSyslogFacility AUTHPRIV # 注：日志类型 认证类型 AUTHPRIV 设置#LogLevel INFO日志文件： /var/log/secure[sanchuang@cPen_centos8 ~]$ ps aux|grep rsyslog # 注：外包日志的进程 12345ssh将自己的日志功能外包给rsyslog服务去帮它记录日志[sanchuang@cPen_centos8 ~]$ vim /etc/rsyslog.conf # The authpriv file has restricted access.authpriv.* /var/log/secure 3.8 ssh服务登录不了，如何排除？ ssh服务登录不了，如何排除？ 检测网络是否通畅 ping 检测ssh服务是否启动，检查端口，selinux ssh的配置：是否禁用root，是否禁用密码认证 检查防火墙iptables ​ service firewalled stop 黑白名单 # 注：centos6、7里面用，8里面没有 3.9 ssh免密通道 ssh免密通道 生成密钥对 ​ ssh-keygen ​ ssh-keygen -t ecdsa 上传公钥 ​ ssh-copy-id -i id_ecdsa.pub root@192.168.0.35 ​ ssh-copy-id -p 2299 -i id_ecdsa.pub root@192.168.0.35 远程连接 ​ ssh -p ‘2299’ ‘root@192.168.0.39’ 123456免密通道的建立步骤：[root@localhost .ssh]# ssh-keygen -t ecdsa[root@localhost .ssh]# ssh-copy-id -p 2299 -i id_ecdsa.pub root@192.168.0.39[root@localhost .ssh]# ssh -p &#x27;2299&#x27; &#x27;root@192.168.0.39&#x27;known_hosts：存放我们曾经ssh连接过的机器的公钥 1234567891011121314151617scp 就是在2台机器之间底层使用ssh协议来拷贝文件或者文件夹[root@cPen_centos8 ssh]# ssh root@192.168.0.24 # 注：远程登录[root@cPen_centos8 ssh]# ssh root@192.168.0.24 df -Th # 注：远程执行命令[root@cPen_python ssh]# scp echo.sh root@192.168.0.35:/root # 注：传文件 （源文件 远程）[root@cPen_python ssh]# scp -r /boot root@192.168.0.35:/root # 注：传文件夹[root@cPen_python ssh]# scp -r root@192.168.0.35:/etc/passwd # 注：拿文件夹[root@cPen_python ssh]# ssh root@192.168.0.35 bash /root/echo.sh feng zhang wangscp 就是在2台机器之间底层使用ssh协议来拷贝文件或者文件夹---------------------------------------------------------------------------------------------------------------------------------[root@cPen_centos8 ssh]# getenforce # 注：查看selinuxDisabled[root@cPen_centos8 ssh]# setenforce 0 # 注：临时关闭selinuxsetenforce: SELinux is disabled---------------------------------------------------------------------------------------------------------------------------------[sanchuang@cPen_centos8 ~]$ ifdown ens33[sanchuang@cPen_centos8 ~]$ ifup ens33#注：禁用root用户登录后，本地可以用root用户登录","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://blog1.cpen.top/tags/SSH/"}]},{"title":"20_Linux基础-ssh服务2","slug":"Linux_基础/20_Linux基础-ssh服务2","date":"2022-09-17T04:00:00.000Z","updated":"2022-09-17T05:00:00.000Z","comments":true,"path":"posts/46092.html","permalink":"https://blog1.cpen.top/posts/46092.html","excerpt":"","text":"一. 公钥认证排错 1、确保公钥正确 2、确保~/.ssh/authorized_keys文件权限为600 3、确保家目录以及.ssh目录权限为755以下权限，即属组和其他人没有7的权限 12345678示例--------------------------------------------------------------------------------------------[root@cPen_web .ssh]# ssh -vvv wy@192.168.0.30 # 注：看ssh登录时的详细信息#注：B机器下操作[wy@cPen_web .ssh]$ vim authorized_keys # 注：把A机器的公钥粘过去[wy@cPen_web .ssh]$ chmod 600 authorized_keys [wy@cPen_web home]$ chmod 755 wy # 注：公钥认证家目录其他人权限不能太高[wy@cPen_web ~]$ chmod 755 .ssh # 注：给.ssh也是755 权限 二. 登录方式 123456789101112131415161718192021222324[root@cPen_web .ssh]# ssh wy@192.168.0.30[root@cPen_web .ssh]# ssh 192.168.0.30 -l wy[root@cPen_web .ssh]# ssh 192.168.0.30 -l wy -p 22 # 注：指定用户，指定端口（默认22号端口）[root@cPen_web .ssh]# ssh -vvv 192.168.0.30 wy # 注：查看登录过程的详细信息…………debug1: Trying private key: /root/.ssh/id_dsadebug3: no such identity: /root/.ssh/id_dsa: No such file or directorydebug1: Trying private key: /root/.ssh/id_ecdsadebug3: no such identity: /root/.ssh/id_ecdsa: No such file or directorydebug1: Trying private key: /root/.ssh/id_ed25519debug3: no such identity: /root/.ssh/id_ed25519: No such file or directorydebug1: Trying private key: /root/.ssh/id_xmssdebug3: no such identity: /root/.ssh/id_xmss: No such file or directory…………#注：默认会去寻找~/.ssh/id_rsa，然后再找id_dsa等等...#注：rsa dsa ecdsa 加密算法---------------------------------------------------------------------------------------------------------------------------------#注：不接任何用户名，会以A机器上的当前用户去登录B机器上的同名用户（不管B机器有没有这个用户） (没有就登录失败)[sanchuang@cPen_web ~]$ ssh 192.168.0.30Are you sure you want to continue connecting (yes/no/[fingerprint])? yessanchuang@192.168.0.30&#x27;s password: [sanchuang@cPen_web ~]$ ----------------------------------#注：登录时默认会去寻找家目录下的~/.ssh/id_rsa去进行认证，所有尽量不要在生成key的时候将它的默认路径更改 三. 登录验证原理 - 密码登录 1、密码登录 ​ client向server发送登陆请求，server将自己的公钥发送给client ​ client使用这个公钥，将密码进行加密，发送给server ​ server用私钥解密登陆密码，验证合法性 ​ server返回验证结果给client 这个流程有一个问题，怎么保证收到的公钥就是目标server的公钥？（中间人攻击） 如果一个攻击者中途拦截了client的登录请求，发送自己的公钥给client，client端就会用攻击者的公钥进行数据加密，攻击者接收到信息后，用自己的私钥就可以解密了，这就窃取了client的登陆信息了 为了解决这个问题，client端第一次登录的时候，会进行一个公钥确认 确认server服务端的这个host主机摘要，确认成功之后就会将server端的pubkey保存在~/know_hosts里面 以后每次连接都会验证这个know_hosts里的key和收到的pubkey是否一致 server主机的pubkey保存在/etc/ssh/目录下，默认使用ssh_host_ecdsa_key.pub #注：SSH基于公钥加密的技术 #注：第一步A机器向B机器发送登录请求（还没有道输入密码的阶段） #注：B机器接收到A机器的请求之后，把B机器的公钥发送给A机器 #注：A机器拿到公钥之后，用公钥对密码进行加密（密码是密文，不能让别人知道） #注：A机器把加好密的这一串密文发给B #注： B机器收到来此A机器的机密之后的密码，用私钥解密，得到passwd，再与/etc/shadow密码进行比较验证是否通过 #注：B机器向A机器返回登陆结果（成功或者失败） #注：密码登录涉及公钥加密，ssh整个都设计公钥加密（无论是密码登录或公钥登录） #注：没有保证第3方人攻击 #注：公钥加密私钥解密、私钥加密公钥解密（为了区分后面+.pub） #注：成对存在成对加解密 1234567891011121314151617#注：第一次登录机器时，一般会要输入yes（是否信任B主机），然后把key放到know_hosts里面A机器下[root@cPen_web .ssh]# ssh 192.168.0.30 -l wy -p 22………………Are you sure you want to continue connecting (yes/no/[fingerprint])? yes………………[root@cPen_web .ssh]# cat known_hosts 192.168.0.30 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBO+Xv/RYitaOHx0iyAbcOXLIPZEn75xh94pJ2L+MWOV/V3YRezYCgHJSwAJm5N9ceqtYCKoXUL3cCJeuGiiDH0A=B机器下[root@cPen_web .ssh]# cd /etc/ssh # 注：ssh服务的配置文件[root@cPen_web ssh]# lsmoduli sshd_config ssh_host_ecdsa_key.pub ssh_host_ed25519_key.pub ssh_host_rsa_key.pubssh_config ssh_host_ecdsa_key ssh_host_ed25519_key ssh_host_rsa_key[root@cPen_web ssh]# cat ssh_host_ecdsa_key.pub # 注：默认使用ssh_host_ecdsa_key.pubecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBO+Xv/RYitaOHx0iyAbcOXLIPZEn75xh94pJ2L+MWOV/V3YRezYCgHJSwAJm5N9ceqtYCKoXUL3cCJeuGiiDH0A= #注：A机器保存的key就是B机器/etc/ssh/ssh_host_ecdsa_key.pub下面的#注：A机器生成的公钥就是B机器/etc/ssh/ssh_host_ecdsa_key.pub下面的 第一次登录 输入yes的原因：信任它 -#注：为了增加安全性，第一次连接B主机的时候，都会进行一个主机确认（yes） -#注：输入yes表示，是可信任主机，那就是将主机的pubkey保存在~/.ssh/known_hosts里面，以后每次连接都会验证接收的key是否和know_hosts里一直，不一致，会登录异常 .-------------------------------------------------------------------------------------------------------------------------- -#注：A机器向B机器发送请求登录 -#注：B机器向A机器返回公钥 -#注：如果A机器向B机器发送请求的时候，被C给拦截了 -#注：C就伪造一下，把它的公钥发送给A -#注：A把密文用C的公钥加密发送给B，c就可以拿自己的密钥解密信息，不安全 -#注：只能自己确认（人为确认）接收的公钥是否是B机器的，输入yes，know_hosts就是自己信任的主机，把B主机的公钥保存到know_hosts里面 -#注：后续都会拿know_hosts里面 这个公钥和B发送的公钥进行比较（密钥不一致时会提示 登录失败不受信任） -#注：这个key是属于主机的key，验证这台主机的 -#注：公钥登录的key属于用户的，是验证用户的key 四. 登录验证原理 - 公钥认证登录 2、公钥认证登陆 ​ client端生成公钥对，将公钥追加在server端的~/.ssh/authorized_keys（1行1个公钥） ​ 发送登录请求，server收到请求之后，生成随机字符串发送给client ​ client用自己的私钥对字符串进行加密，发送给server ​ server收到加密字符串之后用公钥解密，比较解密出的字符串和之前生成的字符串是否一致 ​ 返回结果给client -#注：公私钥对是成对存在的，一个用于加密，一个用于解密，具体哪个为私钥，哪个为公钥就看使用者自己管理 注意：非对称加密计数 使用公钥进行加密，私钥解密，基本用于数据加密 使用私钥加密公钥解密，用于认证（对数据加密性没有要求，拿到就拿到） -#注：第一步在A机器上生成公钥对 -#注：B主机将A主机的公钥写入B主机用户的~/.ssh/authorized_keys里面 -#注：A主机向B机器发送登录请求 -#注：B机器收到请求之后，会生成一个随机字符串。把这个随机字符串发送给A机器 -#注：A机器收到随机字符串后，用私钥加密 -#注：A机器将加密之后的字符串发送给B机器 -#注：B机器拿到A机器的加密字符串之后，用公钥解密，再比较解密之后的字符串和生成的字符串是否一致。 -#注：B机器再返回结果 -#注：ABC3台机器，A上面的公钥在BC上都有，C也能公钥解密，得到字符串（对数据加密性没有要求，拿到就拿到） 五. 总结 5.1 SSH服务介绍 远程Shell应用程序 允许用户在远程机器上执行任意命令 让标准输出在本地 早期明文远程协议：telnet SSH（Secure Shell，安全的外壳） 为客户机提供安全的Shell环境，用于远程管理 默认端口：TCP 22 SSH基于公钥加密（非对称加密）技术 数据加密传输 客户端和服务器的身份验证 5.2 公钥加密体系 **公钥（Public Key）和私钥（Private Key） ** 公钥和私钥是成对生成的，这两个密钥互不相同，两个密钥可以互相加密和解密 不能根据一个密钥而推算出另外一个密钥 公钥对外公开，私钥只有私钥的持有人才知道 私钥应该由密钥的持有人妥善保管 根据实现的功能不同，可以分为数据加密和数字签名 六. 数据加密 **发送方使用接收方的公钥加密数据 ** 接收方使用自己的私钥解密数据 数据加密能保证所发送数据的机密性 .-------------------------------------------------------------------------------------------------------------------------- -#注：数据加密 主要是为了保障 接收方的数据安全性 -#注：把A机器的公钥发送给B机器 -#注：B用A机器的公钥对传输内容进行加密，然后把信息发送给A机器 -#注：将加密内容发送给A机器，此时只有A机器有权限获取里面的内容 -#注：数据加密 主要是为了保障 接收方的数据安全性 -#注：不能保障收到的数据一定是B机器发过来的 七. 数字签名 发送方 对原始数据执行HASH算法得到摘要值 发送方用自己私钥加密摘要值 将加密的摘要值与原始数据发送给接收方 数字签名保证数据完整性、身份验证和不可否认 .-------------------------------------------------------------------------------------------------------------------------- -#数据签名 -#注：如何保障收到的数据一定是B机器发过来的 -#注：（A机器上要有B机器的公钥，B机器也要有A机器的公钥） -#注：A机器公钥给B机器 -#注：B机器公钥给A机器 -#注：B机器向A机器发送数据：B机器先用自己的私钥对摘要信息（hash，一般是data的hash散列值 做信息的摘要信息，验证信息-完整值）进行加密生成签名。B机器再用A机器的公钥对信息内容和签名进行加密，发送给A机器 -#注：A机器收到B机器的密文数据后，用自己的私钥进行解密。得到解密后的明文后，用B机器的公钥来解密B机器生成的签名 -#注：数据签名 验证发送方的数据安全（验证发送方是不是我想要的发送方） 八. SSH身份验证过程 九. 电子邮件数字签名过程 十. OpenSSH OpenSSH 官方站点：http://www.openssh.com 主要软件包：openssh-server、openssh-clients 服务名：sshd 服务端主程序：/usr/sbin/sshd # 注：都是可执行的脚本 客户端主程序：/usr/bin/ssh # 注：都是可执行的脚本 服务端配置文件：/etc/ssh/sshd_config 客户端配置文件：/etc/ssh/ssh_config -#注：xshell就是模拟ssh的客户端 -#注：linux yum下下来的包基本都是rpm包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051示例1：查看命令属于哪个包下载的---------------------------------------------------------------------------------------------------------------------------------ssh是通过openssh下载的[root@cPen_web ~]# which ssh/usr/bin/ssh[root@cPen_web ~]# rpm -qf /usr/bin/sshopenssh-clients-8.0p1-4.el8_1.x86_64[root@cPen_web ~]# yum list |grep openssh===============================================================================示例2：启动sshd服务的实际上是执行行的服务启动脚本文件 /usr/sbin/sshd（真正执行服务的脚本）[root@cPen_web ~]# rpm -qf /usr/sbin/sshdopenssh-server-8.0p1-4.el8_1.x86_64[root@cPen_web ~]# service sshd restart # 注：service 守护进程 帮它去管理服务Redirecting to /bin/systemctl restart sshd.service[root@cPen_web ~]# #注：守护进程可以帮助管理，想关闭或打开。自己管理的话，很难，要手动的kill 或者 先kill再起来===============================================================================示例3：直接执行脚本/usr/sbin/sshd 启动服务---------------------------------------------------------------------------------------------------------------------------------#如果服务起来，会有22号端口属于listen监听状态[root@cPen_web ~]# service sshd stop[root@cPen_web ~]# lsof -i:22COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsshd 1709 root 5u IPv4 37939 0t0 TCP cPen_web:ssh-&gt;192.168.0.42:54537 (ESTABLISHED)sshd 2185 root 5u IPv4 50589 0t0 TCP cPen_web:ssh-&gt;192.168.0.42:57389 (ESTABLISHED)[root@cPen_web ~]# /usr/sbin/sshd[root@cPen_web ~]# lsof -i:22COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsshd 1709 root 5u IPv4 37939 0t0 TCP cPen_web:ssh-&gt;192.168.0.42:54537 (ESTABLISHED)sshd 2185 root 5u IPv4 50589 0t0 TCP cPen_web:ssh-&gt;192.168.0.42:57389 (ESTABLISHED)sshd 2282 root 4u IPv4 52306 0t0 TCP *:ssh (LISTEN) # 注：处于监听状态sshd 2282 root 6u IPv6 52308 0t0 TCP *:ssh (LISTEN)===============================================================================示例4：直接启动vsftpd服务端---------------------------------------------------------------------------------------------------------------------------------#注：vsftpd是服务端，ftp是客户端[root@cPen_web ~]# vsftpd # 注：启动vsftpd服务端（可以直接启动）#注：查看服务是否起来（4种）[root@cPen_web ~]# pidof vsftpd2297[root@cPen_web ~]# ps -ef |grep vsftpdroot 2297 1 0 14:50 ? 00:00:00 vsftpdroot 2300 2186 0 14:51 pts/1 00:00:00 grep --color=auto vsftpd[root@cPen_web ~]# netstat -auplt |grep vsftpdtcp6 0 0 [::]:ftp [::]:* LISTEN 2297/vsftpd [root@cPen_web ~]# lsof -i:21COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEvsftpd 2297 root 3u IPv6 52524 0t0 TCP *:ftp (LISTEN) 十一. SSH服务端配置文件 /etc/ssh/sshd_config 重启sshd服务生效 修改了配置文件端口号，启动不起来，原因是selinux是enforcing状态需要修改 .-------------------------------------------------------------------------------------------------------------------------- -#注：一般配置文件都是以#开头的注释行 -#注：只有root用户有权限修改它 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150示例1：过滤出有效行--------------------------------------------------------------------------------------------------------------------------------[root@cPen_web ~]# grep -v -E &quot;^#|^$&quot; /etc/ssh/sshd_config # 注：-E支持扩展正则 ； -v不显示HostKey /etc/ssh/ssh_host_rsa_keyHostKey /etc/ssh/ssh_host_ecdsa_keyHostKey /etc/ssh/ssh_host_ed25519_key……………………Subsystem sftp /usr/libexec/openssh/sftp-server===============================================================================示例2：vim /etc/ssh/sshd_config--------------------------------------------------------------------------------------------------------------------------------[root@cPen_web ~]# vim /etc/ssh/sshd_config #Port 22 # 注：默认端口号#AddressFamily any # 注：ip地址 （ipv4\\ipv6） any 任何#ListenAddress 0.0.0.0 # 注：本机上面的所有ip地址#ListenAddress :: # 注：ipv6===============================================================================示例3：ipv6地址--------------------------------------------------------------------------------------------------------------------------------IPv6的地址长度为128位，是IPv4地址长度的4倍。于是IPv4点分十进制格式不再适用，采用十六进制表示。#注：以: 冒号分隔===============================================================================示例4：网络连接失败 排错--------------------------------------------------------------------------------------------------------------------------------1、ping通 确保网络是联通的2、确保服务是起来的[C:\\~]$ telnet 192.168.0.29 2233 1端口没起，2防火墙[C:\\~]$ telnet 192.168.0.29Connecting to 192.168.0.29:23...Connecting to 192.168.0.29:2233... Connection established.To escape to local shell, press &#x27;Ctrl+Alt+]&#x27;.SSH-2.0-OpenSSH_8.0===============================================================================示例5：配置文件常用配置详解--------------------------------------------------------------------------------------------------------------------------------[root@cPen_web ~]# vim /etc/ssh/sshd_config #Port 22Port 2233 # 注：修改默认监听端口（默认22端口）#AddressFamily anyListenAddress 192.168.0.29 # 注：设置本机监听ip地址，默认为0.0.0.0（表示在本机任意ip地址上监听）PermitRootLogin no # 注：禁止root用户登录（no 不予许root用户登录，默认为yes）#PubkeyAuthentication yes # 注：是否开启公钥认证（默认开启）AuthorizedKeysFile .ssh/authorized_keys # 注：配置公钥认证的文件（这个文件可以改 没必要） # 注：前面的家目录没有写PasswordAuthentication no # 注：是否开启密码认证，默认为yes# WARNING: &#x27;UsePAM no&#x27; is not supported in Red Hat Enterprise Linux and may cause severalUsePAM yes # 注：使用pam认证（一般为yes不用改它）(pam帮我们进行认证，而不是ssh)#UseDNS yes # 注：是否将客户端主机名解析成ip，可以将其设置为no # 注：此过程不顺利的话，会非常的慢，会影响登录认证的速度，可以将其设置为no#注：一般来说不会开启密码认证#注：一般来说一个机器不允许root用户登录，一般来说给用户加sudo权限，用超级用户登录#注：pam是linux下面的pam模块，认证模块。我们登陆进来后，pam帮我们做的密码/密码认证，身份认证状态检验#注：pam认证模块 --&gt; 配置路径 /etc/pam.d/ 这个目录下面存放的是每个需要认证的服务的配置，文件名就是服务名#注：DNS --&gt; 域名解析服务。网络中使用ip地址通信。域名最终都要解析成ip的#注：DNS域名解析服务。主机名也可以使用DNS解析 (比如cPen_centos8)#注：如果在DNS范畴之内，可以通过主机名来访问这台主机，或者通过ip地址来访问-----------------------------------------------------------------------------------[root@cPen_centos8 ~]# visudosanchuang ALL=(ALL) NOPASSWD:ALL[root@cPen_python ~]# service sshd restart # 注：重启服务后22号端口已有的连接还在-------------------------------------------------------------------------------------#注：主机B登录[root@cPen_web ~]# ssh 192.168.0.29 -p 2233 # 注：指定端口2233#注：已经连接了的端口，即使改了端口，也不会有影响（只要不关闭窗口）#注：修改配置文件只是在磁盘上进行修改，对于正在运行的程序，需要把配置加载到磁盘上（重启、reload、kill -1）#注：修改完配置文件后，root用户 和 密码登录 登录不上去了（禁止使用密码登录）--------------------------------------------------------------------------------------------#注：修改配置文件并重启服务时 PermitRootLogin no#注：B机器root用户登录不上了[root@cPen_web ~]# ssh 192.168.0.29 -p 2233Permission denied (publickey,gssapi-keyex,gssapi-with-mic).===============================================================================PasswordAuthentication no # 注：是否开启密码密码认证，默认为yes示例6：物理机上 公钥登录（sanchuang用户登录）--------------------------------------------------------------------------------------------------------------------------------#注：ssh生成公钥：（xshell菜单栏）工具 --&gt; 新建用户密钥生成向导 --&gt; 下一步（一直） --&gt; 保存公钥pub key:id_rsa_2048.pub#注：把pub key复制到sanchuang用户下面去[sanchuang@cPen_web .ssh]$ vim authorized_keys………………[sanchuang@cPen_web .ssh]$ chmod 600 authorized_keys [sanchuang@cPen_web .ssh]$ chmod 755 /home/sanchuang#注：物理机（xshell）生产一对密钥对，放在虚拟机上#注：物理机上生成的key，在物理机上登，对物理机进行验证#注：属性 --&gt; 用户身份验证 --&gt; 方法：Public Key ; 用户名：sanchuang ； 用户密钥：id_rsa_2048（刚才生成的密钥）#注：这个key是物理机上的key，key粘到哪个用户下，就以哪个用户登录。在物理机上生成密钥对，要登你的虚拟机，使用xshell生成和管理密钥对，需要登录虚拟机的sanchuang用户，把物理机的pub key赋给sanchuang用户家目录下~/.ssh/authorized_keys，使用物理机去登。在物理机上生成的key，在物理机上登，sanchuang保存的是物理机的key，只能对物理机进行验证#注：连接不成功的话，设置selinux 关掉（setenforce 0）。修改端口需要添加selinux的规则，一般来说不会去添加它的规则，而是把它关掉#注：连不上的话，把iptables也关掉（iptables -F）===============================================================================示例7：ssh命令登陆--------------------------------------------------------------------------------------------------------------------------------ssh命令登陆 -l 指定登陆的用户名 -p 指定server的端口 -i 指定私钥文件，默认会在~/.ssh/去找私钥 -o 接特定设置选项 #无序输入yes，自动保存hostkey ssh -o StrictHostKeyChecking=no 192.168.0.132 -p 223 #注：脚本里这样写 无序输入yes===============================================================================示例8：修改完成之后重新加载配置的方法（sshd_config）#注：ssh起来后(默认会读磁盘里ssh配置文件)放到内存去运行--------------------------------------------------------------------------------------------------------------------------------#注：修改完成之后重新加载配置的方法（sshd_config）[root@cPen_web ~]# kill -1 2282[root@cPen_web ~]# kill -HUP 2282[root@cPen_web ~]# service sshd restart # 注：重新启动服务[root@cPen_web ~]# service sshd reload # 注：重新加载配置===============================================================================示例9：man 5 查看配置文件帮助文档--------------------------------------------------------------------------------------------------------------------------------man 1 普通的命令man 5 查看配置文件的帮助文档[root@cPen_web .ssh]# man 5 /etc/ssh/sshd_config # 注：man 5 查看配置文件帮助文档===============================================================================示例10：UsePAM yes--------------------------------------------------------------------------------------------------------------------------------UsePAM yes # 注：使用pam认证（一般为yes不用改它）#注：pam是linux下面的pam模块，认证模块。我们登陆进来后，pam帮我们做的密码/密码认证，身份认证状态检验模块文件：/etc/pam.d/ # 注：存放路径；用于认证的模块，linux可插入认证模块--------------------------------------------------------------------------------------------[root@cPen_python ~]# cd /etc/pam.d/ # 注：里面是pam的配置[root@cPen_python pam.d]# ls # 注：里面全是认证的模块；每一个服务一个文件chfn fingerprint-auth passwd postlogin runuser-l smtp.postfix sudo-i systemd-userchsh fingerprint-auth-ac password-auth postlogin-ac smartcard-auth sshd su-l vlockconfig-util login password-auth-ac remote smartcard-auth-ac su system-auth vmtoolsdcrond other polkit-1 runuser smtp sudo system-auth-ac vsftpd===============================================================================示例11：hostname -f 查看主机名全称--------------------------------------------------------------------------------------------------------------------------------[root@cPen_centos8 pam.d]# hostname -fcPen_centos8===============================================================================示例12：解析出百度的ip--------------------------------------------------------------------------------------------------------------------------------[root@cPen_centos8 pam.d]# host www.baidu.com[root@cPen_centos8 pam.d]# ping www.baidu.com 十二. 练习 修改端口为2233 禁止root用户登录 禁止密码登录 创建管理员用户sanchuang,给sanchuang所有sudo权限 在Windows机器上生成密钥对，后续A,B两台虚拟机器都使用公钥认证进行登陆 * 注意关闭防火墙和selinx iptables -F getenforce 0 --&gt; 或者修改配置文件 /etc/selinux/config --disabled，永久修改需要重启机器 .-------------------------------------------------------------------------------------------------------------------------- -#注：不是错误，使用service sshd restart命令实际上是执行/bin/systemctl restart sshd.service命令 1234[root@cPen_python ~]# service sshd restartRedirecting to /bin/systemctl restart sshd.service # 注：使用这个命令去执行#注：练习 具体操作如上 十三. ssh-agent管理密钥 ssh-agent管理密钥 一个代理程序，帮助我们管理私钥 配置: xshell–&gt; 主机属性–》ssh --》勾选 使用xagent进行身份验证 ;勾选 使用代理转发 12345[sanchuang@mysql-binary .ssh]$ ssh-add id_rsa # 注：添加主机密钥给agent管理#注：把虚拟机上面的key也交给给ssh-agent去管理[sanchuang@mysql-binary .ssh]$ ssh-add -l # 注：查看agent管理了哪些密钥2048 SHA256:eJz1xcOJnntAP/R0w1if7oEaukIbiwh0vmtp9Q605ls (RSA) .-------------------------------------------------------------------------------------------------------------------------- -#注：ssh-agent的概念：帮你管理密钥的，默认情况下ssh-agent开在物理机上的。ssh-agent就是一个中间商，保存管理密钥的。在xshell里面开启了ssh-agent之后，从A机器登录到B机器，它会先取看一下A机器root家目录下面有没有公私钥，没有的话 会从ssh-agent里面捞取它的公私钥 -#注：B机器没有A机器的公钥，它会去找ssh-agent里面管理的那个公钥对（中间商），最后认证是拿物理机的key去做认证的，因为物理机里面跑了1个ssh-agent，管理了物理机的pubkey，物理机的pubkey可以登录A又可以登录B，满足的条件是物理机能够登录到B -#注：再来一台主机C，想要从A调到C，先决条件是C要有物理机的pubkey，C对物理机授了权，然后物理机的key又由ssh-agent去管理，就可以从A主机跳到C主机。（家目录下面没有私钥生成，就去找ssh-agent管理的密钥对，只要C有物理机的公钥，就都可以登录了） -#注：这个服务是xshell的，只能通过xshell里面才能进行这一系列操作（xshell管理ssh-agent） .-------------------------------------------------------------------------------------------------------------------------- -#注：（xshell菜单栏）文件 --&gt; 打开（下拉） --&gt; 属性（右键） --&gt; SSH --&gt; 允许Xagent进行身份验证（勾上）；允许代理转发（勾上） -#注：在B机器上勾上（现在要在A机器上登录B机器） .-------------------------------------------------------------------------------------------------------------------------- #注：物理机上面有2个虚拟机 A、B，物理机使用xshell去连接A和B。刚在在A、B上都创建了sanchuang用户，并且把物理机的pub key都给了A、B两台机器的sanchuang用户。现在，在A机器上想要连接B机器的sanchuang用户，应该怎么做？B机器上没有A机器的key #注：答：把A的key给B（在A机器上生成自己的key，这样的话太麻烦了） #注：用户加的是哪一台的pubkey，就是允许哪一台的主机登录，加的authorized_keys是为哪一台机器授权 #注：A、B机器2台主机之间进行通讯的话，有1个本地的概念，它会在本地用户的家目录下面去找key；物理机没有这个概念，因为它是通过xshell(ssh的客户端，图形界面的ssh命令)去连接的，它通过xshell去管理它的key 123456示例：A机器上登录到B机器--------------------------------------------------------------------------------------------#注：前提确保 Windows可以免密码登录到A、B机器[sanchuang@cPen_python ~]$ ssh 10.122.148.108 -p 2233Last login: Sun Nov 15 19:59:00 2020 from 10.122.38.250[sanchuang@cPen_centos8 ~]$ 十四. 其他总结 14.1 SSH服务端配置文件 SSH登录使用的用户名 服务器中的本地系统用户的帐号名 SSH登录的用户验证方式 密码验证：使用服务器中系统帐号对应的密码 密钥对验证：使用客户机中生成的公钥、私钥 SSH客户端文件通常无需修改 14.2 SSH客户端 使用ssh命令远程登录 方式1： ssh 用户名@服务器地址 方式2： ssh -l 用户名 服务器地址 方式3： ssh 服务器地址 客户机使用第一次连接服务器时 [root@localhost ~]# ssh root@10.10.10.1 14.3 known_hosts文件 客户机使用ssh第一次连接服务器时 将服务器上sshd守护进程的公钥复制到本地 存放到本地~/.ssh/known_hosts文件中 每行存放一台服务器的公钥 用来验证服务器的身份 公钥验证服务器的具体细节 14.4 密钥方式 SSH的公钥认证流程 公钥验证客户端的具体细节 SSH公钥认证的基本实现步骤 1、在客户机创建密钥对 ssh-keygen -t rsa 指定rsa算法 设置保护私钥文件的密码 在~/.ssh下生成两个文件 id_rsa是用户的私钥 id_rsa.pub是用户的公钥 2、将公钥文件上传至服务器 上传到服务器~/.ssh/authorized_keys文件 文件中每行保存一个用户的公钥 scp ~/.ssh/id_rsa.pub root@10.10.10.1:~/.ssh/authorized_keys 14.5 SSH客户端 使用scp命令远程复制文件/目录 方式1： scp 用户名@服务器地址:源文件 目标路径 方式2： scp 本地文件 用户名@服务器地址:目标路径 若复制的是目录，则需添加“-r”选项 使用sftp命令从服务器下载文件 格式：sftp 用户名@服务器地址 14.6 通过SSH运行服务器中的窗口程序 运行服务器中的图形程序是SSH的重要应用 ssh命令需要在图形界面虚拟终端下运行 命令格式：ssh -X username@sshserver xlock是运行在SSH服务器中，而显示在SSH客户机中的窗口程序 14.7 SSH客户端应用 使用图形客户端软件 SecureCRT 主要用途：基于SSH协议远程登录以便管理服务器 下载地址：http://www.vandyke.com/ 使用图形客户端软件 WinSCP 主要用途：基于sftp、scp或ftp的方式下载/上传数据 下载地址：http://winscp.net/ 14.8 SSH访问控制 **SSH使用TCP Wrappers实现访问控制 ** 主要配置文件 /etc/hosts.allow /etc/hosts.deny TCP Wrappers可以控制哪些服务 受super daemon（xinetd）管理的服务 支持libwrap.so模块的服务 TCP Wrappers的访问控制原则 首先检查 hosts.allow 文件，若找到相匹配的策略，则允许访问 否则继续检查 hosts.deny 文件，若找到相匹配的策略，则拒绝访问 如果两个文件中都没有相匹配的策略，则允许访问","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://blog1.cpen.top/tags/SSH/"}]},{"title":"19_Linux基础-ssh服务1","slug":"Linux_基础/19_Linux基础-ssh服务1","date":"2022-09-16T04:00:00.000Z","updated":"2022-09-16T05:00:00.000Z","comments":true,"path":"posts/33033.html","permalink":"https://blog1.cpen.top/posts/33033.html","excerpt":"","text":"一. 练习 1、编写脚本，实现批量新增用户，用户名以user开头，具体新增用户数量随用户输入，并且为每个用户设置随机密码（密码长度为12位随机字符组成），记录创建的用户与密码，保存到/tmp/user文件中。 2、如何实现两个字符串的拼接，两个整数求和，以及5除以3，保留2位小数 3、如何计算本机有多少个用户以及多少个普通用户？ 4、如何去除字符串中所有空格？ 5、备份/var/log/nginx/access.log日志，每五分钟备份一次,并且以2020-11-15_10_05-access.log.tar.gz方式命名。将日志文件备份文件放到/nginx/目录下。 6、查找/etc/目录下10天以内3天以前修改过的文件，并将这些文件记录到/tmp/etc_log文件中 1.1 编写脚本，实现批量新增用户，用户名以user开头，具体新增用户数量随用户输入，并且为每个用户设置随机密码（密码长度为12位随机字符组成），记录创建的用户与密码，保存到/tmp/user文件中 题目1：编写脚本，实现批量新增用户，用户名以user开头，具体新增用户数量随用户输入，并且为每个用户设置随机密码（密码长度为12位随机字符组成），记录创建的用户与密码，保存到/tmp/user文件中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546示例1---------------------------------------------------------------------read -p &quot;请输入你要添加的用户个数：&quot; num1for i in `seq $num1` # 注：循环多少次do id user$i &amp;&gt;/dev/null a=`echo $?` # 注：上条命令返回值 0 成功 非0 失败 str1=`date +%s+%N | md5sum|head -c 4` # 注：%s时间戳 if [ $a -eq 0 ] ;then echo &quot;该用户已存在，不进行新建操作&quot; break else useradd user$str1$i &amp;&gt;/dev/null b=`echo $?` if [ $b -eq 0 ];then echo &quot;创建成功&quot; passwd1=`mkpasswd -l 12` # 注：mkpasswd 生成随机12位密码串 echo $passwd1 |passwd user$str1$i --stdin &amp;&gt;/dev/null # 注：--stdin 密码从标准输入里面来 echo &quot;user$str1$i:$passwd1&quot; &gt;&gt;/tmp/user else echo &quot;创建失败&quot; fi fidone---------------------------------------------------------------------[root@cPen_web lianxi]# date +%s+%N # 注：引用纳秒的概念，防止用户名 重复1605251515+012657467[root@cPen_web lianxi]# man date %% a literal % %a locale&#x27;s abbreviated weekday name (e.g., Sun) # 注：Sun %A locale&#x27;s full weekday name (e.g., Sunday) # 注：Sunday %s seconds since 1970-01-01 00:00:00 UTC # 注：时间戳 从1970年1月1号到现在的秒数 %N nanoseconds (000000000..999999999) # 注：纳秒 1纳秒=十亿分之一秒[root@cPen_web ~]# date +%s+N | md5sum|head -c 42b13[root@cPen_web ~]# 示例2---------------------------------------------------------------------read -p &quot;输入新增用户数:&quot; numfor i in `seq $num`do useradd user$i &amp;&gt;/dev/null passwd=`mkpasswd -l 12` echo $passwd |passwd user$i --stdin &amp;&gt;/dev/null echo &quot;用户名:user$i&quot; &quot;密码:$passwd&quot; &amp;&gt;&gt;/tmp/userdone 1.2 如何实现两个字符串的拼接，两个整数求和，以及5除以3，保留2位小数 题目2：如何实现两个字符串的拼接，两个整数求和，以及5除以3，保留2位小数 数值运算：https://blog.csdn.net/weixin_34408624/article/details/92598137 #注：挨在一起写实现2个字符串拼接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950示例---------------------------------------------------------------------[root@cPen_web ~]# a=abc[root@cPen_web ~]# b=def[root@cPen_web ~]# echo $a$b # 注：字符串拼接abcdef[root@cPen_web ~]# echo abc$aabcabc[root@cPen_web ~]# a=3[root@cPen_web ~]# b=4[root@cPen_web ~]# echo $(($a+$b))7#注：1个括号默认是字符串拼接 不会进行数值运算[root@cPen_web ~]# a=123 # 注：默认都是str类型[root@cPen_web ~]# a=&quot;123&quot;[root@cPen_web ~]# a=&#x27;123&#x27;------------------------------------------------------------[root@cPen_web ~]# a=123[root@cPen_web ~]# b=4[root@cPen_web ~]# echo $(( $a &gt; $b ))1 # 注：正确返回1[root@cPen_web ~]# echo $(( $a &lt; $b ))0 # 注：错误返回0[root@cPen_web ~]# expr $a + $b # 注：expr命令 进行数值运算127[root@cPen_web ~]# echo $(( $a + $b )) # 注：2个圆括号实现整数运算127[root@cPen_web ~]# echo $[ $a + $b ] # 注：中括号实现整数运算127[root@cPen_web ~]# let c=$a+$b # 注：let 也可以实现整数运算[root@cPen_web ~]# echo $c # 注：let只能复制 不能直接赋值127#注：整数运算：4种方法[root@cPen_web ~]# expr $a + $b[root@cPen_web ~]# echo $(( $a + $b ))[root@cPen_web ~]# echo $[ $a + $b ][root@cPen_web ~]# let c=$a+$b # 注：let只能复制 不能直接赋值数值运算：https://blog.csdn.net/weixin_34408624/article/details/92598137------------------------------------------------------------------------#注：小数运算echo &quot;scale=3;5/3&quot;|bc # 注：3表示保留3位小数 5/3[root@cPen_web ~]# echo &quot;scale=3;5/3&quot;|bc # 注：确保主机上装了bc1.666[root@cPen_web lianxi]# echo $((5/3))1[root@cPen_web lianxi]# echo |awk &#x27;&#123;printf 5/3&#125;&#x27; # 注：awk默认保留5位小数1.66667[root@cPen_web lianxi]# [root@cPen_web lianxi]# echo |awk &#x27;&#123;printf &quot;%.2f&quot;,5/3&#125;&#x27; # 注：保留2位小数1.67[root@cPen_web lianxi]# 数值运算：https://blog.csdn.net/weixin_34408624/article/details/92598137 1.3 如何计算本机有多少个用户以及多少个普通用户？ 题目3：如何计算本机有多少个用户以及多少个普通用户？ 123456示例---------------------------------------------------------------------#3、如何计算本机有多少个用户以及多少个普通用户？wc -l /etc/passwd # 注：本机有多少用户awk -F&quot;:&quot; &#x27;$3&gt;=1000&#123;print $1&#125;&#x27; /etc/passwd |wc -l # 注：本机有多少普通用户#注：普通用户uid&gt;1000 1.4 如何去除字符串中所有空格？ 题目4：如何去除字符串中所有空格？ 1234示例---------------------------------------------------------------------str=&quot;s t r i n g&quot;echo $str |tr -d &quot; &quot; # 注：-d删除指定字符 1.5 备份/var/log/nginx/access.log日志，每五分钟备份一次,并且以2020-11-15_10_05-access.log.tar.gz方式命名。将日志文件备份文件放到/nginx/目录下 题目5：备份/var/log/nginx/access.log日志，每五分钟备份一次,并且以2020-11-15_10_05-access.log.tar.gz方式命名。将日志文件备份文件放到/nginx/目录下。 #注：确保crontab打开 1234示例---------------------------------------------------------------------[root@cPen_web ~]# crontab -e # 注：计划任务里命令最好写绝对路径*/5 * * * * tar czf /nginx/$(date +%Y-%m-%d_%H_%M-access.log.tar.gz) /var/log/nginx/access.log 1.6 查找/etc/目录下10天以内3天以前修改过的文件，并将这些文件记录到/tmp/etc_log文件中 题目6：查找/etc/目录下10天以内3天以前修改过的文件，并将这些文件记录到/tmp/etc_log文件中 123456789101112131415示例---------------------------------------------------------------------[root@cPen_web ~]# find /etc -type f -mtime -10 -mtime +3 # 注：注意 是查找的文件/etc/dnf/modules.d/python27.module/etc/selinux/config/etc/vsftpd/vsftpd.conf/etc/dconf/db/site/etc/dconf/db/local/etc/dconf/db/distro[root@cPen_web ~]# stat /etc/selinux/config # 注：stat看文件的原信息………………最近访问：2020-11-13 10:14:37.388001468 +0800最近更改：2020-11-05 15:12:05.484883965 +0800最近改动：2020-11-05 15:12:05.485883965 +0800[root@cPen_web lianxi]# find /etc -type f -mtime -10 -mtime +3 &amp;&gt;/tmp/etc_log 二. 练习 请用shell写出一个简单的猜拳游戏，枚举值（0石头、1剪刀、2布），有两位选手分别是rob1、rob2，他们的出拳方式由系统自动枚举，并连续猜十盘，最后给出十盘的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121示例1：判定各种情况 if语句---------------------------------------------------------------------#!/bin/bashecho &quot;猜拳游戏开始啦！！！&quot;echo &quot;今天我们的两位对手是rob1和rob2&quot;pingju=0rob1_win=0rob2_win=0for i in `seq 10`do a=`echo $[RANDOM%3]` b=`echo $[RANDOM%3]` case $a in 0) c=bor1出的是石头 ;; 1) c=bor1出的是剪刀 ;; 2) c=bor1出的是布 ;; esac case $b in 0) d=bor2出的是石头 ;; 1) d=bor2出的是剪刀 ;; 2) d=bor2出的是布 ;; esac if (($a==$b));then echo -e &quot;$c\\n$d \\n他们战平了&quot; pingju=$[$pingju+1] continue fi if [[ $a -eq 1 || $b -eq 1 ]];then # 注：如果1方出布 if [[ $a -eq 0 || $b -eq 0 ]];then # 注：如果1方出拳头 if (($a&gt;$b));then echo -e &quot;$c\\n$d,rob2获胜&quot; rob2_win=$[$rob2_win+1] continue else echo -e &quot;$c\\n$d,rob1获胜&quot; rob1_win=$[$rob1_win+1] continue fi fi fi if (($a&gt;$b));then echo -e &quot;$c\\n$d,rob1获胜&quot; rob1_win=$[$rob1_win+1] else echo -e &quot;$c\\n$d,rob2获胜&quot; rob2_win=$[$rob2_win+1] fidoneecho &quot;rob1获胜次数$rob1_win,rob2获胜次数$rob2_win,平局次数$pingju============================================================================================示例2：使用减法#注：if语句的使用---------------------------------------------------------------------for i in `seq 10`do rob1=$(($RANDOM%3)) echo rob1=$rob1 rob2=$(($RANDOM%3)) echo rob2=$rob2 if [ $rob1 -eq $rob2 ] then echo &quot;平局&quot; elif [ $(($rob1-$rob2)) -eq -1 ] || [ $(($rob1-$rob2)) -eq 2 ] # 注：rob1赢的情况 then echo &quot;rob1 win&quot; else echo &quot;rob2 win&quot; fidone============================================================================================示例3---------------------------------------------------------------------r1_win=0r2_win=0equal=0for i in `seq 10`do echo -ne &quot;第$i盘\\t&quot; rob1_res=$(($RANDOM%3)) rob2_res=$(($RANDOM%3)) if [[ $(($rob1_res - $rob2_res)) = -1 ]]; then echo -ne &quot;rob1胜\\t&quot; &amp;&amp;r1_win=$(($r1_win + 1)); fi if [[ $(($rob1_res - $rob2_res)) = 2 ]]; then echo -ne &quot;rob1胜\\t&quot; &amp;&amp;r1_win=$(($r1_win + 1)); fi if [[ $(($rob2_res - $rob1_res)) = -1 ]]; then echo -ne &quot;rob2胜\\t&quot; &amp;&amp;r2_win=$(($r2_win + 1)); fi if [[ $(($rob2_res - $rob1_res)) = 2 ]]; then echo -ne &quot;rob2胜\\t&quot; &amp;&amp;r2_win=$(($r2_win + 1)); fi if [[ $(($rob1_res - $rob2_res)) = 0 ]]; then echo -ne &quot;平局\\t&quot; &amp;&amp; equal=$(($equal + 1)); fi [[ $rob1_res = 0 ]] &amp;&amp; echo -ne &quot;rob1:石头\\t&quot; [[ $rob1_res = 1 ]] &amp;&amp; echo -ne &quot;rob1:剪刀\\t&quot; [[ $rob1_res = 2 ]] &amp;&amp; echo -ne &quot;rob1:布\\t\\t&quot; [[ $rob2_res = 0 ]] &amp;&amp; echo &quot;rob2:石头&quot; [[ $rob2_res = 1 ]] &amp;&amp; echo &quot;rob2:剪刀&quot; [[ $rob2_res = 2 ]] &amp;&amp; echo &quot;rob2:布&quot;doneecho &quot;rob1胜场:$r1_win&quot;echo &quot;rob2胜场:$r2_win&quot;echo &quot;平局场数:$equal&quot;示例4：生成1个随机数 3以内 不包括3---------------------------------------------------------------------#注：生成1个随机数 3以内 不包括3[root@cPen_web lianxi]# echo $[RANDOM%3]2[root@cPen_web lianxi]# echo $[RANDOM%3]1[root@cPen_web lianxi]# echo $[RANDOM%3]0 SSH服务 三. SSH服务介绍 远程Shell应用程序 允许用户在远程机器上执行任意命令 让标准输出在本地 早期明文远程协议：telnet SSH（Secure Shell，安全的外壳） 为客户机提供安全的Shell环境，用于远程管理 默认端口：TCP 22 SSH基于公钥加密（非对称加密）技术 数据加密传输 客户端和服务器的身份验证 #注：23号端口是明文的，已经淘汰了 .-------------------------------------------------------------------------------------------------------------- ssh是什么？ ​ ssh --&gt; secure shell ​ remote login program – 远程登陆模式 ​ 对数据进行加密传输的服务，主要用在远程登陆 #注：把数据放到加密好了的壳里面，是安全的协议 .-------------------------------------------------------------------------------------------------------------- ssh协议是应用层协议，根据ssh协议实现的服务叫ssh服务 ssh服务主要在HP-UX,LINUX,AIX,UNIX系统上都有（类UNIX系统上），Windows上没有 #注：ftp协议也是应用层的协议，根据协议实现的服务叫ftp服务 .-------------------------------------------------------------------------------------------------------------- ssh常见的2种登陆方式： 1、密码登陆 2、密钥登陆（免密码登录） # 注：不需要密码 #注：想要登录到那台主机，1、需要知道那台主机ip，2、允许登录，3、网络跟它联通，可以访问到那台主机上 #注：ssh服务默认端口 22号端口 可以去更改 .-------------------------------------------------------------------------------------------------------------- #注：/etc/services 可以查看常用服务的默认端口号 1234[root@cPen_web lianxi]# less /etc/services ssh 22/tcp # The Secure Shell (SSH) Protocolssh 22/udp # The Secure Shell (SSH) Protocol#注：一般来说ssh都是使用tcp去传输的 .-------------------------------------------------------------------------------------------------------------- #注：因为它所有的数据都是进行加密的，所以说它是安全的shell #注：2台主机之间进行数据交互 都会牵扯到 数据包的传输 #注：对别的服务发起一个请求，其实就是相当于发送了1个包给它，这里包里面带有请求 #注：普通情况下不给它加密的话，信息是明文的，是不安全的；ssh服务对数据进行加密，只有a主机和b主机知道解密的方式，其他人不知道 #注：安装好系统后（最小安装），一般来说自带ssh服务，一般来说启动系统它会自动起来 .-------------------------------------------------------------------------------------------------------------- 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152示例：查看ssh服务是否启动---------------------------------------------------------------------------------1、查看进程[root@cPen_web lianxi]# ps ef |grep ssh # 注：进程名叫sshd2、pidof sshd # 注：判定某个服务是否存在pid[root@cPen_web lianxi]# pidof sshd # 注：服务起来的话必定会有1个pid2545 2543 2542 2538 2537 2536 909#服务起来后必定会有1个pid3、查看网络连接监听状态 netstat#注：yum install net-tools[root@cPen_web lianxi]# netstat -atpl |grep ssh # 注：a 所有 ;t tcp ;p 端口[root@cPen_web lianxi]# netstat -atpln |grep sshtcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 909/sshd #注：listen状态 在监听中，表示别人可以里来连接我了tcp 0 0 192.168.0.21:22 192.168.0.42:58697 ESTABLISHED 2536/sshd: root [pr #注：ESTABLISHED表示已经建立连接了，可以进行数据交换了；tcp 0 36 192.168.0.21:22 192.168.0.42:58698 ESTABLISHED 2537/sshd: root [pr tcp6 0 0 :::22 :::* LISTEN 909/sshd #注：0.0.0.0:22表示在本机所有ip上监听22端口（别人可以通过所有的ip来访问）。如果把它监听到192.168.0.135/24上，那别人只能通过135这个地址来访问我#注：listen状态 在监听中；表示服务起来了 在监听状态，表示别人可以来连接我了#注：establish表示有1个客户端连接我了（已经建立连接的状态）#注：0.0.0.0:*表示允许任意ip，任意端口客户端来连接 （*代表任意端口客户端）#注：0.0.0.0:22第1种表示本机上所有的ip （本机上的）#注：0.0.0.0:* 表示允许任意ip，任意端口客户端来连接 （外部客户端的任意端口）（*代表任意端口客户端）------------------------------------------------------------------------------------------------------#注：本地回环地址代表本地，测试网卡是否ok 127.0.0.1/8 本地回环地址#注：网卡实际地址 192.168.0.21/24#注：别人不可以通过127.0.0.1来访问，因为127.0.0.1代表本地，每一台机器都有一个127.0.0.1本地回环地址，别人通过127.0.0.1来访问，仅仅只是访问的自己4、lsof -i:22 #注：查看有没有listen状态的监听 ； establish表示连接建立了#注：知道端口后可以查看端口#注：lsof --&gt;list open file 列出打开的文件（全称）[root@cPen_web ~]# lsof -i:22COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsshd 908 root 4u IPv4 27707 0t0 TCP *:ssh (LISTEN) # 注：listen 监听状态sshd 908 root 6u IPv6 27721 0t0 TCP *:ssh (LISTEN) # 注：ESTABLISHED 建立连接sshd 1419 root 5u IPv4 29943 0t0 TCP cPen_web:ssh-&gt;10.112.68.22:49959 (ESTABLISHED)sshd 1421 root 5u IPv4 29943 0t0 TCP cPen_web:ssh-&gt;10.112.68.22:49959 (ESTABLISHED)============================================================================================示例：增加ip地址[root@cPen_web lianxi]# ip a add 192.168.0.144/24 dev ens33 # 注：增加ip地址[root@cPen_web lianxi]# ip add # 注：最好跟它同网段 inet 127.0.0.1/8 scope host lo # 注：dev ens3 设备 ens33 inet 192.168.0.21/24 brd 192.168.0.255 scope global dynamic noprefixroute ens33 inet 192.168.0.144/24 scope global secondary ens33============================================================================================示例：查看命令属于哪个包[root@cPen_web lianxi]# which netstat # 注：找到命令的绝对路径/usr/bin/netstat[root@cPen_web lianxi]# rpm -qf /usr/bin/netstat # 注：查看这个绝对路径执行文件属于哪个包net-tools-2.0-0.51.20160912git.el8.x86_64 四. 密钥登陆 12345678910111213141516171819202122[root@cPen_web ~]# ssh-keygen # 注：创建密钥对Generating public/private rsa key pair. # 注：rsa算法生成公钥和私钥的钥匙对（钥匙有2把不是同一把）Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:JZh0IhlTUDkIvuXuv7Iw7zYsoucwfLjpPWrHYN7P63g root@cPen_webThe key&#x27;s randomart image is:+---[RSA 2048]----+| ..=B=.. || . o+o= || . . o.. . || + o || . . S ||.o.. ||=o*o. ||.=BXBE ||=O+*XX+. |+----[SHA256]-----+[root@cPen_web ~]# 加密 对称加密 ​ 加解密的钥匙都是同一把 ​ 怎么样安全的保存这个密码，这个密钥在需要加密的机器之间都是共享的 ​ 很难保证这个密钥不被泄漏 非对称加密 # 注：加密和解密的钥匙不一样 ​ 生成一对公私钥，私钥自己保管，公钥可以给其他人 ​ 公私钥对是成对存在的，一个用于加密，一个用于解密。具体哪个为私钥，哪个为公钥就看使用者自己管理。 注意： ​ 使用公钥进行加密，私钥解密，基本用于数据加密 ​ 使用私钥加密公钥解密，用于认证 123456789101112131415161718192021222324252627282930313233[root@cPen_web ~]# ssh-keygen # 注：创建密钥对Generating public/private rsa key pair. # 注：rsa算法生成公钥和私钥的钥匙对（钥匙有2把不是同一把）Enter file in which to save the key (/root/.ssh/id_rsa): # 注：存放公私钥的路径，root用户的Enter passphrase (empty for no passphrase): # 注：设置密钥密码 # 注：非全局Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:JZh0IhlTUDkIvuXuv7Iw7zYsoucwfLjpPWrHYN7P63g root@cPen_web # 注：算法hash算法The key&#x27;s randomart image is: # 注：信息摘要 用的 SHA256 hash算法+---[RSA 2048]----+| ..=B=.. || . o+o= || . . o.. . || + o || . . S ||.o.. ||=o*o. ||.=BXBE ||=O+*XX+. |+----[SHA256]-----+[root@cPen_web ~]# #注：hash算法 任意长度的输入，映射成固定长度的输出--------------------------------------------------------------------------------------------#注：加密分为2种方式：1、对称加密；2、非对称加密#注：对称加密 a机器给b机器传输东西，a机器知道1串密码叫做aa，b机器也知道这个密码叫做aa；a机器对date用aa加密，b机器用aa解密。2个加密解密都用同一个密钥（加密的钥匙A和B都知道）。形式的条件是a和b都知道密钥是什么，且都一样#注：问题 不能保证密钥不被被人知道#注：非对称加密 a机器和b机器进行数据加密传输（进行通讯）。a机器在本地生成1个public和private的钥匙对，a机器生成公钥和私钥都放在a机器上，发送数据时，a机器先把公钥给b（也可以把公钥给c,公钥可以给任何人），但是私钥只有自己a机器才知道。b机器用a机器给的公钥加密，a机器收到后用私钥解密唯一能够解密的钥匙 私钥 只有机器a才有，只有机器a才能解密#注：对于数据信息加密而言，用公钥加密，用私钥解密，只有机器a才能解密#注：非对称加密 用于数据加密时，用公钥加密，私钥解密 五. ssh配置 ssh配置 目录：/etc/ssh # 注：这下面放的都是ssh的配置文件 123456789[root@cPen_web ~]# cd /etc/ssh/ [root@cPen_web ssh]# lsmoduli sshd_config ssh_host_ecdsa_key.pub ssh_host_ed25519_key.pub ssh_host_rsa_key.pubssh_config ssh_host_ecdsa_key ssh_host_ed25519_key ssh_host_rsa_key#注：sshd_config 客户端的配置文件#注：ssh_config 服务的配置文件#注：ssh_host_ecdsa_key ssh_host_ecdsa_key.pub 一对公私钥#注：ssh_host_ecdsa_key.pub 公钥 ssh_host_ecdsa_key私钥#注：ssh服务起来的时候，它会自动创建1对公私钥 123456示例：创建的公私钥默认放在/root/.ssh/目录下[root@cPen_web ~]# cd .ssh[root@cPen_web .ssh]# lsid_rsa id_rsa.pub known_hosts#注：id_rsa 私钥#注：id_rsa.pub 公钥 六. 实现公钥认证(免密码登录) 1234567891011121314151617181920212223#注：a机器下(生成公钥后)[root@cPen_web ~]# cd .ssh[root@cPen_web .ssh]# lsid_rsa id_rsa.pub known_hosts[root@cPen_web .ssh]# cat id_rsa.pub ssh-rsaAAAAB3NhQX......jXDv87iERv/z9XepKCeYqCfF2Dvv0n/g+IeFmzhW0iOppExskimMPGGWcN+7rXWlwaLNTiknmSTl+mFvZV8uIY5DnQXv root@cPen_web#注：b机器下[root@cPen_web ~]# mkdir .ssh # 注：没有的话 创建 .ssh文件夹[root@cPen_web ~]# cd .ssh/[root@cPen_web .ssh]# lsknown_hosts[root@cPen_web .ssh]# vim authorized_keys # 注：创建文件authorized_keysssh-rsa # 注：把a机器的公钥粘过去AAAAB3NhQX......jXDv87iERv/z9XepKCeYqCfF2Dvv0n/g+IeFmzhW0iOppExskimMPGGWcN+7rXWlwaLNTiknmSTl+mFvZV8uIY5DnQXv root@cPen_web[root@cPen_web .ssh]# chmod 600 authorized_keys #注：给它的权限为600，不要让其他人或者其他组有任何权限#注：a机器下[root@cPen_web .ssh]# ssh root@10.122.148.108 # 注：使用客户端 以root用户登录………………………Are you sure you want to continue connecting (yes/no)? yes………………………[root@cPen_web ~]# # 注：不需要输入密码，就是免密码登录成功 实现公钥认证,免密码登录 A --&gt; B A机器要登录到B机器上 1、在A机器上生成公钥对（如果有公钥对，则不需要重新生成），默认会放在当前用户家目录下的.ssh/文件下 生成一个id_rsa（私钥），id_rsa.pub（公钥） #注：如果有了，就不需要重新生成公钥对了，因为会覆盖。默认路径不要改它，改它的意义不大，因为默认在默认路径查找 [root@cPen_web ~]# ssh-keygen # 注：生成，中间一直敲回车，选择默认 2、在B机器上目标用户的家目录下面~/.ssh/authorized_keys文件里将A机器的公钥复制粘贴过来， 没有此文件就创建，并且确保这个文件的权限设为600 3、查看公钥认证是否成功 ​ 在A机器上执行 ssh root@B机器的ip ​ 不需要输入密码就可以登录到B机器，则表示免密码登录成功 ​ 公钥放在B机器的哪个用户下面，就通过哪个用户登录 ​ 以哪个用户登录，需要看公钥放到B机器的哪个用户下 12345678[root@cPen_web ~]# useradd wy[root@cPen_web ~]# su - wy # 注：su切换不会经过ssh服务[wy@cPen_web ~]$ #注：su切换用户，是不会经过ssh#注：ssh是远程登录su 和 su - su切换不会切换bash环境（还是原用户的bash环境） su - 去切换 会切换到wy的bash环境 公钥认证排错 确保公钥正确 确保~/.ssh/authorized_keys文件权限为600 确保家目录以及.ssh目录权限为755以下权限，即属组和其他人没有7的权限","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://blog1.cpen.top/tags/SSH/"}]},{"title":"18_Linux基础-用户权限3","slug":"Linux_基础/18_Linux基础-用户权限3","date":"2022-09-15T04:00:00.000Z","updated":"2022-09-15T05:00:00.000Z","comments":true,"path":"posts/57976.html","permalink":"https://blog1.cpen.top/posts/57976.html","excerpt":"","text":"一. 回顾：/根目录下的 /etc 一般放配置文件 /根目录下的 /etc 一般放配置文件 一个用户的基本组只能有一个，附属组可以有多个；享受的权限是一样的，都是有那个组的权限 1234567891011121314151617181920212223242526272829303132333435363738394041424344示例---------------------------------------------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# useradd sanle10[root@sanchuang-linux ~]# id sanle10uid=2224(sanle10) gid=2224(sanle10) 组=2224(sanle10)[root@sanchuang-linux ~]# less /etc/group[root@sanchuang-linux ~]# useradd sanle11 -g sanchuang05 -G sanchuang06 # 指定基本组、附属组[root@sanchuang-linux ~]# id sanle11uid=2225(sanle11) gid=1043(sanchuang05) 组=1043(sanchuang05),1044(sanchuang06)[root@sanchuang-linux ~]# less /etc/passwd # 注：存放用户信息hello:x:1007:1007::/home/hello:/bin/bash# 注：字段2仅仅只是密码占位符，真正的密码放在/etc/shadow[root@sanchuang-linux ~]# ls -al /etc/passwd-rw-r--r-- 1 root root 4539 11月 12 09:50 /etc/passwd # 注：任何人都可以访问/etc/passwd[root@sanchuang-linux ~]# ls -al /etc/shadow---------- 1 root root 4588 11月 12 09:50 /etc/shadow # 注：权限都为0[root@sanchuang-linux ~]# useradd sanle13 -c &quot;create sanle13&quot; # 注：指定用户描述信息[root@sanchuang-linux ~]# less /etc/passwdsanle13:x:2227:2227:create sanle13:/home/sanle13:/bin/bash # 注：字段5用户描述信息[root@sanchuang-linux tmp]# ls -ld /lianxi # 注：查看/lianxi 目录属于哪个用户哪个组drwxr-xr-x. 9 root root 4096 11月 9 09:47 /lianxi# 普通用户默认只能在自己的家目录下 或 /tmp目录下创建对个人环境信息做设置~/.bash_profile~/.bashrc[root@sanchuang-linux tmp]# id sanle11uid=2225(sanle11) gid=1043(sanchuang05) 组=1043(sanchuang05),1044(sanchuang06) # 注：基本组sanchuang05[root@sanchuang-linux tmp]# su - sanle11[sanle11@sanchuang-linux ~]$ touch cc[sanle11@sanchuang-linux ~]$ ls -al总用量 16……………………-rw-r--r-- 1 sanle11 sanchuang05 0 11月 12 10:21 cc # 注：有效组sanchuang05# 注：有效组默认是用户基本组[sanle11@sanchuang-linux ~]$ newgrp sanchuang06 # 注：修改有效组；临时修改[sanle11@sanchuang-linux ~]$ touch dd[sanle11@sanchuang-linux ~]$ ls -al……………………-rw-r--r-- 1 sanle11 sanchuang06 0 11月 12 10:23 dd # 注：有效组sanchuang06 二. 练习 2.1 题目1 创建三个用户sx1,sx2,sx3，这三个用户的附属组都是sanle组，创建名为/home/sanle的目录，在该目录中，三个用户可以合作&gt;处理文件。要求恰当修改该目录的权限，以便只允许用户和组能在这个目录中访问、删除、创建文件，其他用户没有任何权限，&gt;三个用户新建的文件只能自己有权限删除，彼此无法删除，而且新建的文件应该被自动分配到sanle的组所有权。 1234567891011示例---------------------------------------------------------------------#创建三个用户sx1,sx2,sx3，这三个用户的附属组都是sanle组，创建名为/home/sanle的目录，在该目录中，三个用户可以合作&gt;处理文件。要求恰当修改该目录的权限，以便只允许用户和组能在这个目录中访问、删除、创建文件，其他用户没有任何权限，&gt;三个用户新建的文件只能自己有权限删除，彼此无法删除，而且新建的文件应该被自动分配到sanle的组所有权。useradd -G sanle sx1useradd -G sanle sx2useradd -G sanle sx3mkdir /home/sanlenewgrp sanlemkdir /home/sanlechmod 1770 /home/sanle -Recho &quot;newgrp sanle&quot; &gt;&gt; ~/.bashrc 2.2 题目2 脚本 --------------------------------------------------------------------- 1、创建用户 2、删除指定用户 3、修改指定用户（用户id，用户属组，用户家目录） 4、删除指定用户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137示例1---------------------------------------------------------------------#!/bin/bashmenu()&#123; echo &quot;1、创建用户&quot; echo &quot;2、删除指定用户&quot; echo &quot;3、修改指定用户（用户id，用户属组，用户家目录）&quot; echo &quot;4、删除指定用户&quot;&#125;add()&#123; read -p &quot;输入用户名:&quot; username # 注：接收从键盘的输入 useradd $username &amp;&gt;/dev/null &amp;&amp; echo &quot;创建成功&quot; || echo &quot;创建失败&quot;&#125;del()&#123; read -p &quot;输入用户名:&quot; username userdel -r $username &amp;&gt;/dev/null &amp;&amp; echo &quot;删除成功&quot; || echo &quot;用户不存在&quot;&#125;modify()&#123; read -p &quot;输入用户名:&quot; username id $username &amp;&gt;/dev/null if [[ $? = 0 ]] then read -p &quot;输入uid:&quot; uid # 注：可以再加3个case 更精细 read -p &quot;输入gid:&quot; gid read -p &quot;输入家目录:&quot; home usermod -u $uid -g $gid -d $home $username 2&gt;/dev/null &amp;&amp; echo &quot;修改成功&quot; || &quot;修改失败&quot; else echo &quot;用户不存在&quot; fi&#125;while :do menu read -p &quot;请输入1-4：&quot; option case $option in 1) add ;; 2) del ;; 3) modify ;; 4) del ;; *) echo &quot;输入不合法&quot; esacdone示例2：一次性添加多个变量---------------------------------------------------------------------------------------------------------------------------------mod()&#123; read -p &quot;请输入(用户id，用户属组，用户家目录):&quot; userid usergroup userhome username usermod -u $userid -g $usergroup -d $userhome $username &amp;&gt; /dev/null &amp;&amp; echo &quot;修改成功&quot; || echo &quot;修改失败&quot; &#125;示例3：精密选择（推荐）---------------------------------------------------------------------------------------------------------------------------------#!/bin/bashmenu()&#123; echo &quot;1、创建用户&quot; echo &quot;2、删除指定用户&quot; echo &quot;3、修改指定用户（用户id，用户属组，用户家目录）&quot;&#125;menu2()&#123; echo &quot;1、修改用户id&quot; echo &quot;2、修改用户属组&quot; echo &quot;3、修改用户家目录&quot;&#125;add()&#123; read -p &quot;输入用户名:&quot; username id $username &amp;&gt;/dev/null &amp;&amp;echo &quot;用户已存在&quot; || useradd $username &amp;&gt;/dev/null &amp;&amp; echo &quot;创建成功&quot; || echo &quot;创建失败&quot;&#125;del()&#123; read -p &quot;输入用户名:&quot; username id $username &amp;&gt;/dev/null || echo &quot;用户不存在&quot; &amp;&amp; userdel -r $username &amp;&gt;/dev/null &amp;&amp; echo &quot;删除成功&quot; || echo &quot;删除失败&quot;&#125;modify()&#123; read -p &quot;输入用户名:&quot; username if id $username &amp;&gt;/dev/null then menu2 read -p &quot;请输入:&quot; choice2 case $choice2 in 1) read -p &quot;输入uid:&quot; uid usermod -u $uid $username &amp;&gt;/dev/null &amp;&amp; echo &quot;修改成功&quot; || echo &quot;修改失败&quot; ;; 2) read -p &quot;输入gid:&quot; gid usermod -g $gid &amp;&gt;/dev/null &amp;&amp; echo &quot;修改成功&quot; || echo &quot;修改失败&quot; ;; 3) read -p &quot;输入家目录:&quot; home usermod -d $home $username &amp;&gt;/dev/null &amp;&amp; echo &quot;修改成功&quot; || echo &quot;修改失败&quot; ;; *) echo &quot;输入不合法&quot; esac else echo &quot;用户不存在&quot; fi&#125;while truedo menu read -p &quot;请输入(按q退出)：&quot; choice case $choice in 1) add ;; 2) del ;; 3) modify ;; q) break ;; *) echo &quot;输入不合法&quot; esacdone 三. ACL的使用 ACL(Access Control List) # 注：访问控制列表（允许哪些人可以/不可以访问） 一个文件/目录的访问控制列表，可以针对任意指定的 用户/组使用权限字符分配rwx权限 设置ACL：setfacl指令 格式： setfacl 选项 规则 文件 常用选项 -m：新增或修改ACL中的规则 -b： 删除所有ACL规则 -x： 删除指定的ACL规则 查看ACL：getfacl指令 格式：getfacl 文件 设置ACL：setfacl指令 格式： setfacl 选项 规则 文件 常用规则 格式：类型:特定的用户或组:权限 user:(uid/name):(perms) 指定某位使用者的权限 group:(gid/name):(perms) 指定某一群组的权限 other::(perms) 指定其它使用者的权限 mask::(perms) 设定有效的最大权限 注意 user、group、other、mask简写为：u , g , o , m perms使用rwx #注：acl访问控制列表，工作中和云计算都比较常见 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768示例1：查看文件acl---------------------------------------------------------------------------------------------------------------------------------#注：对权限精准把控[root@localhost ~]# getfacl win-utf-2.txt # 注：查看文件acl规则# file: win-utf-2.txt # 注：get file acl# owner: root # 注：初始的规则# group: rootuser::rw-group::r--other::r--[root@localhost ~]# ls -la win-utf-2.txt -rw-r--r--. 1 root root 0 10月 27 11:42 win-utf-2.txt[root@localhost ~]# ===============================================================================示例2：对sanchuang用户有读写执行权限#注：针对特殊用户---------------------------------------------------------------------------------------------------------------------------------[root@localhost ~]# setfacl -m u:sanchuang:rwx win-utf-2.txt # 注：对sanchuang用户有rwx权限[root@localhost ~]# getfacl win-utf-2.txt # 注：u也可以写成 user 一般简写# file: win-utf-2.txt # 注：注意普通用户对/root目录没有操作权限# owner: root# group: rootuser::rw-user:sanchuang:rwx # 注：对sanchuang用户有rwx权限group::r--mask::rwxother::r--[root@localhost ~]# ls -la win-utf-2.txt # 注：权限多了个+-rw-rwxr--+ 1 root root 0 10月 27 11:42 win-utf-2.txt===============================================================================示例3：对组有读写执行的权利#注：针对特定组---------------------------------------------------------------------------------------------------------------------------------[root@localhost ~]# setfacl -m g:sanchuang5:rw win-utf-2.txt [root@localhost ~]# ls -la win-utf-2.txt # 注：set file acl-rw-rwxr--+ 1 root root 0 10月 27 11:42 win-utf-2.txt[root@localhost ~]# getfacl win-utf-2.txt # file: win-utf-2.txt# owner: root# group: rootuser::rw-user:sanchuang:rwxgroup::r--group:sanchuang5:rw- # 注：对组有读写执行的权利mask::rwxother::r--===============================================================================示例4：设置有效的最大权限#注：针对mask设置有效权限---------------------------------------------------------------------------------------------------------------------------------#注：设定有效的最大权限为r#注：设置的权限在mask之下（天花板）[root@localhost ~]# setfacl -m m::r win-utf-2.txt # 注：设置有效的最大权限[root@localhost ~]# getfacl win-utf-2.txt # file: win-utf-2.txt# owner: root# group: rootuser::rw-user:sanchuang:rwx #effective:r-- # 注：即使sanchuang的权限是rw，但是有效最大权限是rgroup::r--group:sanchuang5:rw- #effective:r--mask::r--other::r--#注：指明了有效最大权限后；用户sanchuang即使有读写的权限，用户sanchuang5最大权限仅仅指为读#注：即使设置了用户sanchuang rw权限，但是mask设置为r，也只有r的权限 四. ACL类型 ACL类型 存取型ACL(Access ACL)：文件或目录 预设型ACL(Default ACL)：只能对目录 预设型ACL(Default ACL) 格式：setfacl –m default:类型:特定的用户或组:权限 setfacl –m d:类型:特定的用户或组:权限 设置了预设型ACL的目录，其下的所有文件或者子目录就都具有了主目录的ACL权限，并且子目录也同样有预设的ACl权限 #注：只能对目录设置预设型 1234567891011121314151617181920212223242526272829303132333435示例 设置预设ACL---------------------------------------------------------------------------------------------------------------------------------[root@sanchuang-linux lianxi]# mkdir cc_test[root@sanchuang-linux lianxi]# getfacl cc_test/# file: cc_test/# owner: root# group: rootuser::rwxgroup::r-xother::r-x[root@sanchuang-linux lianxi]# setfacl -m d:u:sanle10:rw cc_test/ # 注：对文件进行预设型acl设置[root@sanchuang-linux lianxi]# getfacl cc_test/# file: cc_test/# owner: root# group: rootuser::rwxgroup::r-xother::r-xdefault:user::rwx # 注：新增的参数default:user:sanle10:rw-default:group::r-xdefault:mask::rwxdefault:other::r-x[root@sanchuang-linux lianxi]# cd cc_test/[root@sanchuang-linux cc_test]# touch aa # 注：新建的文件会继承预设的acl设置[root@sanchuang-linux cc_test]# getfacl aa# file: aa# owner: root# group: rootuser::rw-user:sanle10:rw- # 注：新建的文件会继承预设的acl设置group::r-x #effective:r--mask::rw-other::r--#注：预设之前已经创建的文件 不会继承预设的acl设置 五. 练习 1、新建三个组 shuiguo, mifeng, shaokao 2、新建3个用户，pingguo属于shuiguo组，jingshi属于mifen组，yueyang属于shaokao组 3、在根目录下新建目录food，将/etc/passwd文件复制到food目录下 4、设置权限，passwd文件能被shuiguo组读写，jingshi这个用户读写执行，yueyang这个用户不能进行任何操作 1234567891011121314151617181920212223242526272829示例---------------------------------------------------------------------------------------------------------------------------------#1[root@sanchuang-linux lianxi]# groupadd shuiguo[root@sanchuang-linux lianxi]# groupadd mifen[root@sanchuang-linux lianxi]# groupadd shaokao#2[root@sanchuang-linux lianxi]# useradd -g shuiguo pingguo[root@sanchuang-linux lianxi]# useradd -g mifen jingshi[root@sanchuang-linux lianxi]# useradd -g shaokao yueyang#3[root@sanchuang-linux lianxi]# mkdir /food[root@sanchuang-linux lianxi]# cp /etc/passwd /food[root@sanchuang-linux lianxi]# cd /food#4[root@sanchuang-linux food]# setfacl -m g:shuiguo:rw passwd [root@sanchuang-linux food]# setfacl -m u:jingshi:rwx passwd [root@sanchuang-linux food]# setfacl -m u:yueyang:--- passwd # 注：没有任何权限[root@sanchuang-linux food]# getfacl passwd # file: passwd# owner: root# group: rootuser::rw-user:jingshi:rwxuser:yueyang:---group::r--group:shuiguo:rw-mask::rwxother::r-- 六. 权限的继承和拒绝 一个用户属于某个组会继承这个组的权限。 ​ 1.主要组 ​ 2.次要组 用户的主要组（有效组）属于某个组，会继承这个组的权限，如果是附属组属于某个组，也会继承。 newgrp 拒绝权限高于一切 —》针对用户 一个组允许，一个组拒绝 —》允许 七. sudo授权 sudo授权 Linux里root用户权限最大 ​ 关机、重启系统、配置IP地址、格式化磁盘、mount等 普通用户权限非常小 如何让普通用户也具有一定的权限？ ​ 给root用户分忧 如果能授权，那么是授权给用户还是组？ #注：sudo授权给部分普通用户使用root用户的权限 #注：sudo --&gt; 授权给普通用户取执行命令的 #注：sudo配置文件 /etc/sudoers #注：有一个日志文件会记录下被授权者执行的所有命令 /var/log/secure #注：第一个ALL表示允许任何终端、机器访问sudo，一般就表示本机 #注：第二个ALL表示sudo命令可以允许以任何用户身份去执行 #注：第三个ALL表示可以执行任何命令 授权日志：有一个日志文件会记录下被授权者执行的所有命令 /var/log/secure 查看日志，知道授权命令的执行情况 [root@cali ~]# tailf /var/log/secure 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111示例1：生成随机密码#注：生成随机密码的工具 mkpasswdhttps://www.cnblogs.com/shijunxian/archive/2020/05/26/12961543.html---------------------------------------------------------------------------------------------------------------------------------[root@sanchuang-linux food]# yum install expect -y[root@sanchuang-linux bin]# mkpasswd -l 15 -d 3 -c 4 -C 4 -s 2wjp4[HC]hx6mSO6===============================================================================示例2：sudo配置文件 /etc/sudoers#注：授权给某些用户执行某些命令#注：编辑/etc/sudoers授权并验证---------------------------------------------------------------------------------------------------------------------------------[root@sanchuang-linux bin]# less /etc/sudoers………………## Syntax:#### user MACHINE=COMMANDS ………………## Allow root to run any commands anywhere root ALL=(ALL) ALL # 注：ALL表示当前这个机器#注：1、允许root用户执行这条命令 ； 2、ALL表示当前这个主机，(ALL)表示允许用户以哪个用户的权限设置 ； 3、ALL表示所有命令（在这个机器上面可以有任何用户的命令）#注：第一个ALL表示允许任何终端、机器访问sudo，一般就表示本机#注：第二个ALL表示sudo命令可以允许以任何用户身份去执行#注：第三个ALL表示可以执行任何命令===============================================================================示例3：编辑配置文件/etc/sudoers 给用户颁布权限#注：编辑配置文件 可以使用vim 也可以使用visudo 使用visudo不需要接文件名#注：推荐使用visodu去编辑/etc/sudoers，它会检测语法；vim去编辑不会检测#注：对于用户sanle有本地host所有权限---------------------------------------------------------------------------------------------------------------------------------[root@sanchuang-linux bin]# visudo # 注：使用visudo不需要接文件名## Allow root to run any commands anywhereroot ALL=(ALL) ALLsanle ALL=(ALL) ALL #注：表示sanle用户，可以在这台主机上执行任何用户的任何命令，但是使用sudo执行时需要输入sanle用户的密码#注：不设置NOPASSWD 第1次输入密码后 密码有时效性[root@sanchuang-linux bin]# su - sanle # 注：切换到sanle用户[sanle@sanchuang-linux ~]$ sudo passwd wy # 注：前面+sudo 能进行任何操作我们信任您已经从系统管理员那里了解了日常注意事项。总结起来无外乎这三点： #1) 尊重别人的隐私。 #2) 输入前要先考虑(后果和风险)。 #3) 权力越大，责任越大。[sudo] sanle 的密码： # 注：需要输入sanle用户 密码[root@sanchuang-linux bin]# visudo ## Allow root to run any commands anywhereroot ALL=(ALL) ALLsanle ALL=(ALL) NOPASSWD:ALL #注：表示sanle用户，可以在这台主机上执行任何用户的任何命令，无需输入sanle的密码[sanle@sanchuang-linux ~]$ sudo passwd wy更改用户 wy 的密码 。新的 密码： # 注：不需要验证原密码===============================================================================示例4：给用户/组颁布权限---------------------------------------------------------------------------------------------------------------------------------[root@sanchuang-linux bin]# visudo ## Allow root to run any commands anywhereroot ALL=(ALL) ALLsanle ALL=(ALL) NOPASSWD:ALL #注：表示sanle用户，可以在这台主机上执行任何用户的任何命令，无需输入sanle的密码%sanchuang5 ALL=(ALL) NOPASSWD:ALL #注：表示sanchuang5这个组的用户，在这台主机上可以执行任何用户的任何命令，无需输入密码#注：对于sanchuang5这个组赋予以任何用户执行任何权限#注：组里的所有成员也会拥有这个权限===============================================================================示例5 对于指定的命令去授权---------------------------------------------------------------------------------------------------------------------------------[sanle@sanchuang-linux ~]$ which chown/usr/bin/chown[sanle@sanchuang-linux ~]$ which passwd/usr/bin/passwd[root@sanchuang-linux cc_test]# visudoroot ALL=(ALL) ALLsanle ALL=(ALL) NOPASSWD:ALL%sanchuang5 ALL=(ALL) NOPASSWD:ALLwy ALL=(ALL) /usr/bin/chown,/usr/bin/passwd # 注：接命令的绝对路径#注：表示wy用户在这台主机上，拥有chown,passwd命令执行授权，命令路径写命令的绝对路径[wy@sanchuang-linux ~]$ sudo chmod 777 aa我们信任您已经从系统管理员那里了解了日常注意事项。总结起来无外乎这三点： #1) 尊重别人的隐私。 #2) 输入前要先考虑(后果和风险)。 #3) 权力越大，责任越大。[sudo] wy 的密码： # 注：验证密码后可以修改[wy@sanchuang-linux ~]$ sudo passwd wy2更改用户 wy2 的密码 。新的 密码：===============================================================================示例6：授权日志 /var/log/目录下 secure文件#注：有一个日志文件会记录下被授权者执行的所有命令 /var/log/secure---------------------------------------------------------------------------------------------------------------------------------[root@sanchuang-linux cc_test]# cd /var/log/[root@sanchuang-linux log]# less secure uid=0 tty=/dev/pts/2 ruser=wy rhost= user=wyNov 12 16:43:26 sanchuang-linux sudo[2424]: pam_unix(sudo:auth): conversation failedNov 12 16:43:26 sanchuang-linux sudo[2424]: pam_unix(sudo:auth): auth could not identify password for [wy]Nov 12 16:43:26 sanchuang-linux sudo[2424]: wy : command not allowed ; TTY=pts/2 ; PWD=/home/wy ; USER=root ; COMMAND=/bin/chmod 777 aa===============================================================================示例7---------------------------------------------------------------------------------------------------------------------------------[root@sanchuang-linux bin]# ls -ld /bin/passwd-rwsr-xr-x. 1 root root 33600 4月 7 2020 /bin/passwd#注：s位 普通用户有设置密码的权限，但是没有为他人设置密码的权限，且密码需要满足密码复杂度 八. 练习 yum install net-tools -y 授予bailongma用户：useradd、userdel、passwd 授予baigujing用户：ip、ping、ifconfig、route 授权yutujing用户：poweroff、reboot #注：授权不会检测系统里有该用户 12345678910111213141516171819202122232425262728293031323334353637383940414243示例1---------------------------------------------------------------------------------------------------------------------------------[wy@sanchuang-linux ~]$ which useradd # 注：查找命令的绝对路径/usr/sbin/useradd………………………………[wy@sanchuang-linux ~]# visudoroot ALL=(ALL) ALLbailongma ALL=(ALL) /usr/sbin/useradd,/usr/sbin/userdel,/usr/bin/passwdbaigujing ALL=(ALL) /usr/sbin/ip,/usr/bin/ping,/usr/sbin/ifconfig,/usr/sbin/routeyutujing ALL=(ALL) /usr/sbin/poweroff,/usr/sbin/reboot===============================================================================示例2：(ALL) 可以不写---------------------------------------------------------------------------------------------------------------------------------[wy@sanchuang-linux ~]# visudoroot ALL=(ALL) ALLbailongma ALL=/usr/sbin/useradd,/usr/sbin/userdel,/usr/bin/passwd # 注：(ALL) 可以不写baigujing ALL=/usr/sbin/ip,/usr/bin/ping,/usr/sbin/ifconfig,/usr/sbin/routeyutujing ALL=/usr/sbin/poweroff,/usr/sbin/reboot===============================================================================示例3：定义别名--------------------------------------------------------------------------------------------[wy@sanchuang-linux ~]# visudo#定义命令别名Cmnd_Alias NETWORK = /usr/sbin/ip,/usr/bin/ping,/usr/sbin/ifconfig,/usr/sbin/routeCmnd_Alias SHUT = /usr/sbin/poweroff,/usr/sbin/rebootCmnd_Alias USER = /usr/sbin/useradd,/usr/sbin/userdel,/usr/bin/passwdbailongma ALL=USER,NETWORKbaigujing ALL=NETWORKyutujing ALL=SHUT------------------------------------------------------------------------[baigujing@sanchuang-linux ~]$ sudo ip a add 192.168.0.144/24 dev ens33 #注：为网卡增加ip地址[sudo] baigujing 的密码： # 注：ip命令权限的使用[baigujing@sanchuang-linux ~]$ ip add……………… inet 192.168.0.26/24 brd 192.168.0.255 scope global dynamic noprefixroute ens33 inet 192.168.0.144/24 scope global secondary ens33………………------------------------------------------------------------------------#注：为网卡增加ip地址（1个网卡可以有多个ip地址）[wy@sanchuang-linux ~]$ ip a add 192.168.0.144/24 dev ens33 九. SELinux介绍 **SELinux是什么？有什么用？ ** 如何查看SELinux是否开启？ ​ getenforce 如何关闭和开启SELinux？ ​ 临时 ​ setenforce ​ 永久 ​ 修改配置文件 ​ vim /etc/selinux/config ​ vim /etc/sysconfig/selinux ​ 重新启动系统 SELinux在企业里使用多吗？ .--------------------------------------------------------------------------------------------------------------------------------------------------------------------- 12345678910111213141516SELinux是什么？·SELinux是一个linux系统里的一个安全方面的子系统，用来提升linux的整体的安全级别。是一种访问控制体系，进程只能访问那些在他的任务中所需要文件。（控制进程可以访问哪些允许访问的资源）·操作系统有两类访问控制：自主访问控制（DAC）和强制访问控制（MAC）。·标准Linux安全是一种DAC，SELinux为Linux增加了一个灵活的和可配置的的MAC。·DAC(Discretionary Access Control）自主访问控制·工作原理：·MAC(Mandatory Access Control）―――强制访问控制 ---》selinux·工作原理：·哪些进程能访问哪些类型的文件，都有安全策略 1234567891011121314151617永久修改#注：这是链接文件 /etc/sysconfig/selinux -&gt; /etc/selinux/config[root@cali log]# vim /etc/sysconfig/selinuxSELINUX=disabled临时配置临时配置，重新启动系统会失效0--》Permissive 宽容模式1--》Enforcing 强制执行模式 [root@cali selinux]# setenforce 0 [root@cali selinux]# getenforce Permissive[root@cali selinux]#[root@cali selinux]# setenforce 1 [root@cali selinux]# getenforce Enforcing[root@cali selinux]# 12345678·进程控制 ：控制哪些进程能访问哪些文件，因为它对进程和文件进行了分类，制定了策略，策略里规定了哪些类型的进程能操作哪些类型的文件。·服务异常不能访问--》通过网络不能访问·1.考虑iptables防火墙是否开启 ·2.考虑selinux安全机制是否开启·iptables 是外层的安全策略防火墙·selinux是linux内部的安全策略机制防火墙 123456789101112131415161718192021222324博客链接：https://blog.csdn.net/yanjun821126/article/details/80828908SELinux是内核集成的一个安全相关的子系统，可以让系统更加的安全内核版本2.6以上支持#注：查看内核版本 uname -r[root@sanchuang-linux bin]# uname -r4.18.0-193.el8.x86_64安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。SELinux 的作用SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）。DAC:在没有使用 SELinux 的操作系统中，决定一个资源是否能被访问的因素是：某个资源是否拥有对应用户的权限（读、写、执行）这种权限管理机制的主体是用户，也称为自主访问控制（DAC）MAC:在使用了 SELinux 的操作系统中，决定一个资源是否能被访问的因素除了上述因素之外，还需要判断每一类进程是否拥有对某一类资源的访问权限。这种权限管理机制的主体是进程，也称为强制访问控制（MAC）默认情况下SElinux属于关闭状态（disable） 服务访问不了基本是设置了SElinux 1234567891011121314151617181920212223示例：临时修改--------------------------------------------------------------------------------------------#注：临时修改 关机重启后失效#注：临时配置，重新启动系统会失效#注：0 --》Permissive 宽容模式#注：1 --》Enforcing 强制执行模式[root@sanchuang-linux ~]# getenforce # 注：获取当前selinux的模式Disabled[root@sanchuang-linux ~]# setenforce 0 # 注：0宽容模式 临时生效setenforce: SELinux is disabled[root@sanchuang-linux ~]# setenforce 1 # 注：1强制模式（一定要遵循SELinux规则）setenforce: SELinux is disabled#注：0|1 Permissive|Enforcing 宽容模式|强制执行模式============================================================================================示例：永久生效 修改配置文件#注：配置文件：/etc/selinux/config[root@sanchuang-linux ~]# vim /etc/selinux/config# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=disabled # 注：指定工作模式#注：修改之后生效，需要重启电脑","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"权限","slug":"权限","permalink":"https://blog1.cpen.top/tags/%E6%9D%83%E9%99%90/"}]},{"title":"17_Linux基础-用户权限2","slug":"Linux_基础/17_Linux基础-用户权限2","date":"2022-09-14T04:00:00.000Z","updated":"2022-09-14T05:00:00.000Z","comments":true,"path":"posts/14777.html","permalink":"https://blog1.cpen.top/posts/14777.html","excerpt":"","text":"一. 练习：批量创建n个用户 批量创建n个用户 用户名以sanchuang开头,sanchuang 指定家目录/lianxi/user 1234567891011121314151617181920212223242526272829303132333435示例---------------------------------------------------------------------------------------------------------------------------------[root@localhost ~]# seq -w 10 # 注：-w 同等长度输出0102………………0910[root@sanchuang-linux ~]# vim create_user2.sh#!/bin/bashnum=$1 # 注：$1外面 接收参数，改名字 见名知义[ -d /lianxi/user ] || mkdir /lianxi/user # 注：-d判断目录是否存在，-f判断普通文件是否存在for i in `seq -w $num` # 注：mkdir /lianxi/user 就可以了，不要加上用户名目录do # 注：判断是否存在，如果前面为真不做任何事情，如果为假就执行mkdir… useradd -d /lianxi/user/sanchuang$i sanchuang$idone[root@sanchuang-linux ~]# bash create_user2.sh 12useradd：用户“sanchuang01”已存在useradd：用户“sanchuang02”已存在………………useradd：用户“sanchuang10”已存在useradd：用户“sanchuang12”已存在[root@sanchuang-linux ~]# cd /lianxi/user[root@sanchuang-linux user]# lssanchuang01 ………… sanchuang10 sanchuang12[root@sanchuang-linux user]# cd[root@sanchuang-linux ~]# bash create_user2.sh 20useradd：用户“sanchuang01”已存在useradd：用户“sanchuang02”已存在………………useradd：用户“sanchuang12”已存在useradd：用户“sanchuang13”已存在[root@sanchuang-linux ~]# cd /lianxi/user[root@sanchuang-linux user]# lssanchuang01 ………… sanchuang18 sanchuang20 二. 一般情况下普通用户只能在家目录下或者/tmp目录下创建文件或者文件夹 一般情况下普通用户只能在家目录下或者/tmp目录下创建文件或者文件夹 #注：/tmp目录是一个临时目录，一般存放临时性的东西 #注：（如：程序运行中需要记录的一些东西，程序结束后把/tmp目录下的东西删掉） 123456789101112[root@sanchuang-linux ~]# su - sanchuang上一次登录：五 11月 6 17:09:41 CST 2020pts/2 上[sanchuang@sanchuang-linux ~]$ ls -ld /dr-xr-xr-x. 38 root root 4096 11月 5 15:12 /[sanchuang@sanchuang-linux ~]$ ls -ld /etcdrwxr-xr-x. 90 root root 8192 11月 7 15:00 /etc[sanchuang@sanchuang-linux ~]$ ls -ld ./ # 注：家目录下 创建文件或者文件夹drwxrwxrwx. 4 sanchuang sanchuang 122 11月 6 17:10 ./[sanchuang@sanchuang-linux ~]$ ls -ld /tmp # 注：/tmp目录下 创建文件或者文件夹drwxrwxrwt. 12 root root 264 11月 7 10:36 /tmp#注：chmod 自己是属主的时候，才可以修改权限 三. chmod chmod使用，必须是文件的属主，才能改动文件的读写执行权限（root除外） #注：chmod使用 用户必须是文件的属主才能修改（即使是文件属组里的成员也没有权限去修改文件） #注：root用户除外 1234567示例：su切换用户时 加- 不加- 区别[root@sanchuang-linux chenpeng]# su - sanchuang11 # 注：加 - 会自动切换到到家目录下上一次登录：六 11月 7 15:10:51 CST 2020pts/0 上[sanchuang11@sanchuang-linux ~]$ exit注销[root@sanchuang-linux chenpeng]# su sanchuang11 # 注：不加 - 会在当前目录下[sanchuang11@sanchuang-linux chenpeng]$ 四. 设置文件/目录的归属 设置文件/目录的归属 4.1 chown命令 chown命令 # 注：用来改变文件的属主和属组 必须是root # 注：chown 只能root去更改 用户和组必须存在 格式： chown 属主 文件 chown :属组 文件 chown 属主:属组 文件 12345678910111213141516171819202122示例：chown 修改文件的属主和属组--------------------------------------------------------------------------------------------[root@sanchuang-linux tmp]# ls -al sanchuang_log # 注：属主 sanchuang ; 属组 sanchuang-rw-rw-r-- 1 sanchuang sanchuang 673 11月 7 15:19 sanchuang_log[root@sanchuang-linux tmp]# chown sanchuang10 sanchuang_log # 注：修改属主 sanchuang10[root@sanchuang-linux tmp]# ls -al sanchuang_log -rw-rw-r-- 1 sanchuang10 sanchuang 673 11月 7 15:19 sanchuang_log[root@sanchuang-linux tmp]# chown :sanchuang9 sanchuang_log # 注：修改属组 sanchuang9[root@sanchuang-linux tmp]# ls -al sanchuang_log -rw-rw-r-- 1 sanchuang10 sanchuang9 673 11月 7 15:19 sanchuang_log[root@sanchuang-linux tmp]# chown sanchuang2:sanchuang sanchuang_log # 注：即改属主又改属组[root@sanchuang-linux tmp]# ls -al sanchuang_log -rw-rw-r-- 1 sanchuang2 sanchuang 673 11月 7 15:19 sanchuang_log#注：属主和属组不可以随便更改#注：数字随便改，没有限制 没有强制性的检查#注：改字符串形式的名字 会检查一下[root@sanchuang-linux tmp]# chown xixi:haha sanchuang_log # 注：修改 字符串会检查chown: 无效的用户: “xixi:haha”[root@sanchuang-linux tmp]# chown 6666:6666 sanchuang_log # 注：数字没有限制[root@sanchuang-linux tmp]# ls -al sanchuang_log -rw-rw-r-- 1 6666 6666 673 11月 7 15:19 sanchuang_log 4.2 chgrp命令 chgrp命令 # 注：修改属组（不常用） 格式： chgrp 属组 文件 必须是root或者是文件的所有者 必须是新组的成员 常用命令选项 -R：递归修改指定目录下所有文件、子目录的归属 12345示例：chgrp命令 修改属组--------------------------------------------------------------------------------------------[root@sanchuang-linux tmp]# chgrp sanchuang5 sanchuang_log # 注:只修改属组[root@sanchuang-linux tmp]# ls -al sanchuang_log -rw-rw-r-- 1 6666 sanchuang5 673 11月 7 15:19 sanchuang_log 4.3 可以执行的用户 可以执行的用户 操作 可以执行的用户 chmod root和文件所有者 chgrp root和文件所有者（必须是组成员） chown 只有root #注：chgrp修改属组 文件所有者 必须是想要修改的组里的组成员 五. 默认权限 在内核级别，文件的初始权限666 在内核级别，文件夹的初始权限777 用umask命令控制默认权限，临时有效 1234567891011[root@localhost ~]# umask 0022[root@localhost ~]# umask -S u=rwx,g=rx,o=rx [root@localhost ~]# umask 077 [root@localhost ~]# umask 0077不推荐修改系统默认umask# 注：umask规定默认创建文件或者文件夹的权限有多大============================================================================================[sanchuang9@sanchuang-linux ~]$ ls -ld dd # 注：新建的文件dd-rw-rw-r-- 1 sanchuang9 sanchuang9 0 11月 7 15:48 dd # 注：权限644============================================================================================ 5.1 /etc/profile下面有umask的设置 /etc/profile下面有umask的设置 系统环境设置 /etc/profile # 注：/etc/profile下面有umask的设置 #注：判断uid是否大于199，并且当前用户的 用户名和组名 相等的时候 umask 是 002 #注：用户名和组名不一样时 umask 是022 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495[sanchuang9@sanchuang-linux ~]$ less /etc/profile # 注：/etc/profile下面有umask的设置if [ $UID -gt 199 ] &amp;&amp; [ &quot;`/usr/bin/id -gn`&quot; = &quot;`/usr/bin/id -un`&quot; ]; then umask 002 # 注：如果uid大于199 执行 id -gn 命令 group_name ;id -un user_nameelse # 注：判定uid是否大于199，并且group_name=user_name umask 022 # 注：用户名和组名一样时 umask 是002 ； 用户名和组名不一样时 是 002fi--------------------------------------------------------------------------------------------#注：新建文件的权限是666-umask，新建目录的权限是777-umask#注：使用umask设置文件的权限，因为每次登陆shell都会加载系统的环境，会运行/etc/profile，所以会设置它的umask#注：id -gn 获取当前用户组名#注：id -un 获取当前用户名#uid大于199，并且当前用户的group_name和user_name名字相同的时候 umask是002#剩下的时候 umask是022·在内核级别，文件的初始权限666 ·在内核级别，文件夹的初始权限777·用umask命令控制默认权限，临时有效umask为002 则表示新建文件的默认权限为664，新建文件的文件夹权限为775umask为022 则表示新建文件的默认权限为644，新建文件的文件夹权限为755# 注：666 - umask 777 - umask============================================================================================示例：id -gn 获取当前用户组名; id -un 获取当前用户名--------------------------------------------------------------------------------------------[root@sanchuang-linux tmp]# /usr/bin/id -gnroot[root@sanchuang-linux tmp]# /usr/bin/id -unroot[root@sanchuang-linux tmp]# id -gn # 注：当前所在用户组名root[root@sanchuang-linux tmp]# id -un # 注：当前所在用户名root============================================================================================示例：判断2个字符串是否相等 可以用1个等号--------------------------------------------------------------------------------------------[root@sanchuang-linux tmp]# [ &quot;a&quot; = &quot;b&quot; ] || echo &quot;ok&quot; # 注：判断字符串相同 可以用一个等于号ok # 注：条件为假 输出ok[root@sanchuang-linux tmp]# [ &quot;a&quot; = &quot;b&quot; ] &amp;&amp; echo &quot;ok&quot; # 注：条件为真 输出ok[root@sanchuang-linux tmp]# [ &quot;a&quot; = &quot;a&quot; ] &amp;&amp; echo &quot;ok&quot;ok--------------------------------------------------------------------------------------------[root@sanchuang-linux tmp]# su - sanchuang # 注：用户名和组名一样时[sanchuang@sanchuang-linux ~]$ umask 0002 # 注：用户名和组名一样时 umask 是002[sanchuang@sanchuang-linux ~]$ id -gn # 注：第一位0是粘滞位 002是umasksanchuang[sanchuang@sanchuang-linux ~]$ id -unsanchuang[root@localhost ~]# su - b1 # 注：用户名 和 组名不一样时[b1@localhost ~]$ iduid=1204(b1) gid=1001(cali) 组=1001(cali),200(tech)[b1@localhost ~]$ id -unb1[b1@localhost ~]$ id -gncali[b1@localhost ~]$ umask # 注：用户名和组名不一样时 umask是0220022[b1@localhost ~]$ touch gg[b1@localhost ~]$ ls -ld gg # 注：新建文件的权限是644权限-rw-r--r--. 1 b1 cali 0 11月 8 16:27 gg[b1@localhost ~]$ umask 422 # 注：临时设置umask为422 （临时修改）[b1@localhost ~]$ mkdir test # 注：新建文件夹的权限是 355（777-umask）[b1@localhost ~]$ ls -ld test/d-wxr-xr-x. 2 b1 cali 6 11月 8 16:49 test/ # 注：目录权限355 写执行 读执行 读执行============================================================================================示例：临时设置umask--------------------------------------------------------------------------------------------[root@sanchuang-linux tmp]# umask 422 # 注：临时更改umask[root@sanchuang-linux tmp]# touch hh[root@sanchuang-linux tmp]# ls -ld hh--w-r--r-- 1 root root 0 11月 7 16:02 hh # 注：文件 权限是244 写读读============================================================================================示例：umask -S 查看文件目前默认权限是多少[sanchuang9@sanchuang-linux ~]$ umask -S # 注：查看文件目前默认权限是多少u=rwx,g=rwx,o=rx ============================================================================================示例：想要修改某个用户的umask，永久修改--------------------------------------------------------------------------------------------#注：在家目录下的.bashrc下添加umask设置 永久修改#注：/etc/profile,/etc/bashrc系统配置 基本上不要更改（不要想着改全局配置）[sanchuang9@sanchuang-linux ~]$ vim /home/sanchuang9/.bashrcumask=002[sanchuang9@sanchuang-linux ~]$ exit注销[root@sanchuang-linux tmp]# su - sanchuang9上一次登录：六 11月 7 16:07:40 CST 2020pts/0 上[sanchuang9@sanchuang-linux ~]$ umask # 注：umask变成002了0002[sanchuang9@sanchuang-linux ~]$ bash # 注：执行到新bash里面去 umask也是002[sanchuang9@sanchuang-linux ~]$ umask0002 六. 练习 6.1 新建文件夹/pem，复制/etc/hosts文件到pem目录下 1231、新建文件夹/pem，复制/etc/hosts文件到pem目录下[root@sanchuang-linux pem]# mkdir /pem[root@sanchuang-linux pem]# cp /etc/hosts /pem 6.2 修改hosts文件的权限为，属主有读写执行，组有读写执行，其他人没有任何权限 12342、修改hosts文件的权限为，属主有读写执行，组有读写执行，其他人没有任何权限[root@sanchuang-linux pem]# chmod 750 /pem/hosts [root@sanchuang-linux pem]# ls -al /pem/hosts -rwxr-x--- 1 root root 158 11月 7 16:20 /pem/hosts 6.3 新建/pem2目录，修改权限为任何人都有读写执行的权限 12343、新建/pem2目录，修改权限为任何人都有读写执行的权限[root@sanchuang-linux pem]# mkdir /pem2[root@sanchuang-linux pem]# chmod 777 /pem2[root@sanchuang-linux pem]# chmod 777 /pem2 -R # 注：连带下面所有的子文件 6.4 修改/pem2目录权限为属主有读写执行的权限，其他任何人都没有权限 124、修改/pem2目录权限为属主有读写执行的权限，其他任何人都没有权限[root@sanchuang-linux pem]# chmod 700 /pem2 6.5 修改/pem2任何人都没有任何权限 125、修改/pem2任何人都没有任何权限[root@sanchuang-linux pem]# chmod 000 /pem2 6.6 复制/etc/passwd和/etc/shadow文件到/pem目录下，查看复制之后的权限是否一致，如何保持权限一致 123456、复制/etc/passwd和/etc/shadow文件到/pem目录下，查看复制之后的权限是否一致，如何保持权限一致[root@sanchuang-linux pem]# cp /etc/&#123;passwd,shadow&#125; /pem[root@sanchuang-linux pem]# ls -al /pem--w-r--r-- 1 root root 3964 11月 7 16:23 passwd---------- 1 root root 4201 11月 7 16:23 shadow 6.7 cp -a 保留文件的属性（包括权限、时间、用户、组） cp -a 保留文件的属性（包括权限、时间、用户、组） 12345[root@sanchuang-linux pem]# cp /home/sanchuang9/.viminfo /tmp/viminfo # 注：cp过来 属主、属组发生改变[root@sanchuang-linux pem]# ls -al /tmp/viminfo --w------- 1 root root 1622 11月 7 16:30 /tmp/viminfo[root@sanchuang-linux pem]# ls -al /tmp/viminfo # 注：cp-a选项 属主、属组、权限、创建时间都没变-rw------- 1 sanchuang9 sanchuang9 1622 11月 7 16:11 /tmp/viminfo 七. 文件或目录的隐藏属性 chattr命令：设置文件的隐藏属性 格式：chattr [+-=] [ai] 文件或目录 # 注：+、-、= 分别表示 增加、去除、设置参数 常用命令选项 -R：递归修改 -a：可以增加文件内容，但不能修改和删除 -i：锁定保护文件 lsattr命令：查看文件的隐藏属性 格式：lsattr [Rda] 文件或目录 常用命令选项 -R：递归修改 -d：查看目录 #注：普通用户设置不了文件的隐藏属性；root用户才能设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647示例1：chattr +i hosts 锁定保护文件# 注：root用户也不能去修改它--------------------------------------------------------------------------------------------#注：不能更改文件（不能删 不能加 不能移动）[root@sanchuang-linux pem]# chattr +i hosts # 注：设置锁定保护文件；将它不能更改[root@sanchuang-linux pem]# mv hosts&#123;,.bak&#125; # 注：不能移动（即使是root用户）mv: 无法将&#x27;hosts&#x27; 移动至&#x27;hosts.bak&#x27;: 不允许的操作 [root@sanchuang-linux pem]# ls -al hosts # 注：ls -al命令 无法查看隐藏属性-rwxr-x--- 1 root root 158 11月 7 16:20 hosts[root@sanchuang-linux pem]# lsattr hosts # 注：lsattr 才能 查看文件隐藏属性 i----i--------------- hosts # 注：多了1个i属性[root@sanchuang-linux pem]# chattr -i hosts # 注：去除属性 去除锁定[root@sanchuang-linux pem]# lsattr hosts-------------------- hosts # 注：i隐藏属性没了#注：不能删，加，移动（root用户也不能）============================================================================================示例2：chattr +a hosts 可以增加文件内容，但不能修改和删除# 注：可以使用重定向去增加文件内容，但不能去修改和删除--------------------------------------------------------------------------------------------[root@sanchuang-linux pem]# chattr +a hosts # 注：可以增加文件内容，但是无法修改和删除[root@sanchuang-linux pem]# lsattr hosts-----a-------------- hosts # 注：多了a属性[root@sanchuang-linux pem]# vim hosts # 注：不可以修改[root@sanchuang-linux pem]# echo &quot;aaaa&quot; &gt;&gt; hosts # 注：可以追加[root@sanchuang-linux pem]# cat hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4aaaa[root@sanchuang-linux pem]# rm -rf hosts # 注：不可以删除rm: 无法删除&#x27;hosts&#x27;: 不允许的操作#注：不能修改，只能追加，不能删除#注：有时候无论什么情况都不想让它更改 +a属性============================================================================================示例3：chattr +i /etc/passwd--------------------------------------------------------------------------------------------[root@sanchuang-linux pem]# chattr +i /etc/passwd # 注：设置以后就创建不了用户[root@sanchuang-linux pem]# lsattr /etc/passwd # 注：查看隐藏属性----i--------------- /etc/passwd # 注：隐藏属性i[root@sanchuang-linux pem]# useradd sanchuang21 # 注：无论什么用户，设置了隐藏属性，基本没戏了useradd：无法打开 /etc/passwd[root@sanchuang-linux pem]# chattr -i /etc/passwd # 注：解锁============================================================================================示例4：普通用户设置不了文件的隐藏属性--------------------------------------------------------------------------------------------[root@localhost ~]# su - sanchuang[sanchuang@localhost ~]$ touch aa[sanchuang@localhost ~]$ chattr +i aa # 注：普通用户设置不了文件的隐藏属性chattr: 不允许的操作 while setting flags on aa 八. 文件的正常权限 123#注：正常文件的权限是读写执行[root@sanchuang-linux pem]# ls -ld /tmpdrwxrwxrwt. 12 root root 4096 11月 7 16:30 /tmp # 注：t 文件的特殊权限 九. 文件的特别权限 #注：set位权限设置 SET位权限 主要用途： 为可执行（有 x 权限的）文件设置，权限字符为“s” # 注：以前的x位变成s位 其他用户执行该文件时，将拥有属主或属组用户的权限 SET位权限类型： SUID：表示对属主用户增加SET位权限 SGID：表示对属组内的用户增加SET位权限 # 注：用在可执行文件 # 注：suid sgid 对应文件而言 123456789101112131415161718192021222324252627282930313233343536373839404142434445示例：/bin/passwd--------------------------------------------------------------------------------------------[root@localhost ~]# which passwd/bin/passwd[root@localhost ~]# ls -ld /bin/passwd -rwsr-xr-x. 1 root root 27856 4月 1 2020 /bin/passwd#注：普通用户以root用户的身份，间接更新了shadow文件中自己的密码[root@localhost ~]# su - sanchuang[sanchuang@localhost ~]$ passwd sanchuang # 注：不能更改密码 其他权限没到位passwd：只有根用户才能指定用户名。#注：s位 这个权限基本不会颁布，必须在有可执行文件下才能生效#注：这个权限设置 所有人全部给，不能精确到某个用户示例：SET位权限设置--------------------------------------------------------------------------------------------[root@sanchuang-linux pem]# ls -ld /pemd-wxr-xr-x 2 root root 47 11月 7 16:42 /pem # 注：只有root用户有写的权限#注：让/pem有普通用户创建、写入的权限？1.设置/pem的权限为7772.设置mkdir SUID的权限[root@sanchuang-linux sbin]# which mkdir/usr/bin/mkdir[root@sanchuang-linux sbin]# ls -ld /usr/bin/mkdir -rwxr-xr-x. 1 root root 195192 4月 10 2020 /usr/bin/mkdir # 注：没有设置s属性[root@sanchuang-linux sbin]# chmod u+s /bin/mkdir # 注：让普通用户执行mkdir时以root（属主）权限去运行[root@sanchuang-linux sbin]# ls -ld /usr/bin/mkdir # 注：变成s位了-rwsr-xr-x. 1 root root 195192 4月 10 2020 /usr/bin/mkdir[root@sanchuang-linux sbin]# su - sanchuang9上一次登录：六 11月 7 16:09:48 CST 2020pts/0 上[sanchuang9@sanchuang-linux ~]$ cd /pem[sanchuang9@sanchuang-linux pem]$ lshosts passwd shadow[sanchuang9@sanchuang-linux pem]$ mkdir aa # 注：普通用户有写的权限了[sanchuang9@sanchuang-linux pem]$ ls -ld /pemd-wxr-xr-x 3 root root 57 11月 7 16:59 /pem[sanchuang9@sanchuang-linux pem]$ touch dd # 注：touch没有这个权限touch: 无法创建 &#x27;dd&#x27;: 权限不够[sanchuang9@sanchuang-linux pem]$ exit注销[root@sanchuang-linux sbin]# chmod u-s /bin/mkdir[root@sanchuang-linux sbin]# ls -ld /bin/mkdir -rwxr-xr-x. 1 root root 195192 4月 10 2020 /bin/mkdir# 注：s位基本不会给# 注：s位不要轻易的颁布它，会对用户进行影响 十. 粘滞位权限（Sticky） 粘滞位权限（Sticky） 主要用途： 为公共目录（例如，权限为777的）设置，权限字符为“t” # 注：t 粘滞位标记字符 用户不能删除该目录中其他用户的文件 # 注：一般作用于文件夹 # 注：粘滞位对于文件夹而言 123456789101112131415161718192021222324252627282930313233343536示例1--------------------------------------------------------------------------------------------[root@sanchuang-linux sbin]# ls -ld /tmpdrwxrwxrwt. 12 root root 4096 11月 7 16:30 /tmp # 注：/tmp目录 任何用户 都有读写执行权限#注：因为粘滞位权限，用户在/tmp目录下只能创建自己的，删除自己的#注：一般作用于文件夹#注：sanchuang10用户不能删除sanchuang用户创建的文件==============================================================================================================示例2：chmod 777 /pem 普通用户可以操作/pem这一层目录下的文件或者文件夹及子文件# 注：777权限，不同用户可以相互删除文件# 注：设置粘滞位后，只能删除自己创建的文件--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# chmod 777 /pem # 注：把/pem文件夹权限改为777[root@sanchuang-linux ~]# ls -ld /pem # 注：所有用户都有对/pem读写执行的权限 包括创建、删除drwxrwxrwx 3 root root 74 11月 7 17:10 /pem[root@sanchuang-linux ~]# su - sanchuang9 # 注：普通用户有创建的权限上一次登录：六 11月 7 17:07:17 CST 2020pts/2 上[sanchuang9@sanchuang-linux ~]$ touch /pem/sanchuang9 # 注：普通用户有创建的权限[root@sanchuang-linux ~]# su - sanchuang[sanchuang@sanchuang-linux ~]$ rm -rf /pem/sanchuang9 # 注：普通用户有删除的权限#注：用户可以删除其他用户创建的文件==============================================================================================================示例3：粘滞位 t# 注：设置粘滞位后，只能删除自己创建的文件[sanchuang9@sanchuang-linux tmp]$ ls -ld /tmpdrwxrwxrwt. 13 root root 4096 11月 7 17:07 /tmp # 注：/tmp目录设置了1个粘滞位[sanchuang9@sanchuang-linux ~]$ touch /tmp/sanchuang9[sanchuang9@sanchuang-linux ~]$ exit[root@sanchuang-linux ~]# su - sanchuang上一次登录：日 11月 8 19:05:55 CST 2020pts/3 上[sanchuang@sanchuang-linux ~]$ rm -rf /tmp/sanchuang9 # 注：因为设置了1个粘滞位rm: 无法删除&#x27;/tmp/sanchuang9&#x27;: 不允许的操作 # 注：用户只能在/tmp目录下创建 删除自己的#注：粘滞位的作用#注：·为公共目录（例如，权限为777的）设置，权限字符为“t”#注：·用户不能删除该目录中其他用户的文件#注：一般作用于文件夹 十一. 设置SET位、粘滞位权限 设置SET位、粘滞位权限 使用权限字符 chmod ug±s 可执行文件... # 注：设置set位 chmod o±t 目录名... # 注：设置粘滞位 使用权限数字 chmod mnnn 可执行文件... m为4时，对应SUID，2对应SGID，1对应粘滞位，可叠加 # 注：m为4 为2 set位 123456789101112131415161718192021示例--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# ls -ld /tmpdrwxrwxrwt. 13 root root 4096 11月 7 17:07 /tmp # 注：/tmp目录设置了粘滞位，权限为1777#注：/tmp目录设置了粘滞位，第1位是1============================================================================================示例：设置粘滞位--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# chmod 1777 /pem[root@sanchuang-linux ~]# ls -ld /pemdrwxrwxrwt 3 root root 74 11月 7 17:10 /pem # 注：粘滞位 t 之前 x 的位置#注：普通情况下不需要使用粘滞位、set位的时候，用3个数字就可以了-----------------------------------------------------------------[root@sanchuang-linux ~]# ls -ld /bin/mkdir -rwxr-xr-x. 1 root root 195192 4月 10 2020 /bin/mkdir[root@sanchuang-linux ~]# chmod 4755 /bin/mkdir # 注：设置为SET位SUID权限[root@sanchuang-linux ~]# ls -ld /bin/mkdir -rwsr-xr-x. 1 root root 195192 4月 10 2020 /bin/mkdir[root@sanchuang-linux ~]# chmod 755 /bin/mkdir # 注：改回来[root@sanchuang-linux ~]# ls -ld /bin/mkdir -rwxr-xr-x. 1 root root 195192 4月 10 2020 /bin/mkdir","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"权限","slug":"权限","permalink":"https://blog1.cpen.top/tags/%E6%9D%83%E9%99%90/"}]},{"title":"16_Linux基础-文件&目录权限及归属","slug":"Linux_基础/16_Linux基础-文件&目录权限及归属","date":"2022-09-13T04:00:00.000Z","updated":"2022-09-13T05:00:00.000Z","comments":true,"path":"posts/5637.html","permalink":"https://blog1.cpen.top/posts/5637.html","excerpt":"","text":"一. 文件/目录的权限 文件/目录的权限 访问权限 可读(read)：允许查看文件内容、显示目录列表 r 可写(write)：允许修改文件内容，允许在目录中新建、移动、删除文件或子目录 w 可执行(execute)：允许运行程序、切换目录 x 归属（所有权） 文件拥有者(owner)：拥有该文件或目录的用户帐号 # 注：属主 属组(group)：拥有该文件或目录的组帐号 # 注：属组 其它人(others)：除了属主和属组的其他人 # 注：其他 #注：区分是对于文件而言还是对于目录而言 12ls -al 查看当前目录下面文件或者文件夹的详细信息，包括文件的权限ls -ld 查看当前目录 123456789101112131415161718192021示例1：查看文件权限 ls -al# 注：第三列属主 第四列属组---------------------------------------------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# ls -al #注：查看文件权限总用量 668-rw-r--r--. 1 root root 211 9月 18 10:31 &#x27;!&#x27;dr-xr-x---. 21 root root 12288 11月 6 15:16 .[root@sanchuang-linux ~]# ls -al zuoye.sh # 注：查看单个文件权限-rw-r--r--. 1 root root 1212 10月 29 20:20 zuoye.sh[root@sanchuang-linux ~]# ls -al /home # 注：查看/home目录下所有文件的权限总用量 18348drwxr-xr-x. 43 root root 4096 11月 6 15:36 .dr-xr-xr-x. 38 root root 4096 11月 5 15:12 ..[root@sanchuang-linux ~]# ls -al *.sh # 注：查看文件权限-rw-r--r--. 1 root root 0 9月 25 09:35 backup_log.sh-rw-r--r--. 1 root root 41 10月 28 20:27 file_test.sh示例2：查看目录权限 ls -ld /home--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# ls -ld /home # 注：查看/home 目录的权限drwxr-xr-x. 43 root root 4096 11月 6 15:36 /home 二. 文件/目录的权限 123[root@localhost ~]# ls -ld first.py -rw-r--r--. 1 root root 1097 10月 13 10:20 first.py文件类型 访问权限 所有者 属组 123456789101112131415161718192021222324252627282930313233343536373839404142示例：drwxr-xr-x--------------------------------------------------------------------------------------------第一列：表示文件类型与权限 第一个字符 - 普通文件 file d 表示目录 s 表示socket文件 # 注：socket（套接字） 进程之间通信的一种方式。 p 管道文件 pipe c 字符设备文件 tty b 块设备文件 磁盘（disk） # 注：跟硬件相关的块设备文件一般放在 /dev下面 l 链接文件 # 注：/usr/bin/目录下 有大量 链接文件 #权限 r 可读 w 可写 x 可执行 ·第2-第4个字符 表示属主的权限 ·第5-第7个字符 表示属组的权限 ·后三个 表示其他人的权限--------------------------------------------------------------------------------------------敲的所有命令都是在PATH环境变量路径下查找创建链接文件# 注：ln -s 源文件 目标文件 symbolic adj. 象征的；符号的；使用符号的[root@sanchuang-linux bin]# ln -s python3.6 python # 注：-s创建软链接[root@sanchuang-linux bin]# ln -s python3.6 /root/python # 注：可以在绝对路径下创建链接文件#注：链接文件/root/python 放在了/root目录下which查看命令的绝对路径[root@sanchuang-linux bin]# which mkdir/usr/bin/mkdir[root@sanchuang-linux bin]# mv /usr/bin/mkdir /usr/bin/mkdirbak # 注：修改名字后 命令找不到了[root@sanchuang-linux bin]# mkdir-bash: mkdir: 未找到命令[root@sanchuang-linux bin]# mkdirbak /tmp/mkdir[root@sanchuang-linux bin]# mv /usr/bin/mkdirbak /usr/bin/mkdir # 注：改回来/usr/bin/下有大量链接文件[root@sanchuang-linux tmp]# cd /usr/bin/ # 注：/usr/bin/下有大量链接文件[root@sanchuang-linux bin]# ls -al python2 # 注：链接文件lrwxrwxrwx. 1 root root 9 6月 5 11:38 python2 -&gt; python2.7[root@sanchuang-linux bin]# ls -al python3 # 注：链接文件lrwxrwxrwx. 1 root root 25 9月 18 15:47 python3 -&gt; /etc/alternatives/python3 三. socket（套接字） #注：socket（套接字） 进程之间通信的一种方式，通常用于不同主机不同进程之间的通信方式（网络编程） ftp有vsftpd的服务，vsftpd服务端服务起来了开启21号端口。ftp客户端要想连接这个服务，ftp客户端需要开启一个随机端口去连接21号端口，进行网络传输。通过网络指定某种特定协议，进行网络连接。 开启一个vsftpd，会产生一个socket文件 开放了端口基本上都会有一个socket文件 123[root@localhost mail]# cd /data/mysql[root@localhost mysql]# ls -alsrwxrwxrwx 1 mysql mysql 0 10月 7 12:04 mysql.sock # 注：s socket文件 （粉色） 四. Linux内核五大子系统 Linux内核五大子系统： 1、文件系统 2、内存管理 3、进程通信 4、进程调度 5、网络接口 五. 进程 进程是系统进行资源分配的基本单位，不同进程之间资源是互相隔离的 进程之间通信（常见的5种）： 管道 信号 （kill -9） 共享内存 socket套接字 消息队列 12345678910111213141516171819202122232425示例1：管道 #注：管道是进程之间通信的一种方式示例[root@sanchuang-linux ~]# cat /etc/passwd |grep sanchuang # 注：通过管道把前进程的输出赋给后进程的输入sanchuang:x:1005:1005::/home/sanchuang:/bin/bash#注：适用于相同主机不同进程--------------------------------------------------------------------------------------------示例2：信号 示例：kill -9 pid[root@sanchuang-linux ~]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1………………[root@sanchuang-linux ~]# ps -ef |grep nginxroot 5868 5691 0 16:29 pts/0 00:00:00 grep --color=auto nginx[root@sanchuang-linux ~]# kill -9 2868 # 注：发送9这个信号给1209进程--------------------------------------------------------------------------------------------示例3：共享内存#注：A、B之间创建了一片新的内存空间，可以一起去拿#注：适用于相同主机不同进程--------------------------------------------------------------------------------------------示例4：socket套接字#注：用于不同主机之间不同进程 网络通信--------------------------------------------------------------------------------------------示例5：消息队列#注：相当于排队的 1,2,3,4,5,6#注：AB共享的内存空间里，A产生的B去获取。A产生1，B取出来，1从A里出去 六. /根目录下 /etc 存放配置文件 /dev 存放设备文件 # 注：硬件相关的 磁盘、网卡、socket /root # 注：root用户家目录 /home # 注：存放普通用户的家目录文件 123456[root@sanchuang-linux ~]# cd /dev[root@sanchuang-linux dev]# ls -alcrw-rw-rw- 1 root tty 5, 0 11月 6 11:32 tty # 注：字符设备文件 ttycrw--w---- 1 root tty 4, 0 11月 5 15:12 tty0crw--w---- 1 root tty 4, 1 11月 6 14:28 tty1brw-rw---- 1 root disk 8, 0 11月 5 15:12 sda # 注：块设备文件 磁盘 七. 可执行权限 12345678第一列第二到第十个字符 #权限 r 可取 w 可写 x 可执行 第2-第4个字符 表示属主的权限 第5-第7个字符 表示属组的权限 后三个 表示其他人的权限 12345678910示例--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# ls -al men_test.sh -rw-r--r--. 1 root root 0 10月 30 16:26 men_test.sh[root@sanchuang-linux ~]# bash men_test.sh # 注：使用bash解释器去执行（生成一个新的bash）[root@sanchuang-linux ~]# sh men_test.sh # 注：使用sh解释器去执行（生成一个新的sh）[root@sanchuang-linux ~]# . men_test.sh # 注：使用当前bash去执行，会继承当前环境变量#注：相当于当前bash，当前环境[root@sanchuang-linux ~]# ./men_test.sh # 注：权限不够，本身没有可执行权限-bash: ./men_test.sh: 权限不够 # 注：有可执行权限的文件 可以直接./men_test.sh执行 八. Shell文件执行方式 Shell文件执行方式（3种） #注：shell里面可执行文件后缀没有要求 不一定非要.sh结尾 123456789101112131415161718192021222324252627[root@sanchuang-linux ~]# vim test_aa.shecho &quot;testaa...&quot;echo $aecho $b[root@sanchuang-linux ~]# a=1[root@sanchuang-linux ~]# b=2[root@sanchuang-linux ~]# . test_aa.sh # 注：使用当前bash去执行test_aa.sh，会继承当前 shell 的 环境变量testaa... # 注：用.会继承当前bash里的一切变量12[root@sanchuang-linux ~]# bash test_aa.sh # 注：创建一个新的bash环境去执行命令testaa... # 注：新bash环境中没有定义a、b变量 # 注：没有输出父bash的a、b # 注：没有获取到a、b[root@sanchuang-linux ~]# sh test_aa.sh # 注：创建一个新的sh环境去执行命令testaa... # 注：没有输出[root@sanchuang-linux ~]# ./test_aa.sh # 注：执行文件本身，看文件本身有没有执行权限-bash: ./test_aa.sh: 权限不够 # 注：直接执行当前目录下的这个文件 需要可执行权限# 注：其他的方式不一定需要可执行权限总结. test_aa.sh 不需要可执行权限 当前bash进程执行bash test_aa.sh 不需要可执行权限 新的bash进程运行sh test_aa.sh 不需要可执行权限 新的bash进程运行./test_aa.sh 需要可执行权限 新的bash进程运行 九. chmod命令 chmod命令 # 注：修改文件的访问权限 格式1：chmod [ugoa] [+-=] [rwx] 文件或目录... u、g、o、a 分别表示 u属主、g属组、o其他用户、a所有用户 +、-、= 分别表示 +增加、-去除、=设置权限 rwx 对应的权限字符 常用命令选项 -R：递归修改指定目录下所有文件、子目录的权限 12345678910111213141516171819示例--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# chmod u+x men_test.sh # 注：对属主+可执行权限[root@sanchuang-linux ~]# ls -al men_test.sh -rwxr--r--. 1 root root 0 10月 30 16:26 men_test.sh # 注：可执行文件 都是绿的#注：可执行文件 都是绿的#注：socket文件 都是粉的[root@sanchuang-linux ~]# ./men_test.sh # 注：可以直接执行了--------------------------------------------------------------------------------------------[root@sanchuang-linux lianxi]# chmod a-x sc -R # 注：-R递归，把该目录和该目录下的所有子文件都去除可执行权限[root@sanchuang-linux lianxi]# chmod a+x sc -R # 注：所有用户增加可执行权限============================================================================================#注：根目录只有root用户能用[root@sanchuang-linux ~]# ls -ld /dr-xr-xr-x. 38 root root 4096 11月 5 15:12 /============================================================================================[root@mysql-binary ~]# chmod u+x group_member.sh [root@mysql-binary ~]# ./group_member.sh sanchuang5 # 注：添加了可执行权限后可以 ./运行sanchuang5,sanchuang11,sanchuang13,sanchuang10,sanchuang12 十. chmod命令 chmod命令 # 注：修改文件的访问权限 格式2：chmod nnn 文件或目录... # 注：nnn表示3位八进制数 权限项 读 写 执行 读 写 执行 读 写 执行 字符表示 r w x r w x r w x 数字表示 4 2 1 4 2 1 4 2 1 权限分配 文件所有者 文件所属组 其他用户 常用命令选项 -R：递归修改指定目录下所有文件、子目录的权限 #注：root用户基本上无论有没有权限，它都可以使用 12345678910111213141516171819示例--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# chmod 777 sc # 注：都有读写执行的权限[root@sanchuang-linux ~]# chmod 700 sc # 注：属主有读写执行的权限--------------------------------------------------------------------------------------------[root@sanchuang-linux home]# ls -ld sanchuang # 注：查看目录权限 ls -lddrwx------. 4 sanchuang sanchuang 122 11月 6 17:10 sanchuang[root@sanchuang-linux home]# chmod 777 /home/sanchuang # 注：都有读写执行的权限[root@sanchuang-linux home]# ls -ld sanchuangdrwxrwxrwx. 4 sanchuang sanchuang 122 11月 6 17:10 sanchuang[root@sanchuang-linux home]# chmod 777 /home/sanchuang -R # 注：-R：递归修改指定目录下所有文件、子目录的权限[root@sanchuang-linux home]# ls -ld sanchuangdrwxrwxrwx. 4 sanchuang sanchuang 122 11月 6 17:10 sanchuang#注：用户的家目录下（如/home/sanchuang）授予所有对象读写执行权限，会造成普通用户sanchuang无法进行远程登录示例：root用户基本上无论有没有权限，它都可以使用[root@sanchuang-linux ~]# ls -ld /etc/shadow---------- 1 root root 4201 11月 7 12:04 /etc/shadow[root@sanchuang-linux ~]# vim /etc/shadow 十一. 一般情况下普通用户只能在家目录下或者/tmp目录下创建文件或者文件夹 一般情况下普通用户只能在家目录下或者/tmp目录下创建文件或者文件夹 #注：/tmp目录是一个临时目录，一般存放临时性的东西（如：程序运行中需要记录的一些东西，程序结束后把/tmp目录下的东西删掉） 123456789101112[root@sanchuang-linux ~]# su - sanchuang上一次登录：五 11月 6 17:09:41 CST 2020pts/2 上[sanchuang@sanchuang-linux ~]$ ls -ld /dr-xr-xr-x. 38 root root 4096 11月 5 15:12 /[sanchuang@sanchuang-linux ~]$ ls -ld /etcdrwxr-xr-x. 90 root root 8192 11月 7 15:00 /etc[sanchuang@sanchuang-linux ~]$ ls -ld ./ # 注：家目录下 创建文件或者文件夹drwxrwxrwx. 4 sanchuang sanchuang 122 11月 6 17:10 ./[sanchuang@sanchuang-linux ~]$ ls -ld /tmp # 注：/tmp目录下 创建文件或者文件夹drwxrwxrwt. 12 root root 264 11月 7 10:36 /tmp#注：chmod 自己是属主的时候，才可以修改权限 十二. chmod chmod # 注：修改文件的归属权限 chmod使用，必须是文件的属主，才能改动文件的读写执行权限（root除外） 123456[root@sanchuang-linux chenpeng]# su - sanchuang11 # 注：加 - 会自动到家目录下上一次登录：六 11月 7 15:10:51 CST 2020pts/0 上[sanchuang11@sanchuang-linux ~]$ exit注销[root@sanchuang-linux chenpeng]# su sanchuang11 # 注：不加 - 会在当前路径下[sanchuang11@sanchuang-linux chenpeng]$","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"权限","slug":"权限","permalink":"https://blog1.cpen.top/tags/%E6%9D%83%E9%99%90/"}]},{"title":"15_Linux基础-用户与组2","slug":"Linux_基础/15_Linux基础-用户与组2","date":"2022-09-12T04:00:00.000Z","updated":"2022-09-12T05:00:00.000Z","comments":true,"path":"posts/43746.html","permalink":"https://blog1.cpen.top/posts/43746.html","excerpt":"","text":"一. 练习 1.1 如何知道一个用户是否在linux系统里存在？ 1231、如何知道一个用户是否在linux系统里存在？cat /etc/passwd或者 id命令 1.2 如何禁用一个用户登陆linux系统 1232、如何禁用一个用户登陆linux系统使用usermod -L 锁定用户usermod -s /sbin/nologin root 1.3 如何知道一个用户属于哪些组 12343、如何知道一个用户属于哪些组使用id命令查看使用groups命令查看查看/etc/group里用户所属的组 1.4 如何知道哪些用户现在已经登录在linux里？ 哪些用户曾经登陆过linux系统？ 123456789101112134、如何知道哪些用户现在已经登录在linux里？ 哪些用户曾经登陆过linux系统？使用w命令查看用户登录情况使用last命令查看曾经登录过的用户示例：w who 看当前登录的用户#注：w看的更详细些[root@localhost ~]# w 09:37:40 up 8:32, 5 users, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot tty1 四09 6:28 0.09s 0.09s -bashroot pts/3 192.168.136.1 09:29 4.00s 0.05s 0.03s w[root@localhost ~]# whoroot tty1 2020-11-05 09:31root pts/3 2020-11-06 09:29 (192.168.136.1) 1.5 如何给用户重新设置密码 125、如何给用户重新设置密码passwd 1.6 linux的root密码忘记了怎么办 12345676、linux的root密码忘记了怎么办 进入单用户模式 1、开机，按任意键停住启动界面，然后选择对应的内核，按 e 进行编辑 2、找到linux16这一行，在最后输入 rd.break 3、按 Ctrl-x 启动，然后按照以下操作破解 root 密码示例：忘记root用户密码怎么办？答：进入单用户模式 ​ https://blog.csdn.net/qq_37960324/article/details/84589565 ​ https://www.cnblogs.com/jsjrj01/p/10301603.htm 1.7 如何将已经登录在系统里的用户踢出去？并且防止它再次登陆？ 12347、如何将已经登录在系统里的用户踢出去？并且防止它再次登陆？1.踢出可疑的root登录用户，马上修改密码 2.sshd---》/etc/hosts.deny hosts.allow --&gt;ip 3./etc/ssh/sshd_config --&gt;DenyUsers --&gt;用户 1.8 怎么把普通用户变成root用户 1238、怎么把普通用户变成root用户1.（不推荐）修改 /etc/passwd 文件，找到要修改的普通用户，把用户ID修改为 02.sudo 权限 1.9 12345678910111213141516171819202122· 创建目录/tech/cali和/tech/sanle，分别用于保存个项目组中用户帐号的宿主目录；· 为两个项目组添加组帐号cali、sanle，GID号分别为1001、1002；为技术部添加组帐号tech，GID号为200；· 添加2个用户，分别为b1、b2，要求他们的基本组是cali，附加组是tech，宿主目录均使用/tech/cali目录中与帐号同名的文件夹（例如b1用户的宿主目录/tech/cali/b1）；其中b2用户帐号设置2012-12-31日后失效；· 添加2个用户，分别为a1、a2，要求他们的基本组是sanle，附加组是tech；宿主目录均使用/tech/sanle目录中与帐号同名的文件夹（例如a1用户的宿主目录/tech/cali/a1） ；其中a2用户帐号登录的shell为/bin/ksh所有新建用户密码都是123456；1、mkdir -p /tech/cali /tech/sanle2、groupadd -g 1001 cali groupadd -g 1002 sanle groupadd -g 200 tech3、useradd -g cali -G tech -d /tech/cali/b1 b1 useradd -g cali -G tech -d /tech/cali/b2 -e 2020-11-6 b24、useradd -g sanle -G tech -d /tech/sanle/a100 a1 useradd -g sable -G tech -d /tech/sanle/a200 -s /bin/ksh a25、echo 123456|passwd a1 --stdin echo 123456|passwd a2 --stdin----------------------------------------------------------------示例：过期账户不能登录-----------------------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# useradd -e &quot;2012-11-22&quot; sanle3 # 注：过期账户不能登录[root@sanchuang-linux ~]# su - sanle3 # 注：可以切换，不能登录[sanle3@sanchuang-linux ~]$ 二. /etc/group文件 /etc/group文件 #注：/etc 存放配置文件的地方 /etc/group文件 # 注：可以查看哪些账户的次要组是 组帐号： 主要组(私有组) 次要组(附属组) GID：（Group Identify，组标识号） Linux组帐号 主要组(私有组) 与用户相关的默认组，在/etc/passwd文件的第四个字段定义 次要组(附属组) 用户可以同时属于其他的组，在/etc/group文件的第四个字段定义 用户的主要组的名称和GID相关 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152示例---------------------------------------------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# useradd -g sanchuang4 -G sanchuang5 sanchuang10[root@sanchuang-linux ~]# useradd -g sanchuang4 -G sanchuang5 sanchuang12[root@sanchuang-linux ~]# useradd -g sanchuang5 -G sanchuang4 sanchuang13[root@sanchuang-linux ~]# cat /etc/groupsanchuang4:x:1100:sanchuang13 # 注：只显示次要组的组成员列表sanchuang5:x:1200:sanchuang10,sanchuang12 # 注：只显示次要组的组成员列表#注：组账号名：sanchuang5；GID：1200；组成员列表sanchuang10,sanchuang12#注：只显示次要组的组成员列表===========================================================================================================示例：怎样查看一个组里有哪些用户---------------------------------------------------------------------------------------------------------------------------------#注：联系2个文件 /etc/passwd /etc/group[root@sanchuang-linux ~]# awk -F: &#x27;/sanchuang5/&#123;print $3,$4&#125;&#x27; /etc/group 1200 sanchuang10,sanchuang12 # 注：模糊匹配，匹配包含sanchuang5的行[root@sanchuang-linux ~]# awk -F: &#x27;$1==&quot;sanchuang5&quot;&#123;print $3,$4&#125;&#x27; /etc/group # 注：加引号1200 sanchuang10,sanchuang12 # 注：精确匹配--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# vim group_member.sh#!/bin/bashgroup_name=$1 #注：组名作为参数#/etc/group获取它的GID和成员列表group_msg=`awk -F: -v group_awk=$group_name &#x27;$1==group_awk&#123;print $3,$4&#125;&#x27; /etc/group`echo $group_msg #注：-v选项 向awk传递shell变量 指定外部$group_name赋给awk内部变量 运行的时候用自定义的变量[root@sanchuang-linux ~]# sh group_member.sh sanchuang51200 sanchuang10,sanchuang12--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# a=&#x27;1200 sanchuang10,sanchuang12&#x27;[root@sanchuang-linux ~]# s1=(a b c d e)[root@sanchuang-linux ~]# s2=($a) # 注：转化为数组[root@sanchuang-linux ~]# echo $s21200[root@sanchuang-linux ~]# echo $s2[@]1200[@][root@sanchuang-linux ~]# echo $&#123;s2[@]&#125; # 注：获取数组里全部元素1200 sanchuang10,sanchuang12[root@sanchuang-linux ~]# echo $&#123;#s2[@]&#125; # 注：获取数组长度2[root@sanchuang-linux ~]# echo $&#123;#s2&#125; # 注：获取第一个元素 字符的长度4[root@sanchuang-linux ~]# echo $&#123;s2[0]&#125; # 注：获取数组里第一个元素1200[root@sanchuang-linux ~]# echo $&#123;s2[1]&#125; # 注：获取数组里第二个元素sanchuang10,sanchuang12-----------------------------------------group_name=$1 #注：组名作为参数#/etc/group获取它的GID和成员列表group_msg=`awk -F: -v group_awk=$group_name &#x27;$1==group_awk&#123;print $3,$4&#125;&#x27; /etc/group`#注：-v选项 向awk传递shell变量 指定外部$group_name赋给awk内部变量 运行的时候用自定义的变量#注：获取数组里第一个元素group_lst=($group_msg) #注：转变成数组group_id=$&#123;group_lst[0]&#125; # 注：gidgroup_user_1=$&#123;group_lst[1]&#125; # 注：该组（次要组）成员--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# vim group_member.sh#!/bin/bash group_name=$1 #注：组名作为参数#/etc/group获取它的GID和成员列表group_msg=`awk -F: -v group_awk=$group_name &#x27;$1==group_awk&#123;print $3,$4&#125;&#x27; /etc/group`#注：-v选项 向awk传递shell变量 指定外部$group_name赋给awk内部变量 运行的时候用自定义的变量#注：获取数组里第一个元素group_lst=($group_msg) #注：转变成数组group_id=$&#123;group_lst[0]&#125;group_user_1=$&#123;group_lst[1]&#125;#注：获取/etc/passwd 主要组 成员；tr &quot;\\n&quot; &quot;,&quot; 指定分隔符为,；过滤出 $4==group_id 的行group_user_2=`awk -F: -v group_id=$group_id &#x27;$4==group_id&#123;print $1&#125;&#x27; /etc/passwd|tr &quot;\\n&quot; &quot;,&quot;`echo $group_user_2$group_user_1 # 注：直接拼接 不需要加“+”号[root@sanchuang-linux ~]# sh group_member.sh sanchuang5sanchuang13,sanchuang10,sanchuang12--------------------------------------------------------[root@sanchuang-linux ~]# cat /etc/passwdsanchuang13:x:1034:1200::/home/sanchuang13:/bin/bash # 注：gid 位置 $4===========================================================================================================总结：查看组中有哪些成员#shell与awk参数传递：https://blog.csdn.net/imzoer/article/details/8738581[root@sanchuang-linux ~]# cat group_member2.sh#!/bin/bashgroup_name=$1group_msg=`awk -F: -v group_awk=$group_name &#x27;$1==group_awk&#123;print $3,$4&#125;&#x27; /etc/group`group_lst=($group_msg) # 注：awk -v 选项 定义参数，把变量传递给awkgroup_id=$&#123;group_lst[0]&#125; # 注：()括起来 把字符变成一个数组，默认以空格分割，获取1,2元素group_user_1=$&#123;group_lst[1]&#125;group_user_2=`awk -F: -v group_id=$group_id &#x27;$4==group_id&#123;print $1&#125;&#x27; /etc/passwd| tr &quot;\\n&quot; &quot;,&quot;`echo $group_user_2$group_user_1 # 注：把换行符换成逗号[root@sanchuang-linux ~]# sh group_member2.sh sanchuang5sanchuang13,sanchuang10,sanchuang12--------------------------------------------------------------------------------------------命令行[root@sanchuang-linux ~]# less /etc/groupsanchuang5:x:1200:sanchuang10,sanchuang12[root@sanchuang-linux ~]# awk -F: &#x27;$1==&quot;sanchuang5&quot;&#123;print $3&#125;&#x27; /etc/group1200 # 注：加引号，表示一个字符串[root@sanchuang-linux ~]# awk -F: &#x27;$1==&quot;sanchuang5&quot;&#123;print $3,$4&#125;&#x27; /etc/group1200 sanchuang10,sanchuang12 # 注：组id 附属组的成员[root@sanchuang-linux ~]# awk -F: &#x27;$4==1200&#123;print $1&#125;&#x27; /etc/passwdsanchuang13 # 注：获取的是 为主要组时 成员的用户名（默认换行分割）group_user_2=`awk -F: -v group_id=$group_id &#x27;$4==group_id&#123;print $1&#125;&#x27; /etc/passwd| tr &quot;\\n&quot; &quot;,&quot;`#注：把换行符换成逗号--------------------------------------------------------------------------------------------字符串截取 # 注：不准确，gid可能5位[root@sanchuang-linux ~]# result=`awk -F: &#x27;$1==&quot;sanchuang5&quot;&#123;print $3,$4&#125;&#x27; /etc/group`[root@sanchuang-linux ~]# echo $&#123;result:0:4&#125;1200[root@sanchuang-linux ~]# echo $&#123;result#* &#125;sanchuang10,sanchuang12[root@sanchuang-linux ~]# echo $&#123;result:5&#125;sanchuang10,sanchuang12[root@sanchuang-linux ~]# echo $&#123;result%% *&#125;1200---------------------------字符串截取：#字符串操作line=`head -n1 /etc/passwd`echo &quot;字符串为：$line&quot;echo &#x27;字符串为：$line&#x27;echo &quot;截取前4个字符:&quot;echo $&#123;line:0:4&#125;echo &quot;截取后9个字符:&quot;echo $&#123;line:0-9&#125;echo &quot;从倒数第九个字符开始截取4个字符&quot;echo $&#123;line:0-9:4&#125;echo &quot;从左向右截取最后一个:后的字符&quot;echo $&#123;line##*:&#125;echo &quot;从左向右截取第一个:后的字符&quot;echo $&#123;line#*:&#125;echo &quot;从右向左截取最后一个:后的字符&quot;echo $&#123;line%%:*&#125;echo &quot;从右向左截取第一个:后的字符&quot;echo $&#123;line%:*&#125;echo &quot;字符串长度&quot;echo $&#123;#line&#125;--------------------------------------------------------------------------------------------for循环获取[root@sanchuang-linux lianxi]# vim user.shresult=`awk -F: &#x27;$1==&quot;sanchuang5&quot;&#123;print $3,$4&#125;&#x27; /etc/group`for i in $resultdo echo $idone[root@sanchuang-linux lianxi]# bash user.sh 1200sanchuang10,sanchuang12[root@sanchuang-linux ~]# result=`awk -F: &#x27;$1==&quot;sanchuang5&quot;&#123;print $3,$4&#125;&#x27; /etc/group`------------------------------------------------------------[root@sanchuang-linux ~]# for i in $result; do echo $i; done1200sanchuang10,sanchuang12 三. group操作 3.1 groupadd groupdel groupadd命令 格式：groupadd [-g GID] 组帐号名 groupdel命令 格式：groupdel 组帐号名 1234567示例：groupadd groupdel--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# groupadd -g 5000 sanle # 注：创建gid为5000的sanle组[root@sanchuang-linux ~]# less /etc/group #↑注：添加组账号sanlesanle:x:5000:[root@sanchuang-linux ~]# groupdel sanle # 注：删除组账号sanle[root@sanchuang-linux ~]# less /etc/group # 注：没有了 3.2 groupmod newgrp groupmod命令 用途：设置组名和组id 格式：groupmod [选项]... 组帐号名 常用命令选项 -n：修改组名 -g：修改组id newgrp改变有效组 用户必须是要改变组的成员 有效组：（用的很少） 新建文件或者文件夹的时候，使用的gid gid使用哪个组，哪个就是有效组 当前用户新建文件或者文件夹的时候，默认使用的gid对应的组 就是有效组 12345678910111213141516171819202122示例：newgrp改变有效组--------------------------------------------------------------------------------------------[root@sanchuang-linux lianxi]# ll # 注：ll查看目录详细信息-rw-r--r--. 1 root root 86 9月 25 14:23 abcd.txt-rw-r--r--. 1 root root 158 9月 25 09:47 backup_log.sh#注：第一个root是文件的 属主#注：第二个root是文件的 属组---------------------------------------------------[root@sanchuang-linux lianxi]# newgrp sanchuang4[root@sanchuang-linux lianxi]# touch aa[root@sanchuang-linux lianxi]# ll-rw-r--r-- 1 root sanchuang4 0 11月 6 11:25 bb # 注：属组发生改变---------------------------------------------------[root@sanchuang-linux lianxi]# su - sanchuang10[root@sanchuang-linux lianxi]# touch cc[sanchuang10@sanchuang-linux ~]$ ll总用量 0-rw-r--r-- 1 sanchuang10 sanchuang4 0 11月 6 11:27 cc[sanchuang10@sanchuang-linux ~]$ newgrp sanchuang # 注：普通用户想切换有效组，有效组里面必须有这个普通用户密码：newgrp: failed to crypt password with previous salt: 无效的参数#注：普通用户想切换有效组，有效组里面必须有这个普通用户 3.3 Linux组帐号 Linux组帐号 主要组(私有组) 与用户相关的默认组，在/etc/passwd文件的第四个字段定义 次要组(附属组) 用户可以同时属于其他的组，在/etc/group文件的第四个字段定义 用户的主要组的名称和GID相关 四. gpasswd命令 gpasswd命令 用途：设置组帐号密码（极少用）、添加/删除组成员 格式：gpasswd [选项]... 组帐号名 123456789101112示例：删除组成员root--------------------------------------------------------------------------------------------[root@localhost ~]# gpasswd -d root market正在将用户“root”从“market”组中删除示例：设置组账号密码--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# gpasswd sanchuang正在修改 sanchuang 组的密码新密码：请重新输入新密码：[root@sanchuang-linux ~]# 五. linux加密 Linux加密 默认采用sha512算法 采用哈希算法–》散列值求取 ​ 把任意长度的输入，映射成固定长度的输出，该输出就是散列值 ​ 是一种单向加密技术 hash算法：md5 sha1 sha2 sha256 sha512 如何判定密码正确？ # 注：把输入的密码用同样的方式进行加密，再判定输入的密文和文件里的密文是否一致 123456789101112131415161718192021222324252627282930313233343536373839404142示例：md5sum--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# echo &quot;123456&quot;|md5sum # 注：md5sum也是一种哈希算法f447b20a7fcbf53a5d5be013ea0b15af - # 注：无论给的是 都会返回特点长度的输出[root@sanchuang-linux ~]# echo &quot;123456xyzzzzz&quot;|md5sum # 注：单向加密的算法bcdd6694d1ece311bd7bd668da54b9b9 -[root@sanchuang-linux ~]# echo &quot;xxxxxxxxxxxxxxxxxxxxxxxx&quot;|md5sum7373d8394616d74ba2c42402266ae3aa -[root@sanchuang-linux tmp]# md5sum douban # 注：对文件进行加密816ba8dd29e68f3450d8748096227d42 douban # 注：对任意文件的输入，都会有对应长度的输出[root@sanchuang-linux tmp]# md5sum sucai89a44802fc09e1b84dc94740c40aa6450 sucai8示例：撞库 加盐--------------------------------------------------------------------------------------------#注：撞库[root@sanchuang-linux ~]# echo &quot;123456&quot;|md5sum # 注：加密字符串相同，输出的散列值相同f447b20a7fcbf53a5d5be013ea0b15af -[root@sanchuang-linux ~]# echo &quot;123456&quot;|md5sumf447b20a7fcbf53a5d5be013ea0b15af -#注：加盐 # 注：提高密码安全性[root@sanchuang-linux ~]# echo &quot;123456xndfoaei242&quot;|md5sum # 注：xndfoaei242 盐值15465f7aa2929cca95ed7efb97ffeba0 -示例--------------------------------------------------------------------------------------------root:$6$i4J5vzOUIMpchLRj$nTCbYWgA5cpv34Set6R2ZmC1AYYHGHnQafNbA9fkFsTR0E9GG1BJP5o3OTMuC4kGUqsomCI/G8FdEVELI/aeq0::0:99999:7:::密码字段：$加密算法id$盐值$真正的密文加密底层使用内核的crypt函数实现python实现（sha512）&gt;&gt;&gt; import crypt&gt;&gt;&gt; crypt.crypt(&#x27;123456&#x27;,&#x27;$6$i4J5vzOUIMpchLRj&#x27;) # 注：$加密算法id$盐值，密文和上面相同&#x27;$6$i4J5vzOUIMpchLRj$nTCbYWgA5cpv34Set6R2ZmC1AYYHGHnQafNbA9fkFsTR0E9GG1BJP5o3OTMuC4kGUqsomCI/G8FdEVELI/aeq0&#x27; # 注：与上面的密文一样-----------------------------------------$6 代表sha512算法$i4J5vzOUIMpchLRj 盐值$nTCbYWgA5cpv……aeq0 真正的密文哈希算法用途：用来判定文件md5值是否改变 六. /etc/login.defs文件 /etc/login.defs文件 对账户初始的属性设置 设置普通用户的UID和GID范围等 12345678示例[root@sanchuang-linux ~]# vim /etc/login.defs MAIL_DIR /var/spool/mail # 注：设置默认地址PASS_MAX_DAYS 99999 # 注：密码的过期天数PASS_MIN_DAYS 0PASS_MIN_LEN 5PASS_WARN_AGE 7UID_MIN 1000 七. useradd命令在后台到底做了哪些工作? useradd命令在后台到底做了哪些工作? 八. /etc/skel/*文件 */etc/skel/文件 新建用户帐号时，复制到用户宿主目录中 主要控制用户初始配置文件 bash_profile： 用户每次登录时执行 bashrc： 每次进入新的Bash环境时执行 bash_logout： 用户每次退出登录时执行 bash_history ： 记录存放上次注销前使用的历史命令 登陆的时候： .bash_profile ~/.bash_profile --&gt; ~/.bashrc --&gt; /etc/bashrc 进入新bash环境： ~/.bashrc --&gt; /etc/bashrc -------------------------------------------------------------------------------------------- #注：登录的时候都会执行 .bash_profile #注：登录的时候都会执行 .bashrc # 注：.bash_profile里面调用了.bashrc #注：登录的时候 先执行.bash_profile，.bash_profile里面调用了.bashrc #注：进入了一个新的bash环境，执行.bashrc #注：到新bash环境下，执行了.bashrc，不执行.bash_profile。登录时执行.bash_profile 用户环境设置 #注：/etc/bashrc 系统用户的环境设置，别名设置，其他的函数 /etc/bashrc 相当于全局配置，此文件只能root用户修改 # 注：/etc/bashrc 只有root用户才能修改 ~/.bashrc 个人配置，个性化配置，自己家目录下有权限修改 # 注：家目录下的.bashrc文件 /etc/profile 系统全局用户环境配置 ~/.bash_profile 个人配置 原因： 全局配置，影响所有用户。 家目录下配置，影响当前用户。 /etc/目录下的环境配置修改，属于全局配置，家目录下属于个人用户配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647示例：家目录下配置--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# less .bash_profile # .bash_profileif [ -f /etc/bashrc ]; then # 注：判断有没有 /etc/bashrc，有就在当前执行/etc/bashrc . /etc/bashrc # 注：/etc/bashrc 执行初始化的用户环境设置fi # 注：用. 去执行，. 代表当前bashPATH=$PATH:$HOME/binexport PATH[root@localhost ~]# less .bashrc # .bashrcalias rm=&#x27;rm -i&#x27;alias cp=&#x27;cp -i&#x27;alias mv=&#x27;mv -i&#x27;if [ -f /etc/bashrc ]; then . /etc/bashrc # 注：最终执行的是这个文件fi[root@sanchuang-linux ~]# which ls # 注：ls执行的是/usr/bin/ls，通过PATH环境变量从前往后找alias ls=&#x27;ls --color=auto&#x27; /usr/bin/ls============================================================================================示例：/etc/skel/*文件#注：新建用户帐号时，复制到用户宿主目录中[root@sanchuang-linux ~]# cd /etc/skel/[root@sanchuang-linux skel]# ls -al总用量 24drwxr-xr-x. 2 root root 62 9月 16 13:23 .drwxr-xr-x. 90 root root 8192 11月 6 15:15 ..-rw-r--r--. 1 root root 18 11月 9 2019 .bash_logout-rw-r--r--. 1 root root 141 11月 9 2019 .bash_profile-rw-r--r--. 1 root root 312 11月 9 2019 .bashrc============================================================================================示例：.bash_history 记录存放上次注销前使用的历史命令.bash_history 存放当前用户的命令历史，第一次登录用户，操作命令的时候，不会生成此文件第一次登陆退出后会自动将内存里的历史记录写到.bash_history文件里[root@sanchuang-linux ~]# history #注：history只是查看当前用户的命令历史#注：用户退出时，命令历史才会写入.bash_history#注：新建用户时，不会生成.bash_history文件，只有退出后 再次登录 才会生成.bash_history文件#注：不是所有的命令都写入history，不是很准确[root@sanchuang-linux ~]# cat .bash_history # 注：在当前用户的家目录下查看.bash_history文件 九. 每次登录或退出sanchuang的时候，打印日志到/tmp/sanchuang_log 每次登录或退出sanchuang的时候，打印日志到/tmp/sanchuang_log 123456789步骤1.在sanchuang用户下，修改.bash_profile文件，添加 # 注：因为每次登陆都会先执行这个文件now_date=`date`echo $now_date&quot;login...&quot; &gt;&gt; /tmp/sanchuang_log2.在sanchuang用户下，修改.bash_logout文件，添加 # 注：因为每次退出时都会执行这个文件now_date=`date`echo $now_date&quot;logout...&quot; &gt;&gt; /tmp/sanchuang_log3.监控文件变化，新增末尾行 # 注：经常用 tail -f 监控文件$ tail -f /tmp/sanchuang_log # 注：tail -f监控文件末尾的变化（新增的末尾行） 123456789101112131415示例--------------------------------------------------------------------------------------------[root@sanchuang-linux log]# su - sanchuang # 注：普通用户 在自己的家目录下操作上一次登录：五 11月 6 14:59:23 CST 2020pts/1 上[sanchuang@sanchuang-linux ~]$ vim ~/.bash_profile # 注：家目录下的.bash_profile操作now_date=`date`echo $now_date&quot;login...&quot; &gt;&gt; /tmp/sanchuang_log[sanchuang@sanchuang-linux ~]$ tail -f /tmp/sanchuang_log # 注：tail -f监控文件末尾的变化2020年 11月 06日 星期五 15:05:26 CSTlogin...[sanchuang@sanchuang-linux ~]$ vim ~/.bash_logout now_date=`date`echo $now_date&quot;logout...&quot; &gt;&gt; /tmp/sanchuang_log[sanchuang@sanchuang-linux ~]$ tail -f /tmp/sanchuang_log # 注：tail -f监控文件末尾的变化2020年 11月 06日 星期五 15:05:26 CSTlogin...2020年 11月 06日 星期五 15:07:33 CSTlogout... 十. Shell启动配置文件的区别 Shell启动配置文件的区别 /etc/profile： 配置全局环境变量，影响所有用户 ~/.bash_profile ： 配置个人环境，影响一个用户 /etc/bashrc ： 配置全局的别名或者shell选项，影响所有用户 **~/.bashrc **： 配置个人别名或者shell选项，影响一个用户 十一. .bash_history .bash_history 存放当前用户的命令历史，第一次登录用户，操作命令的时候，不会生成此文件 第一次登陆退出后会自动将内存里的历史记录写到.bash_history文件里 十二. bash的启动脚本初始化 bash的启动脚本初始化 十三. 用户和组账户查询 用户和组账户查询 id命令 用途：查询用户身份标识 格式：id [用户名] who、w、users命令 用途：查询已登录到主机的用户信息 groups命令 用途:查询用户所属的组 # 注：返回用户所属的 基本组和附加组 last、lastlog命令使用 1234567891011121314151617181920212223242526272829303132333435363738示例：w who--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# w # 注：看的是你以哪个用户登录进来，而不是当前你切换到的用户 15:26:24 up 6:11, 6 users, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot tty1 - 四15 58:07 0.07s 0.07s -bash # 注：tty真实终端root pts/0 192.168.0.42 14:28 0.00s 0.18s 0.01s w # 注：远程登录pts虚拟终端root pts/1 192.168.0.42 14:28 12:24 0.07s 0.01s -bash#注：真实终端FORM为空#注：虚拟终端显示的是物理机的ip地址#注：WHAT当前环境做的事情#注：15:26:24 当前时间#注：6:11 开机总时间#注：6 users 登录用户数量#注：load average cpu平均负载，数值越大，机器越繁忙--------------------------------------------------------------[root@sanchuang-linux ~]# who # 注：看的没有w详细root tty1 2020-11-05 15:13root pts/0 2020-11-06 14:28 (192.168.0.42)root pts/1 2020-11-06 14:28 (192.168.0.42)------------------------------------------------------------------[root@sanchuang-linux ~]# users # 注：查看当前有哪些用户登录root root root root root root---------------------------------------------------------------------------------[root@sanchuang-linux ~]# groups sanchuang10 # 注：显示用户所属的基本组和附加组sanchuang10 : sanchuang4 sanchuang5[root@sanchuang-linux ~]# id sanchuang10uid=1032(sanchuang10) gid=1100(sanchuang4) 组=1100(sanchuang4),1200(sanchuang5)--------------------------------------------------------------------------------[root@sanchuang-linux ~]# last # 注：查看之前有哪些用户登录过root tty1 Wed Sep 16 13:41 - 13:41 (00:00)root pts/0 192.168.136.1 Wed Sep 16 13:29 - 13:40 (00:11)reboot system boot 4.18.0-193.el8.x Wed Sep 16 13:26 - 13:42 (00:15)[root@sanchuang-linux ~]# lastlog # 注：查看每一个用户的最近登录状态用户名 端口 来自 最后登陆时间root pts/0 五 11月 6 15:18:46 +0800 2020bin **从未登录过**shutdown **从未登录过** 十四. 终端设备名称 终端设备名称 ​ 名称 设备 ​ ttyn 虚拟控制台 ​ pts/n 伪终端 ​ :0 X服务器","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"用户与组","slug":"用户与组","permalink":"https://blog1.cpen.top/tags/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84/"}]},{"title":"14_Linux基础-用户与组1","slug":"Linux_基础/14_Linux基础-用户与组1","date":"2022-09-11T04:00:00.000Z","updated":"2022-09-11T05:00:00.000Z","comments":true,"path":"posts/10588.html","permalink":"https://blog1.cpen.top/posts/10588.html","excerpt":"","text":"一. 练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120示例1---------------------------------------------------------------------------------------------------------------------------------menu()&#123; echo &quot;1、监控内存使用情况,如果内存使用率大于百分之80，给予提醒&quot; echo &quot;2、扫描局域网ip,检查哪些ip地址正在使用&quot; echo &quot;3、监控文件/etc/passwd是否被修改，每隔5分钟监控一次&quot; echo &quot;4、监控nginx进程是否存在，不存在就给予相应提醒&quot;&#125;option_1()&#123; total=`free -m|grep -i mem|tr -s &quot; &quot;|cut -d &quot; &quot; -f2` #free=`free -m|grep -i mem|tr -s &quot; &quot;|cut -d &quot; &quot; -f4` used=`free -m|grep -i mem|tr -s &quot; &quot;|cut -d &quot; &quot; -f3` used_rate=`echo &quot;scale=4;$used/$total&quot; |bc` #used_1=`echo &quot;$total*0.8&quot;|bc ` result=` echo &quot;$used_rate&gt;0.8&quot;|bc ` #echo $result if (( $result == 1 )) then echo -e &quot;\\e[31m使用率超过80%，请及时对内存扩容，以免不必要的损失\\e[0m&quot; else echo &quot; nothing to do&quot; fi&#125;option_2()&#123; for ip in `seq 255` do ( ip_full=192.168.0.$ip ping -c 1 $ip_full &amp;&gt;/dev/null &amp;&amp; echo $ip_full &gt;&gt;up.txt || echo $ip_full &gt;&gt;down.txt ) &amp; # 注：放到后台子进程执行 donewait # 父进程等待子进程执行完成之后再退出&#125;option_3()&#123; check_num=`diff /etc/passwd /lianxi/passwd |wc -l` [[ check_num -eq 0 ]] &amp;&amp; echo &quot;文件未被修改&quot; || echo &quot;文件已被修改&quot;&#125;option_4()&#123; pidof nginx &amp;&amp; echo &quot;nginx is running&quot; || echo &quot;nginx is down&quot;&#125;menuread -p &quot;请输入你的选择:&quot; optioncase $option in1) option_1 ;;2) option_2 ;;3) option_3 ;;4) option_4 ;;*) echo &quot;请输入1-4&quot;esac示例2：重复选择--------------------------------------------------------------------------------------------重复选择while : dodoneecho &quot;#########################&quot;echo &quot;1.查看内存使用率&quot;echo &quot;2.扫描局域网ip&quot;echo &quot;3.查看文件是否被修改&quot;echo &quot;4.查看nginx进程&quot;echo &quot;5.退出&quot;echo &quot;#########################&quot;while : do read -p &quot;请输入你的选择:&quot; options case $options in 1) /root/shell/mem.sh ;; 2) /root/shell/scan_ip.sh ;; 3) /root/shell/passwd_test.sh ;; 4) /root/shell/ngnix_test.sh ;; 5) echo &quot;退出&quot; exit ;; *) echo &quot;1-4&quot; esacdone--------------------------------------------------------------------------------------------示例3：使用awk获取case $options in1) memory_monitor()&#123; total=`free -m |grep Mem |awk &#x27;&#123;print $2&#125;&#x27;` used=`free -m |grep Mem |awk &#x27;&#123;print $3&#125;&#x27;` use_rate=`echo &quot;scale=2;$used/$total&quot; |bc` result=`echo &quot;$use_rate&gt;0.8&quot; |bc` if(( $result == 1 )) then echo &quot;内存使用率大于80%！！！&quot; else echo &quot;内存使用状态良好！&quot; fi &#125; memory_monitor ;; 二. user group 用户与组 2.1 常见命令 id 查看 useradd 创建 userdel 删除 passwd 创建用户密码 su 切换用户 usermod 更改用户信息 2.2 为什么要引入这个用户和组？ 1、安全性 2、权限管理 3、资源管控 对文件的访问，读写可以管控 对进程的管理 --&gt; 谁可以管理 2.3 用户和组 每个用户有一个唯一的UID 每个组也有一个唯一的GID 一个用户可以属于不同组 一个组可以有不同用户 # 注：多对多的关系 用户和组 --&gt; 权限资源管控 用户加入组，就可以有这个组的权限 默认情况下，创建用户，会添加一个和用户同名的组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071[root@sanchuang-linux ~]# id chenpeng # 注：id查看用户和组信息uid=1030(chenpeng) gid=1030(chenpeng) 组=1030(chenpeng) --------------------------------------------------------------------------------------------[root@localhost ~]# useradd sanchuang[root@localhost ~]# id sanchuanguid=1000(sanchuang) gid=1000(sanchuang) 组=1000(sanchuang)[root@localhost ~]# less /etc/passwd[root@localhost ~]# less /home/sanchuang/[root@localhost ~]# passwd sanchuang更改用户 sanchuang 的密码 。新的 密码：无效的密码： 密码少于 8 个字符重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[sanchuang@localhost ~]$ # 注：登录后默认位置为用户家目录（使用用户sanchuang登录）[root@localhost ~]# less /etc/shadow # 注：shadow存放的是用户的密码信息[root@localhost ~]# less /etc/shadowshadow shadow- [root@localhost ~]# less /etc/passwdpasswd passwd- [root@localhost ~]# diff /etc/passwd /etc/passwd- # 注：passwd-备份文件，每次都会少一个最新的操作21d20 # 注：可以回滚上一个版本&lt; sanchuang:x:1000:1000::/home/sanchuang:/bin/bash[root@localhost ~]# diff /etc/shadow /etc/shadow- # 注：shadowd-备份文件，每次都会少一个最新的操作21d20 # 注：可以回滚上一个版本&lt; sanchuang:$6$dKQsah/D$6sm6owwvDEnVs8BclDWQZ7meYSaMf5Y7AofxzxwxO0PPrvzqHHVCer1G656iY2gE.sUOarUl9beKi2usYdATQ1:18571:0:99999:7:::[root@localhost ~]# less /etc/group # 注：存放组信息[root@localhost ~]# less /etc/gshadow # 注：存放组密码信息[root@localhost ~]# cd /home/sanchuang/ # 注：新建用户，有三个隐藏文件[root@localhost sanchuang]# ls[root@localhost sanchuang]# ls -al # 注：新建用户帐号时，从 /etc/skel 目录中复制而来总用量 12drwx------. 2 sanchuang sanchuang 62 11月 5 10:25 .drwxr-xr-x. 3 root root 23 11月 5 10:25 ..-rw-r--r--. 1 sanchuang sanchuang 18 4月 1 2020 .bash_logout-rw-r--r--. 1 sanchuang sanchuang 193 4月 1 2020 .bash_profile-rw-r--r--. 1 sanchuang sanchuang 231 4月 1 2020 .bashrc[root@localhost sanchuang]# cd /etc/skel/ # 注：模板，拷贝一份过去[root@localhost skel]# ls -al总用量 24drwxr-xr-x. 2 root root 62 10月 6 16:33 .drwxr-xr-x. 77 root root 8192 11月 5 10:27 ..-rw-r--r--. 1 root root 18 4月 1 2020 .bash_logout-rw-r--r--. 1 root root 193 4月 1 2020 .bash_profile-rw-r--r--. 1 root root 231 4月 1 2020 .bashrc[root@localhost skel]# less /etc/login.defs # 注：关于账户的设置信息# Min/max values for automatic uid selection in useradd#UID_MIN 1000 # 注：最多可以创建59000个用户UID_MAX 60000# System accountsSYS_UID_MIN 201SYS_UID_MAX 999CREATE_HOME yes # 注：创建家目录ENCRYPT_METHOD SHA512 # 注：指定用什么方式加密用户密码[root@localhost skel]# ls /etc/group # 注：组也有备份文件group group- [root@localhost skel]# ls /etc/gshadowgshadow gshadow- [root@localhost spool]# cd /var/spool/mail/ # 注：邮件目录[root@localhost mail]# ls # 注：/var/spool/mail/ 下创建一个同名的文件sanchuang[sanchuang@localhost ~]$ less /etc/shadow # 注：普通用户没有权限查看 /etc/shadow存放密码信息/etc/shadow: 权限不够 # 注：只有root用户可读 2.4 用户创建牵扯到哪些文件 账户信息相关文件 /etc/passwd --&gt; 存放用户相关信息的 /etc/shadow --&gt; 存放用户密码 /etc/passwd- 和 /etc/shadow- 这是/etc/passwd 和 /etc/shadow的备份文件，总是比原文件少一次操作 组相关文件 /etc/group --&gt; 存放组信息的 /etc/gshadow --&gt; 存放组密码的 /etc/group- 和 /etc/gshadow- 备份文件 用户环境默认设置 创建用户时，会拷贝/etc/skel/下的文件到用户的家目录 用户的家目录 默认情况下会在/home目录下创建一个同名文件夹 用户默认属性设置文件 /etc/login.defs 邮件目录 /var/spool/mail/ 下创建一个同名的文件 2.5 /etc/passwd 文件详解 123456789101112[root@localhost mail]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologinsanchuang:x:1000:1000::/home/sanchuang:/bin/bash·使用：分隔·字段1：用户名·字段2：密码占位符，通常为“x”或者“*”（因为这个文件谁都可读，所以真正的密码存放在/etc/shadow）·字段3：用户id # 注：-u指定·字段4：用户所属基本组id # 注：-g指定基本组·字段5：用户描述信息 # 注：新建用户没有 没有设置一般没有 （-c选项）·字段6：家目录 # 注：家目录的绝对路径 （-d选项）·字段7：登录shell的信息 12345678示例--------------------------------------------------------------------------------------------[root@localhost ~]# ls -ld /etc/shadow----------. 1 root root 2330 11月 5 20:51 /etc/shadow # 注：普通用户/组 无法读取执行[root@localhost ~]# ls -ld /etc/passwd-rw-r--r--. 1 root root 2006 11月 5 20:51 /etc/passwd#注：通过yum安装的 配置文件一般放在/etc 下 2.6 练习：找出系统中uid大于1000的用户，显示出它的名字，UID，家目录，shell 找出系统中uid大于1000的用户，显示出它的名字，UID，家目录，shell 12345[root@sanchuang-linux ~]# awk -F: &#x27;$3&gt;1000&#123;print $1,$3,$6,$7&#125;&#x27; /etc/passwdchenpeng 1030 /home/chenpeng /bin/bash#注：使用cat和直接使用awk消耗内存差不多#注：语法：awk 选项 ‘模式+动作’ 文件 # 注：不接模式的话 全文截取 2.7 练习：找出/etc/passwd中有几种shell信息 找出/etc/passwd中有几种shell信息 2.8 useradd详解 1234567Shell设置[root@sanchuang-linux ~]# awk -F: &#x27;&#123;print $7&#125;&#x27; /etc/passwd |sort|uniq # 注：排序去重/bin/bash # 注：系统默认用户的shell环境信息 --&gt; 正常使用的shell/bin/sync # 注：将内存里的缓存刷新到磁盘 --&gt; 类似于Python中fp.flush()/sbin/halt # 注：登陆就关机/sbin/nologin # 注：用户不能登录（不允许登录）/sbin/shutdown # 注：登陆就关机 123456789--------------------------------------------------------------------------------------------#注：关机至强最会执行以下sync,将内存里的缓存刷新到磁盘[root@localhost ~]# sync--------------------------------------------------------------------------------------------#注：使用which命令查看命令的绝对路径[root@localhost ~]# which sync/usr/bin/sync敲sync会按照PATH变量的路径下向下找下去执行一个/bin/bash 就会到我们现在的终端环境了 三. 用户和组的关系 每个账户有一个唯一的UID 每个组也有一个唯一的GID 多个账户可以属于同一个组 四. 用户和组的相关文件 和账户相关文件 /etc/passwd、/etc/shadow 和组相关文件 /etc/group、/etc/gshadow 账户宿主目录中文件来源 新建用户帐号时，从 /etc/skel 目录中复制而来 # 注：初始化用户家目录 默认账户的属性文件 /etc/login.defs 用于保存用户的帐号基本信息 文件位置：/etc/passwd 每一行对应一个用户的帐号记录 字段1：用户帐号的名称 字段2：用户密码字串或者密码占位符“x” 字段3：用户帐号的UID号 字段4：所属基本组帐号的GID号 字段5：用户描述信息 字段6：家目录 字段7：登录Shell信息 五. 用户和组的相关文件 用户账户： 超级用户root 程序用户 普通用户 UID （User Identity，用户标识号） 超级用户root的UID为0 程序用户的UID1-999 普通用户的UID大于等于1000 六. 添加与删除用户 useradd命令 格式：useradd [选项]... 用户名 常用命令选项 -u：指定 UID 标记号 -d：指定宿主目录，缺省为 /home/用户名 -e：指定帐号失效时间 -g：指定用户的基本组名（或GID号） -G：指定用户的附加组名（或GID号） -M：不为用户建立并初始化宿主目录 -s：指定用户的登录Shell -c：用户注释描述信息 -r: 新建系统用户，不会有新建家目录 #注：每次新建用户，uid都会在上一个用户uid基础上+1 #注：默认新建用户从1001开始 Shell设置 12345/bin/bash # 注：系统默认用户的shell环境信息 --&gt; 正常使用的shell/bin/sync # 注：将内存里的缓存刷新到磁盘 --&gt; 类似于Python中fp.flush()/sbin/halt # 注：登陆就关机/sbin/nologin # 注：用户不能登录，ssh和su都不能登陆/sbin/shutdown # 注：登陆就关机 123456789101112131415161718192021示例：-s /sbin/nologin--------------------------------------------------------------------------------------------#注：本机用来跑服务的，不能登录[root@localhost mail]# useradd -s /sbin/nologin sanchuang2[root@localhost mail]# echo 123456|passwd sanchuang2 --stdin更改用户 sanchuang2 的密码 。passwd：所有的身份验证令牌已经成功更新。[root@localhost mail]# ssh sanchuang2@192.168.136.136 #注：ssh 登录本机sanchuang2……………………………………Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &#x27;192.168.136.136&#x27; (ECDSA) to the list of known hosts.sanchuang2@192.168.136.136&#x27;s password: This account is currently not available. # 注：提示用户不可达，因为sanchuang2的Shell是nologin，不能直接登录Connection to 192.168.136.136 closed.[root@localhost ~]# su - sanchuang2 # 注：不能切换上一次登录：四 11月 5 11:49:14 CST 2020从 192.168.136.136pts/2 上This account is currently not available.--------------------------------------------------------------------------------------------[root@localhost ~]# usermod -s /bin/bash sanchuang2 # 注：usermod -s 更改用户的shell信息[root@localhost ~]# cat /etc/passwd|grep sanchuang2sanchuang2:x:1001:1001::/home/sanchuang2:/bin/bash 练习：显示出系统中uid大于1000并且用户名包含sanchuang的用户信息（用户名，用户Id，用户家目录） 显示出系统中uid大于1000并且用户名包含sanchuang的用户信息（用户名，用户Id，用户家目录） 12345678[root@localhost ~]# awk -F: &#x27;$3&gt;1000&#123;print $1,$3,$6&#125;&#x27; /etc/passwdsanchuang2 1001 /home/sanchuang2方法1[root@localhost ~]# awk -F: &#x27;$3&gt;1000&#123;print $1,$3,$6&#125;&#x27; /etc/passwd |grep sanchuangsanchuang2 1001 /home/sanchuang2方法2[root@localhost ~]# awk -F: &#x27;$3&gt;1000 &amp;&amp; $1 ~ /sanchuang/&#123;print $1,$3,$6&#125;&#x27; /etc/passwdsanchuang2 1001 /home/sanchuang2 # 注：$1 ~ /sanchuang/ 匹配sanchuang 七. 进程 进程：正在运行中的程序 程序：代码集合，放在磁盘上的 进程是计算机进行资源分配的基本单位 进程的组成核心：进程控制块（PCB） PCB一般包括 1、pid 进程唯一标识符 2、有效用户信息 -euid,egid(通常情况下就是uid,gid) # 注：就是进程属于哪个用户 3、程序的状态 4、程序的优先级 5、程序的上下文 八. Python中使用os模块查看当前进程的用户信息 Python中使用os模块查看当前进程的用户信息 123456789101112131415&gt;&gt;&gt; import os&gt;&gt;&gt; os.geteuid() # 注：获取当前进程用户的用户uid信息0 # 注：为0的都是root用户 root用户的uid&gt;&gt;&gt; os.getuid() # 注：通常情况下，uid和euid都是一样的0--------------------------------------------------------------------------------------------普通用户导入 os模块[sanchuang2@localhost ~]$ python3&gt;&gt;&gt; import os&gt;&gt;&gt; os.geteuid()1001&gt;&gt;&gt; os.getuid()1001[sanchuang2@localhost ~]$ id sanchuang2uid=1001(sanchuang2) gid=1001(sanchuang2) 组=1001(sanchuang2) 九. ftp协议（文件传输协议） 9.1 vsftpd服务与本地用户 ftp的服务 做文件传输的，上传或下载一个文件到指定的地方 ftp是一个文件传输服务，主要用于上传和下载文件，实现文件共享 匿名用户和本地用户都可以登录ftp服务，它们登录进去之后只能操作家目录下的文件或者文件夹 三种用户： 1、匿名用户 2、本地用户 # 注：ftp传输可以使用linux本地用户；ssh登录也可以用本地用户 3、虚拟用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788============================================================================================1、服务安装[root@sanchuang-linux ~]# yum install vsftpd--------------------------------------------------------------------------------------------2、启动服务[root@sanchuang-linux ~]# service vsftpd restartRedirecting to /bin/systemctl restart vsftpd.service[root@sanchuang-linux ~]# ps -ef |grep vsftp # 注：默认root用户启动root 3377 1 0 14:51 ? 00:00:00 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.confroot 3379 3184 0 14:52 pts/1 00:00:00 grep --color=auto vsftp--------------------------------------------------------------------------------------------3、安装客户端#注：centos8里vsftpd服务默认不允许匿名用户登录 使用匿名用户（ftp）登录的话，修改/etc/vsftpd/vsftpd.conf里的配置 anonymous_enable=YES#注：修改完配置文件重启vsftpd服务登录上去之后，默认读取系统中ftp这个用户的家目录文件-----------------------------------------------------[root@sanchuang-linux ~]# yum install lftp -y # 注：lftp是vsftpd的客户端[root@sanchuang-linux ~]# yum install ftp -y # 注：ftp也是vsftpd的客户端#注：这两个都是ftp的客户端============================================================================================[root@sanchuang-linux ~]# lftp ftp@192.168.0.27 # 注：以ftp用户去登录程序密码: # 注：ftp是默认用户[root@localhost ~]# ftp 192.168.136.136 # 注：登录ftp服务………………………………Name (192.168.136.136:root): ftp # 注：匿名用户ftp登录331 Please specify the password.Password: # 注：回车230 Login successful.………………………………ftp&gt; ============================================================================================[root@sanchuang-linux ~]# cat /etc/passwdftp:x:14:50:FTP User:/var/ftp:/sbin/nologin # 注：vsftpd的匿名用户，公共用户#注：/var/ftp ftp这个用户的家目录文件============================================================================================[root@sanchuang-linux ~]# vim /etc/vsftpd/vsftpd.conf # 注：Centos8中开启匿名用户允许登录anonymous_enable=YES # 注：centos7不用设置#注：修改完配置文件重启vsftpd服务============================================================================================登录上去之后，默认读取系统中ftp这个用户的家目录文件/var/ftp-----------------------------------------------------[root@localhost ~]# cd /var/ftp/[root@localhost ftp]# lspub[root@localhost ftp]# cd pub[root@localhost pub]# ls # 注：/var/ftp/pub/下为空[root@localhost pub]# touch aa bb # 注：创建文件aa bb--------------------------------------------------------------------------------------------ftp&gt; ls # 注：当前路径 /var/ftp…………………………drwxr-xr-x 2 0 0 26 Nov 05 07:20 pubftp&gt; cd pub…………………………ftp&gt; ls # 注：显示出文件aa bb…………………………-rw-r--r-- 1 0 0 0 Nov 05 07:20 aa-rw-r--r-- 1 0 0 0 Nov 05 07:20 bb226 Directory send OK.--------------------------------------------------------------------------------------------ftp&gt; get aa # 注：下载文件local: aa remote: aa…………………………ftp&gt; !ls # 注：查看当前所在系统命令有哪些文件aa addstr.pyftp&gt; !pwd # 注：查看当前所在系统命令路径/root#注：匿名用户不能上传============================================================================================[root@localhost ~]# ftp 192.168.136.136Name (192.168.136.136:root): sanchuang # 注：本地用户sanchuang登录Password:230 Login successful. # 注：230 代表登录成功--------------------------------------------------------------------------------------------ftp&gt; put first.py # 注：上传文件local: first.py remote: first.py # 注：匿名用户不能上传…………………………1097 bytes sent in 0.0157 secs (69.83 Kbytes/sec)ftp&gt; ls…………………………-rw-r--r-- 1 1000 1000 1097 Nov 05 07:34 first.py226 Directory send OK.============================================================================================[root@localhost pub]# less /etc/services # 注：# less /etc/services 查看默认端口号ftp 21/tcp # 注：ftp服务默认是21号端口ftp 21/udp fsp fspd 9.2 匿名用户和本地用户都可以登录ftp服务，它们登录进去之后只能操作家目录下的文件或者文件夹 匿名用户和本地用户都可以登录ftp服务，它们登录进去之后只能操作家目录下的文件或者文件夹 三种用户： 1、匿名用户 # 注：匿名用户 ftp ; 无需密码 ; 家目录 /var/ftp ； ftp也是系统的本地用户，系统自动创建ftp用户，nologin，可以通过ftp登录 2、本地用户 # 注：就是linux系统上的用户 ; ftp登录之后在本地用户家目录下 3、虚拟用户 # 注：建立出一个虚拟的用户，映射到本地用户 #注：/etc/passwd 第6个字段 是用户的家目录 #注：看用户的家目录 看/etc/passwd文件 9.3 ftp常用命令 ftp常用命令 ftp常用命令： 上传文件：put # 注：匿名用户不能上传 下载文件：get 查看：ls 切换路径：cd 9.4* ftp的2种工作模式 ftp的2种工作模式（面试） 问的时候：总结（要提到端口号） 主动模式和被动模式都会开启21号端口进行连接 区别是数据连接的方式 主动模式：服务器主动开启20号端口去和客户机主动建立数据连接，传输数据 被动模式：客户机拿到随机开放端口后向服务器进行一个数据传输，客户端向这个随机端口去建立连接，进行数据传输 一、主动模式（默认情况下是主动模式） 1、客户端登录时请求ftp服务器 命令连接端口（21号端口） 2、21号端口返回信息登录成功或者登录失败 3、登录成功后客户端请求传输数据（对21号端口发起一个请求），开启一个随机端口 4、服务器主动开启它的20号端口去把它的数据传递给客户端的随机端口 服务器主动开启20号端口，向客户机主动发送数据 二、被动模式 1、客户端登录时请求ftp服务器 开启 命令连接端口（21号端口） #注：21号端口都是用来做命令连接的 2、21号端口返回信息登录成功或者登录失败 3、客户机请求数据传输（客户机向服务器请求数据传输时，向服务器发送一个pasv命令，告诉服务器端要以被动模式取接收命令。这时服务器端就开放一个端口，可以指定范围，返回给客户机，把这个端口号返回给客户端） 4、收到服务器开放端口号 5、开始连接服务器端口，进行数据传输（和5555号端口建立连接） 假设开放的是5555，服务器就会把5555端口起来，端口处于监听状态，别人就可以连接过来，就可以和这个主机建立连接，就可以通过5555号端口传递数据 #注：被动模式需要配置，默认主动模式 无论主动模式，还是被动模式，21号端口都必须起来 主动模式20号端口起来，被动模式20号端口不一定起来 #注：数据请求和命令请求不是同一个端口的 十. usermod userdel usermod usermod命令 格式：usermod [选项]... 用户名 常用命令选项 -l：更改用户帐号的登录名称 -L：锁定用户账户 -U：解锁用户账户 以下选项与useradd命令中的含义相同 ​ -u、-d、-e、-g、-G、-s userdel userdel命令 格式：userdel [-r] 用户名 添加 -r 选项时，表示连用户的宿主目录一并删除 # 注：建议接上 12345678示例--------------------------------------------------------------------------------------------[root@localhost ~]# useradd stu01 [root@localhost ~]# ls -ld /home/stu01/drwx------ 2 stu01 stu01 4096 09-09 12:38 /home/stu01/ [root@localhost ~]# userdel -r stu01 # 注：删除用户帐号stu01[root@localhost ~]# ls -ld /home/stu01/ ls: /home/stu01/: 没有那个文件或目录 十一. useradd useradd命令 格式：useradd [选项]... 用户名 常用命令选项 -u：指定 UID 标记号 -d：指定宿主目录，缺省为 /home/用户名 -e：指定帐号失效时间 -g：指定用户的基本组名（或GID号） # 注：基本组只能有一个 -G：指定用户的附加组名（或GID号） # 注：附加组可以用很多个 无论基本组/附加组 用户都可以获得所有权限 -M：不为用户建立并初始化宿主目录 -s：指定用户的登录Shell -c：用户注释描述信息 -r: 新建系统用户，不会有新建家目录 十二. 用户 12.1 用户账户： 超级用户root # 注：拥有最高权限 程序用户 # 注：程序运行过程中需要使用的用户 普通用户 # 注：手动创建的用户 UID （User Identity，用户标识号） 超级用户root的UID为0 程序用户的UID 1-999 普通用户的UID大于等于1000 1234567891011121314151617181920212223242526272829303132333435363738394041示例：mysql uid--------------------------------------------------------------------------------------------[root@localhost ~]# id mysqluid=1000(mysql) gid=1000(mysql) 组=1000(mysql)[root@localhost ~]# id sanchuang2uid=1001(sanchuang2) gid=1001(sanchuang2) 组=1001(sanchuang2)示例--------------------------------------------------------------------------------------------#注：默认情况不指定uid 在上一个用户前+1[root@localhost ~]# useradd -u 1100 chenpeng1 # 注：指定用户id[root@localhost ~]# id chenpeng1uid=1100(chenpeng1) gid=1100(chenpeng1) 组=1100(chenpeng1)[root@localhost ~]# useradd -u 1101 -g 1100 chenpeng2 # 注：指定用户id、基本组[root@localhost ~]# id chenpeng2 # 注：在chenpeng1这个组里面uid=1101(chenpeng2) gid=1100(chenpeng1) 组=1100(chenpeng1)示例--------------------------------------------------------------------------------------------[root@localhost ~]# usermod -u 1200 chenpeng2 # 注：修改用户id[root@localhost ~]# id chenpeng2uid=1200(chenpeng2) gid=1100(chenpeng1) 组=1100(chenpeng1)示例--------------------------------------------------------------------------------------------[root@localhost ~]# useradd -d /var/log/sanchuang6 sanchuang6 # 注：指定用户家目录[root@localhost ~]# cd /var/log/sanchuang6/[root@localhost sanchuang6]# ls[root@localhost sanchuang6]# less /etc/passwdsanchuang6:x:1201:1201::/var/log/sanchuang6:/bin/bash # 注：第6列 用户家目录示例：指定附加组--------------------------------------------------------------------------------------------[root@localhost sanchuang6]# useradd -g chenpeng1 -G sanchuang,sanchuang2 sanchuang7[root@localhost sanchuang6]# id sanchuang7uid=1202(sanchuang7) gid=1100(chenpeng1) 组=1100(chenpeng1),1000(sanchuang),1001(sanchuang2)#注：基本组chenpeng1 附属组 sanchuang sanchuang2#注：-g指定基本组 -G指定附加组============================================================================================·-c：用户注释描述信息/etc/passwd 第5列可以查看描述信息 12.2 userdel 删除用户 userdel命令 格式：userdel [-r] 用户名 添加 -r 选项时，表示连用户的宿主目录一并删除 12345678910111213141516示例1--------------------------------------------------------------------------------------------[root@localhost ~]# useradd stu01 [root@localhost ~]# ls -ld /home/stu01/drwx------ 2 stu01 stu01 4096 09-09 12:38 /home/stu01/ [root@localhost ~]# userdel -r stu01 # 注：删除用户帐号stu01[root@localhost ~]# ls -ld /home/stu01/ ls: /home/stu01/: 没有那个文件或目录示例2--------------------------------------------------------------------------------------------[root@localhost sanchuang6]# userdel sanchuang7[root@localhost sanchuang6]# less /etc/passwd # 注：删除了[root@localhost sanchuang6]# cd /home/sanchuang7 # 注：没删[root@localhost sanchuang7]# ls /var/spool/mail/sanchuang7 # 注：没删/var/spool/mail/sanchuang7 十三. usermod 用户修改 usermod命令 格式：usermod [选项]... 用户名 常用命令选项 -l：更改用户帐号的登录名称 -L：锁定用户账户 -U：解锁用户账户 以下选项与useradd命令中的含义相同 -u、-d、-e、-g、-G、-s 123456789101112131415161718192021示例：-L：锁定用户账户--------------------------------------------------------------------------------------------#注：锁上之后不能密码登录#注：本质就是在shadow密码前面加一个！号，使得登录的时候密码验证失败[root@localhost sanchuang7]# id sanchuang6uid=1201(sanchuang6) gid=1201(sanchuang6) 组=1201(sanchuang6)[root@localhost sanchuang7]# usermod -L sanchuang6 # 注：锁定用户账户[root@localhost sanchuang7]# less /etc/shadow # 注：密码密文前面加了1个感叹号chenpeng2:!$6$P3yFUy.H$UOfUIbl8V3h1ng4J/OdVV1aWc3Cx3s5bldkysl33aDyrigsgK0VQ3nzrC4mojDNotpE9w61NbVQmZFqDDRfpl.:18571:0:99999:7:::[root@localhost sanchuang7]# diff /etc/shadow /etc/shadow-25c25&lt; chenpeng2:!$6$P3yFUy.H$UOfUIbl8V3h1ng4J/OdVV1aWc3Cx3s5bldkysl33aDyrigsgK0VQ3nzrC4mojDNotpE9w61NbVQmZFqDDRfpl.:18571:0:99999:7:::---&gt; chenpeng2:$6$P3yFUy.H$UOfUIbl8V3h1ng4J/OdVV1aWc3Cx3s5bldkysl33aDyrigsgK0VQ3nzrC4mojDNotpE9w61NbVQmZFqDDRfpl.:18571:0:99999:7:::#注：sha512加密技术 密文 明文--------------------------------------------------------------------------------------------[root@localhost ~]# ssh chenpeng2@192.168.0.188chenpeng2@192.168.0.188&#x27;s password: # 注：锁上之后不能密码登录Permission denied, please try again.…………………………Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password). 十四. /etc/shadow 用于保存密码字串、密码有效期等信息 文件位置：/etc/shadow # 注：存放用户密码的文件，只能root用户查看 每一行对应一个用户的密码记录 字段1：用户帐号的名称 字段2：加密的密码字串信息 # 注：字段2就是存放密码的字段存放的密码是加密的 密文，sha512算法加密 字段3：上次修改密码的时间 字段4：密码的最短有效天数，默认值为0 字段5：密码的最长有效天数，默认值为99999 字段6：提前多少天警告用户口令将过期，默认值为7 字段7：在密码过期之后多少天禁用此用户 字段8：帐号失效时间，默认值为空 字段9：保留字段（未使用） 十五. passwd passwd命令 格式：passwd [选项]... 用户名 常用命令选项 -d：清空用户的密码，使之无需密码即可登录 -l：锁定用户帐号 -S：查看用户帐号的状态（是否被锁定） -u：解锁用户帐号 –stdin：接收别的命令stdout做为stdin标准输入设置密码 root用户可以修改所有用户密码，不要求复杂性 普通用户只能改自己的密码，要求复杂性 12345678910111213141516171819202122232425262728293031323334353637383940414243示例--------------------------------------------------------------------------------------------[root@localhost sanchuang7]# passwd -d sanchuang6 # 注：清空用户密码清除用户的密码 sanchuang6。passwd: 操作成功[root@localhost sanchuang7]# useradd sanchuang5 # 注：注册 未给密码[root@localhost mail]# less /etc/shadowsanchuang6::18571:0:99999:7::: # 注：清除用户密码，密码字段为空sanchuang5:!!:18571:0:99999:7::: # 注：未给密码 密码字段默认2个感叹号#usermod和passwd锁定账户都是修改账户的shadow加密字段信息，使他们登录的时候密码匹配不上，达到一个锁定状态#usermod -L 加一个!号 # 注：锁定用户在shadow密码字段前加一个！号#passwd -l 加两个!号 # 注：锁定用户在shadow密码字段前加两个！号#注：查看用户有没有设置密码 看/etc/shadow信息示例：usermod -L 和 passwd -l 锁定用户--------------------------------------------------------------------------------------------[root@localhost mail]# useradd chen001[root@localhost mail]# useradd chen002[root@localhost mail]# useradd chen003[root@localhost mail]# echo 123456|passwd chen001 --stdin[root@localhost mail]# echo 123456|passwd chen002 --stdin[root@localhost mail]# echo 123456|passwd chen003 --stdin[root@localhost mail]# usermod -L chen002 # 注：chen002做 usermod -L 操作[root@localhost mail]# passwd -d chen003 # 注：chen003做 passwd -d 操作清除用户的密码 chen003。passwd: 操作成功[root@localhost mail]# less /etc/shadowchen001:$6$y……k1q.yk8U1gOGp/:18571:0:99999:7:::chen002:!$6$u……YF0.:18571:0:99999:7:::chen003::18571:0:99999:7:::-------------------------------------------------------------------------[root@localhost ~]# ssh chen003@192.168.136.136 # 注：登录不上去chen003@192.168.136.136&#x27;s password: …………Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).[root@localhost ~]# ssh chen002@192.168.136.136 # 注：登录不上去chen002@192.168.136.136&#x27;s password: …………Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).[root@localhost ~]# ssh chen001@192.168.136.136 # 注：没做操作的 远程登录成功chen001@192.168.136.136&#x27;s password: [chen001@localhost ~]$ 十六. /etc/group /etc/group ​ 字段一：组名 ​ 字段二：密码字段 ​ 字段三：组id ​ 字段四：存放是当前组为附属组时，有哪些用户 1234示例--------------------------------------------------------------------------------------------[root@localhost ~]# less /etc/grouptech:x:200:b1,b2,a1,a2","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"用户与组","slug":"用户与组","permalink":"https://blog1.cpen.top/tags/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84/"}]},{"title":"13_Linux基础-SHELL命令-wc-diff-patch-bc-awk","slug":"Linux_基础/13_Linux基础-SHELL命令-wc-diff-patch-bc-awk","date":"2022-09-10T04:00:00.000Z","updated":"2022-09-10T05:00:00.000Z","comments":true,"path":"posts/9132.html","permalink":"https://blog1.cpen.top/posts/9132.html","excerpt":"","text":"一. 回顾 sort sort 123456格式：sort 选项 文件-n 按数值进行排序-r 降序排序-k 指定排序的列-t 指定分隔符-u 去重 uniq uniq 1234格式：uniq 选项 文件-c 统计每列在文本中出现的次数-u 仅显示出现一次的行-d 仅显示重复出现的行 cut cut 1234格式：cut 选项 提取范围 文件-d 指定分隔符-f 指定显示的特定字段-c 指定特定字符 文本三剑客 12345678grep 过滤 通用的正则表达式分析程序grep [选项]... 模式 目标文件-i 不区分大小写-v 反转查找，不显示包含指定字符的行-o 显示匹配的内容，并且换行显示-n 显示出过滤出来的行的行号-r 递归查找指定目录下所有的文件（包括其子目录）-E 支持更多的正则扩展表达式 正则表达式 12^aa 以aa开头的行Aa$ 以aa结尾的行 通配符 1234567* 表示匹配前一项任意次? 表示匹配前一次0次或1次+ 表示匹配前一项一次到多次. （占位符）表示除换行符之外的任意字符&#123;n,m&#125; 匹配n到m次&#123;,n&#125; 匹配0次到n次&#123;m,&#125; 匹配m次以上 1234[]集合表示[a-zA-Z][0-9][^a] 表示不取a 12345示例---------------------------------------------------------------------------------------------------------------------------------# grep -E &quot;a.*c&quot; grep_test.txt # 注：.* 匹配前一项 . 0次或任意次# grep -E &quot;a*c&quot; abc.txt --color=auto # 注：* 匹配前一项 a 0次或任意次# grep -E &quot;a+c&quot; abc.txt --color=auto # 注：+ 匹配前一项 a 1次或多次 二. wc wc（字数统计）命令 格式：wc [选项]... 目标文件... -l：统计行数 -w：统计字数 （前后都是空白的一组字符） -c：统计字符数（可见和不可见的字符） 注：wc文本操作命令，可以直接接文本，不需要用cat 1234567891011121314151617181920[root@sanchuang-linux ~]# cat wc_test.txt a b caa bb ccxyz1234aa-bb示例--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# wc -l wc_test.txt # 注：统计行数5 wc_test.txt[root@sanchuang-linux ~]# wc -w wc_test.txt # 注：统计字数9 wc_test.txt[root@sanchuang-linux ~]# wc -c wc_test.txt # 注：统计字符数30 wc_test.txt--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# cat wc_test.txt|wc -c # 写法2：cat30[root@sanchuang-linux ~]# wc -c &lt; wc_test.txt # 写法3：重定向30 三. diff diff命令 比较两个文件之间的差异 输出结果为两个文件的不同之处 diff命令的输出格式 标准diff -u：会将不同的地方放在一起，紧凑易读 -r： 递归比较目录下的所有文件 利用diff命令生成补丁 diff -u test1 test2 &gt; test.patch 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556[root@sanchuang-linux ~]# cat diff_1_test.txtaabbccxx[root@sanchuang-linux ~]# cat diff_2_test.txtaabbxx示例1--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# diff diff_1_test.txt diff_2_test.txt 3d2 # 注：3d2 文件1个第3行 需要删除 就会和 文件2相同&lt; cc # 注：文件1 中的cc============================================================================================[root@sanchuang-linux ~]# cat diff_1_test.txtaabbccxxgg[root@sanchuang-linux ~]# cat diff_2_test.txtaabbddxxee示例2--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# diff diff_1_test.txt diff_2_test.txt 3c3 # 注：第3行&lt; cc # 注：文件1 中的cc---&gt; dd # 注：文件2 中的dd5c5 # 注：第5行&lt; gg # 注：文件1 中的gg---&gt; ee # 注：文件2 中的ee--------------------------------------------------------------------------------------------============================================================================================示例3：-u：会将不同的地方放在一起，紧凑易读[root@sanchuang-linux ~]# diff -u diff_1_test.txt diff_2_test.txt --- diff_1_test.txt 2020-10-30 11:50:45.784010843 +0800+++ diff_2_test.txt 2020-10-30 11:51:11.475010836 +0800@@ -1,5 +1,5 @@ aa bb-cc # 注：理解为 左 - 右 ++dd # 注：或者理解为 左边 -cc +dd 就和右边相同 xx-gg+ee 四. patch patch命令： 用途：用来打补丁修补文件 格式：patch [选项] 原始文件 &lt; 补丁文件 -pN： N表示忽略N层路径 -R： 还原到老版本 注意事项 如果打多个补丁，注意先后顺序 打补丁前不要修改源文件 1234567891011121314151617181920212223242526272829303132333435363738394041示例--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# yum install patch[root@sanchuang-linux ~]# diff diff_1_test.txt diff_2_test.txt 3c3 # 注：差异内容&lt; cc---&gt; dd5c5&lt; gg---&gt; ee#注：差异文件又叫补丁文件#注：生成的是文件1的补丁文件[root@sanchuang-linux ~]# diff -u diff_1_test.txt diff_2_test.txt &gt; diff_test.patch # 注：1的补丁[root@sanchuang-linux ~]# cat diff_test.patch #注：补丁文件--- diff_1_test.txt 2020-10-30 11:50:45.784010843 +0800+++ diff_2_test.txt 2020-10-30 11:51:11.475010836 +0800@@ -1,5 +1,5 @@ aa bb-cc+dd xx-gg+ee[root@sanchuang-linux ~]# patch diff_1_test.txt &lt; diff_test.patch # 注：打补丁patching file diff_1_test.txt[root@sanchuang-linux ~]# cat diff_1_test.txt # 注：打补丁aabbddxxee[root@sanchuang-linux ~]# cat diff_2_test.txt # 注：文件1、2内容相同aabbddxxee 五. grep -A\\-B -A：找到匹配行以及后几行 -B：输出匹配行以及前几行 123示例[root@localhost ~]# grep -A 3 quit /etc/passwd # 注：找到匹配行以及后几行[root@localhost ~]# grep -B 3 quit /etc/passwd # 注：输出匹配行以及前几行 六. free -g 看内存使用率 free -g 12345678[root@sanchuang-linux ~]# free -g # 注：看内存使用率 ，-g单位G ， -m单位M total used free shared buff/cache availableMem: 1 0 1 0 0 1Swap: 1 0 1[root@sanchuang-linux ~]# free -m total used free shared buff/cache availableMem: 1800 272 1101 8 426 1363Swap: 2047 0 2047 七. 编写脚本 12345678910实现以下功能1、监控内存使用情况,如果内存使用率大于百分之80，给予提醒 total free 使用率2、扫描局域网ip,检查哪些ip地址正在使用 ping -c 1 # 注：发送1个包3、监控文件/etc/passwd是否被修改，每隔5分钟监控一次 diff md5sum # md5值，文件的唯一标识4、监控nginx进程是否存在，不存在就给予相应提醒 pidof nginx 123456--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# md5sum abc.txt # 注：md5值2416b02c3d9d753f48cf49dbb5f1de94 abc.txt--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# pidof nginx # 注：显示指定程序的进程号12767 12766 12765 7.1 监控内存使用情况,如果内存使用率大于百分之80，给予提醒 ​ total free 使用率 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081示例--------------------------------------------------------------------------------------------#!/bin/bashfunction mem()&#123; total=`free -m|grep -i mem|tr -s &quot; &quot;|cut -d &quot; &quot; -f2` #free=`free -m|grep -i mem|tr -s &quot; &quot;|cut -d &quot; &quot; -f4` used=`free -m|grep -i mem|tr -s &quot; &quot;|cut -d &quot; &quot; -f3` used_rate=`echo &quot;scale=4;$used/$total&quot; |bc` #used_1=`echo &quot;$total*0.8&quot;|bc ` result=` echo &quot;$used_rate&gt;0.8&quot;|bc ` echo $result if (( $result == 1 )) then echo -e &quot;\\e[31m使用率超过80%，请及时对内存扩容，以免不必要的损失\\e[0m&quot; else echo &quot; nothing to do&quot; fi&#125;mem--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# bash mem_test.sh0 nothing to do============================================================================================知识点7.1.1 bc 命令菜鸟教程：https://www.runoob.com/linux/linux-comm-bc.htmlbc 命令是任意精度计算器语言，通常在linux下当计算器用[root@localhost ~]# yum install bc -y[root@sanchuang-linux ~]# used=`free -m|grep -i mem|tr -s &quot; &quot;|cut -d &quot; &quot; -f3`[root@sanchuang-linux ~]# total=`free -m|grep -i mem|tr -s &quot; &quot;|cut -d &quot; &quot; -f2`[root@sanchuang-linux ~]# echo &quot;scale=2;$used/$total&quot; |bc # 注：保留2位小数.16[root@sanchuang-linux ~]# echo &quot;scale=3;$used/$total&quot; |bc # 注：保留3位小数.165--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# free -m|grep -i mem|tr -s &quot; &quot;|cut -d &quot; &quot; -f2 # 注：-i 不区分大小写1800[root@sanchuang-linux ~]# use_rate=`echo &quot;scale=4;$used/$total&quot; |bc`[root@sanchuang-linux ~]# echo &quot;$use_rate&gt;0.8&quot;|bc # 注：为假返回00[root@sanchuang-linux ~]# echo &quot;0.7&gt;0.8&quot;|bc # 注：为假返回00[root@sanchuang-linux ~]# echo &quot;0.9&gt;0.8&quot;|bc # 注：为真返回11 # 注：这返回的应该是布尔值0假1真，而不是命令执行失败的值。$?都为0 ，命令执行成功############################################################################################知识点7.1.2 小数的运算小数的运算：1、可以使用bc[root@sanchuang-linux ~]# echo &quot;scale=3;1/3&quot;|bc # 注：保留3位小数.333[root@sanchuang-linux ~]# echo &quot;0.7&gt;0.8&quot;|bc # 注：不成立返回00[root@sanchuang-linux ~]# echo &quot;0.9&gt;0.8&quot;|bc # 注：成立返回112、awk 选项语法：awk 选项 ‘模式+动作’ 文件常用选项：-F 指定分隔符内置变量NR awk里表示每一行的行号NF awk的列号模式示例--------------------------------------------------------------------------------------------[root@localhost ~]# free -m total used free shared buff/cache availableMem: 3770 195 3274 11 300 3348Swap: 2047 0 2047[root@localhost ~]# free -m|awk &#x27;NR==2&#123;print $2&#125;&#x27; # 注：打印第二行 第2个变量3770 # 注：NR 行号 ， $2 第2个变量[root@localhost ~]# free -m|awk &#x27;NR==2&#123;print $3&#125;&#x27; # 注：打印第二行 第3个变量194============================================================================================[root@sanchuang-linux ~]# free -m|awk &#x27;/Mem/&#123;print $3/$2&#125;&#x27; # 注：计算小数，过滤出Mem0.156111 # 注：过滤出Mem 这1行[root@sanchuang-linux ~]# free -m|awk &#x27;/Mem/&#123;printf &quot;%.2f\\n&quot;, $3/$2&#125;&#x27; # 注：保留2位的浮点数0.16 # 注：\\n换行输出 7.2 扫描局域网ip,检查哪些ip地址正在使用 ​ ping -c 1 # 注：发送1个包 1234567891011121314151617181920212223242526272829303132333435方法1--------------------------------------------------------------------------------------------scan_ip()&#123; for ip in `seq 255` do ( ip_full=192.168.0.$ip ping -c 1 $ip_full &amp;&gt;/dev/null &amp;&amp; echo $ip_full &gt;&gt;up.txt || echo $ip_full &gt;&gt;down.txt ) &amp; # 注：放到后台子进程执行 donewait # 父进程等待子进程执行完成之后再退出&#125;scan_ip方法2--------------------------------------------------------------------------------------------scan_ip()&#123; for ip in 192.168.0.&#123;1..255&#125; # 注：1-255可以这么写 do ( ping -c 1 $ip &amp;&gt;/dev/null &amp;&amp; echo $ip &gt;&gt;up.txt || echo $ip &gt;&gt;down.txt ) &amp; donewait #注：作用：父进程等待子进程执行完成之后再退出&#125;scan_ip注：后台进程命令 &amp; 产生子bash进程去执行命令的任务wait 父进程等待子进程结束之后再退出============================================================================================[root@sanchuang-linux ~]# ip=45[root@sanchuang-linux ~]# ip_full=192.168.0.$ip # 注：shell 字符串的拼接[root@sanchuang-linux ~]# echo $ip_full 192.168.0.45[root@sanchuang-linux ~]# top # 注：查看cpu 7.3 监控nginx进程是否存在，不存在就给予相应提醒 ​ pidof nginx 123456789101112131415示例--------------------------------------------------------------------------------------------check_nginx()&#123; pidof nginx &amp;&amp; echo &quot;nginx is running&quot; || echo &quot;nginx is down&quot; #if [[ $? -eq 0 ]] #then # echo &quot;nginx is running&quot; #fi&#125;check_nginx--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# pidof nginx12767 12766 12765[root@sanchuang-linux ~]# echo $? # 注：返回值为0表示成功0 7.4 监控文件/etc/passwd是否被修改，每隔5分钟监控一次 ​ diff ​ md5sum # md5值，文件的唯一标识 123456789101112131415161718192021示例--------------------------------------------------------------------------------------------check_monitor()&#123; check_num=`differ /etc/passwd /lianxi/passwd |wc -l` [[ check_num -eq 0 ]] &amp;&amp; echo &quot;文件未被修改&quot; || echo &quot;文件已被修改&quot;&#125;check_monitor--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# cp /etc/passwd /lianxi/passwdcp：是否覆盖&#x27;/lianxi/passwd&#x27;？ y[root@sanchuang-linux ~]# diff /etc/passwd /lianxi/passwd[root@sanchuang-linux ~]# echo $? # 注：即使文件不被修改，返回也为0 （理解为命令执行成功）0 # 注：所以不能直接用类三元运算 去判断[root@sanchuang-linux ~]# diff /etc/passwd /lianxi/passwd[root@sanchuang-linux ~]# diff /etc/passwd /lianxi/passwd|wc 0 0 0[root@sanchuang-linux ~]# diff /etc/passwd /lianxi/passwd|wc -l0#注：判定依据 diff 是否输出内容 没有输出内容，wc -l 行数为0，说明文件未被修改#注：文件是否被修改，想到diff命令","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://blog1.cpen.top/tags/Shell/"}]},{"title":"12_Linux基础-SHELL命令-sort-uniq-cut-grep-正则表达式-通配符","slug":"Linux_基础/12_Linux基础-SHELL命令-sort-uniq-cut-grep-正则表达式-通配符","date":"2022-09-09T04:00:00.000Z","updated":"2022-09-09T05:00:00.000Z","comments":true,"path":"posts/61496.html","permalink":"https://blog1.cpen.top/posts/61496.html","excerpt":"","text":"一. 回顾 回顾1 shell常用命令 123获取命令的返回输出结果 1.` `，反引号 line=`ls`2.$() line=$(ls) 1234seq 类似于python里的range主要生产一组有序数字序列-s 指定分隔符-w 指定同等宽度输出 二. sort sort命令 默认按每行的第一个字符排序 -n：按整数进行排序–&gt;默认是升序 -r：递减排序（注：降序） -u：去重 指定排序键 指定按哪一列数据进行排序 -k：指定哪一列为排序键 cat tt | sort -n -k4 指定字段分隔符 -t：指定字段分割符（默认是空白） sort -t: -n -k3 /etc/passwd # 注：指定分隔符为 : sort是一个排序命令 默认按照每行第一个首字符进行排序 英文根据a-z的顺序进行排序，如果第一个字母相同，就比较第二个字母，依次类推 中文根据首个字符的拼音的首字母进行排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667示例1：cat sort_test.txt |sort---------------------------------------------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# cat sort_test.txt # 注：显示文本内容中文 456 1xx 123abc bcd 3yy ddAac XYZ 2zz三创 xixi[root@sanchuang-linux ~]# cat sort_test.txt |sort # 注：对整个文本进行排序三创 xixi中文 456 1xx 123Aac XYZ 2zzabc bcd 3yy dd--------------------------------------------------------------------------------------------&gt;&gt;&gt; ord(&quot;三&quot;) # python中的ord()函数查看万国码编码19977 # 注：sort不是按编码排序&gt;&gt;&gt; ord(&quot;中&quot;)20013--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# locale # 注：查看编码格式LANG=zh_CN.UTF-8LC_CTYPE=&quot;zh_CN.UTF-8&quot;LC_NUMERIC=&quot;zh_CN.UTF-8&quot;LC_TIME=&quot;zh_CN.UTF-8&quot;LC_COLLATE=&quot;zh_CN.UTF-8&quot;LC_MONETARY=&quot;zh_CN.UTF-8&quot;LC_MESSAGES=&quot;zh_CN.UTF-8&quot;LC_PAPER=&quot;zh_CN.UTF-8&quot;LC_NAME=&quot;zh_CN.UTF-8&quot;LC_ADDRESS=&quot;zh_CN.UTF-8&quot;LC_TELEPHONE=&quot;zh_CN.UTF-8&quot;LC_MEASUREMENT=&quot;zh_CN.UTF-8&quot;LC_IDENTIFICATION=&quot;zh_CN.UTF-8&quot;LC_ALL=============================================================================================示例2：cat sort_test.txt |sort -k 2 指定哪一列为排序键[root@sanchuang-linux ~]# cat sort_test.txt |sort -k2 # 注：指定第二列进行排序中文 456 1xx 123abc bcd 3yy dd三创 xixiAac XYZ 2zz[root@sanchuang-linux ~]# cat sort_test.txt |sort -k 3 # 注：指定第三列进行排序三创 xixi # 注：空白在前面中文 456 1xx 123 # 注：1Aac XYZ 2zz # 注：2abc bcd 3yy dd # 注：3============================================================================================示例3：英文根据a-z的顺序进行排序，如果第一个字母相同，就比较第二个字母[root@sanchuang-linux ~]# cat sort_test.txt 中文 456 1xx 123aac bcd 3yy ddAac XYZ 2zz三创 xixiXyz cdeBbc Abcbbc xxxABCabc[root@sanchuang-linux ~]# cat sort_test.txt |sort # 注：不是按照编码排序三创 xixi中文 456 1xx 123aac bcd 3yy ddAac XYZ 2zzabcABCBbc Abcbbc xxxXyz cde sort -n sort -n 按数字进行排序 1234567891011121314151617181920212223242526272829[root@sanchuang-linux ~]# a=123 # 注：a表示的是字符[root@sanchuang-linux ~]# b=234[root@sanchuang-linux ~]# echo $a+$b # 注：字符串的拼接123+234[root@sanchuang-linux ~]# echo $(($a+$b)) # 注：需要用2个括号进行数字的相加357--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# cat aa.txt 123234234[root@sanchuang-linux ~]# cat aa.txt |sort # 注：默认情况按首个字母字符串进行排序123232344[root@sanchuang-linux ~]# cat aa.txt |sort -n # 注：sort -n 按数值大小进行排序4 # 注：默认升序23 # 注：-n 数字排序比较123234--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# cat aa.txt |sort -n -r # 注：数字、倒序 排序，效果相同[root@sanchuang-linux ~]# cat aa.txt |sort -nr # 注：数字、倒序 排序，效果相同234123234 -t 指定列数的分隔符 指定列数的分隔符 # head -n7 /etc/passwd |sort -k6 -t : ​ 默认分隔符为空白字符 ​ 使用 -t 指定列数的分隔符 12345678910111213141516171819202122232425[root@sanchuang-linux ~]# head -n7 /etc/passwd |sort # 注：取前7行 排序adm:x:3:4:adm:/var/adm:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinroot:x:0:0:root:/root:/bin/bashshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownsync:x:5:0:sync:/sbin:/bin/sync[root@sanchuang-linux ~]# head -n7 /etc/passwd |sort -k2 # 注：sort -k2指定第2列为排序键adm:x:3:4:adm:/var/adm:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinroot:x:0:0:root:/root:/bin/bashshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownsync:x:5:0:sync:/sbin:/bin/sync[root@sanchuang-linux ~]# head -n7 /etc/passwd |sort -k6 -t : # *注：-t : 指定分隔符为 :bin:x:1:1:bin:/bin:/sbin/nologinroot:x:0:0:root:/root:/bin/bashsync:x:5:0:sync:/sbin:/bin/syncdaemon:x:2:2:daemon:/sbin:/sbin/nologinshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin[root@sanchuang-linux ~]# head -n7 /etc/passwd |sort -k6 -t : -r # 注：-r 倒序 三. 练习：找出内存使用率最高的5个进程 找出内存使用率最高的5个进程 12345678910111213ps aux|sort -n -k4 -r|head -5 注：推荐注：内存使用率 %MEM[root@sanchuang-linux ~]# ps aux|tail -n +2|sort -nr -k4 |head -5root 960 0.0 2.0 221572 38096 ? S 08:31 0:00 /usr/libexec/sssd/sssd_nss --uid 0 --gid 0 --logger=filesroot 930 0.0 1.7 425416 31480 ? Ssl 08:31 0:01 /usr/libexec/platform-python -Es /usr/sbin/tuned -l -Ppolkitd 890 0.0 1.2 1625936 23856 ? Ssl 08:31 0:00 /usr/lib/polkit-1/polkitd --no-debugroot 891 0.0 0.9 391216 18088 ? Ssl 08:31 0:00 /usr/sbin/NetworkManager --no-daemonroot 954 0.0 0.8 219700 15416 ? S 08:31 0:00 /usr/libexec/sssd/sssd_be --domain implicit_files --uid 0 --gid 0 --logger=files--------------------------------------------------------------------------------------------#ps aux|tail -n +2|sort -nr -k4 |head -5注：tail -n +2 显示从第2行到末尾（可加可不加）注：sort -nr -k4 -n按数字排序，-r倒序，-k4指定第4列为排序键注：head -5 取前5行 四. uniq uniq命令的使用（去重） uniq --&gt; unique唯一的 去重相邻的行 先排序，再去重 -c 统计重复出现的次数 -u 显示只出现1次的行 -d 显示重复出现的行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960============================================================================================示例1：去重相邻的行[root@sanchuang-linux ~]# cat uniq_test.txt123 abcabc 1234546454547474847[root@sanchuang-linux ~]# cat uniq_test.txt |uniq # 注：去重相邻的行123 abcabc 123454645474847[root@sanchuang-linux ~]# cat uniq_test.txt |sort -n |uniq # 注：先排序，再去重abc 123 # 注：一般来说，先排序，再去重45464748123 abc--------------------------------------------------------------------------------------------示例1.1 # cat uniq_test.txt |sort -nu[root@sanchuang-linux ~]# cat uniq_test.txt |sort -n -u # 注：sort -u 也可以去重[root@sanchuang-linux ~]# cat uniq_test.txt |sort -nu # 注：效果一样abc 12345464748123 abc============================================================================================示例2：-c 统计重复出现[root@sanchuang-linux ~]# cat uniq_test.txt |sort -n |uniq -c # 注： -c 统计重复出现的次数 1 abc 123 3 45 1 46 3 47 1 48 1 123 abc============================================================================================示例3：-u显示只出现1次的行[root@sanchuang-linux ~]# cat uniq_test.txt |sort -n |uniq -u # 注：-u显示只出现1次的行abc 1234648123 abc============================================================================================示例4：-d 显示重复出现的行[root@sanchuang-linux ~]# cat uniq_test.txt |sort -n |uniq -d # 注：-d 显示重复出现的行4547 五. 练习：统计120000行 频率前十的ip 统计120000行 频率前十的ip 12345[root@sanchuang-linux ~]# cat ips.txt |sort |uniq -c|sort -nr |head#注1：第一个sort 把相同的ip段放在一起#注2：uniq -c统计次数#注：第二个sort -nr 对前面的次数+ip 进行逆序#注：head 默认取前十个 12345678910111213141516171819注 :sort -c 用于统计ip地址的访问[root@localhost ~]# yum install nginx[root@sanchuang-linux ~]# nginx[root@sanchuang-linux ~]# lsof -i:80 # 注：nginx起来了COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnginx 12765 root 9u IPv4 60060 0t0 TCP *:http (LISTEN)nginx 12765 root 10u IPv6 60061 0t0 TCP *:http (LISTEN)nginx 12766 nginx 9u IPv4 60060 0t0 TCP *:http (LISTEN)nginx 12766 nginx 10u IPv6 60061 0t0 TCP *:http (LISTEN)nginx 12767 nginx 9u IPv4 60060 0t0 TCP *:http (LISTEN)nginx 12767 nginx 10u IPv6 60061 0t0 TCP *:http (LISTEN)[root@sanchuang-linux ~]# iptables -F # 注：关闭防火墙[root@sanchuang-linux ~]# cd /var/log # 注：/var/log放日志[root@sanchuang-linux log]# cd nginx[root@sanchuang-linux nginx]# pwd/var/log/nginx[root@sanchuang-linux nginx]# lsaccess.log error.log # 注：日志文件 六. 练习：统计web服务器访问前十的用户 统计web服务器访问前十的用户（注：通过ip判断） 123456789101112131415161718#注：nginx查看访问次数最多的3个ip(笔试题常见)#cat access.log |awk &#x27;&#123;print $1&#125;&#x27;|sort|uniq -c|sort -nr|head -3[root@sanchuang-linux nginx]# head access.log 192.168.0.42 - - [29/Oct/2020:12:01:01 +0800] &quot;GET / HTTP/1.1&quot; 200 4057 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3823.400 QQBrowser/10.7.4307.400&quot; &quot;-&quot;……………… # 注：awk命令 提取文本第一列数据 ip地址[root@sanchuang-linux nginx]# cat access.log |awk &#x27;&#123;print $1&#125;&#x27;192.168.0.42 # 注：默认以空格为分隔符，打印第一列$1192.168.0.42192.168.0.42192.168.0.42192.168.0.42192.168.0.193192.168.0.193192.168.0.193192.168.0.193 # 注：awk命令 提取文本第一列数据 ip地址[root@sanchuang-linux nginx]# cat access.log |awk &#x27;&#123;print $1&#125;&#x27;|sort|uniq -c|sort -nr|head -3 5 192.168.0.42 # 注：统计前3的访问量 4 192.168.0.193 七. cut cut命令 从文本文件或者文本流中提取文本列 cut -选项 提取范围 文本文件 ----------------------------------- 常见选项 -c：从指定提取范围中提取字符 -f：从指定提取范围中提取字段 -d：指定分隔符，默认分隔符为tab键 ----------------------------------- 提取范围 n：第n项 n-：第n项到行尾 -m：行首到第m项 n,m：第n项和第m项 n-m：第n项到第m项 123456789101112131415161718192021222324252627282930313233343536示例--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# w # 注：w 当前用户登录情况 14:45:33 up 4:12, 5 users, load average: 0.00, 0.00, 0.03USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot tty1 - 三22 15:49 0.08s 0.08s -bashroot pts/0 192.168.0.42 14:29 3.00s 0.02s 0.01s wroot pts/1 192.168.0.42 14:29 15:35 0.00s 0.00s -bashroot pts/3 192.168.0.42 09:48 4:56m 0.03s 0.03s -bashroot pts/4 192.168.0.42 09:50 2:37m 0.52s 0.52s -bash[root@sanchuang-linux ~]# who # 注：w 看到更详细点root tty1 2020-10-28 22:15root pts/0 2020-10-29 14:29 (192.168.0.42)root pts/1 2020-10-29 14:29 (192.168.0.42)root pts/3 2020-10-29 09:48 (192.168.0.42)root pts/4 2020-10-29 09:50 (192.168.0.42)方法1--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# w |tr -s &quot; &quot;|cut -d&quot; &quot; -f 1,2,4 14:50:31 4:17, # 注：默认分隔符为tab键，所有要压缩 USER TTY LOGIN@ # 注：再指定分隔符为空格root tty1 三22 # 注：加tr -s &quot; &quot;root pts/0 14:29root pts/1 14:29root pts/3 09:48root pts/4 09:50方法2--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# w |awk &#x27;&#123;print $1,$2,$4&#125;&#x27; # 注：awk 默认分隔符是空白字符14:51:28 up 5 # 注：打印第1、2、4列USER TTY LOGIN@root tty1 三22root pts/0 14:29root pts/1 14:29root pts/3 09:48root pts/4 09:50 以冒号作为分隔符 截取用户名、用户Id、用户属组 以冒号作为分隔符 截取用户名、用户Id、用户属组 12345写法1[root@sanchuang-linux ~]# cat /etc/passwd|cut -d&quot;:&quot; -f 1,3,5 写法2（推荐）[root@sanchuang-linux ~]# cut -d &quot;:&quot; -f 1,3,5 /etc/passwd # 注：截取1,3,5列#注：文本操作命令，可以直接操作文本，不需要用到cat 取值范围 取值范围 12345678910111213[root@sanchuang-linux ~]# cut -d &quot;:&quot; -f 1,3,5 /etc/passwd # 注：截取1,3,5列[root@sanchuang-linux ~]# cut -d &quot;:&quot; -f 1-5 /etc/passwd # 注：截取1-5列[root@sanchuang-linux ~]# cut -d &quot;:&quot; -f 3- /etc/passwd # 注：截取第3列--列尾[root@sanchuang-linux ~]# cut -d &quot;:&quot; -f -3 /etc/passwd # 注：截取前3列============================================================================================-c：从指定提取范围中提取字符示例[root@sanchuang-linux ~]# echo abcdefg |cut -c 2 # 注：截取第2个字符b[root@sanchuang-linux ~]# echo abcdefg |cut -c 2-5 # 注：截取2--5个字符bcde[root@sanchuang-linux ~]# echo abcdefg |cut -c 5- # 注：截取第5到末尾字符efg 八. 练习 练习 123451统计access.log中排名前三的ip2显示/boot目录下面所有的文件大小(包括子目录中的文件)，并且由小到大排序3统计/etc/passwd中每种shell使用的次数（降序排序）4统计一下/etc/passwd中sbin这个单词出现了多少次5只显示ens33的ip地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697============================================================================================示例1：1统计access.log中排名前三的ip--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# cut -d &quot;-&quot; -f 1 access.log |sort|uniq -c|sort -nr|head -n3 7 192.168.0.42 6 192.168.0.193 5 192.168.0.38 --------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# cut -d &quot; &quot; -f1 access.log |sort|uniq -c 6 192.168.0.193 5 192.168.0.21 5 192.168.0.32 5 192.168.0.37 5 192.168.0.38 7 192.168.0.42[root@sanchuang-linux ~]# cut -d &quot; &quot; -f1 access.log |sort|uniq -c|sort -nr 7 192.168.0.42 6 192.168.0.193 5 192.168.0.38 5 192.168.0.37 5 192.168.0.32 5 192.168.0.21[root@sanchuang-linux ~]# cut -d &quot; &quot; -f1 access.log |sort|uniq -c|sort -nr|head -3 7 192.168.0.42 6 192.168.0.193 5 192.168.0.38============================================================================================示例2：2显示/boot目录下面所有的文件大小(包括子目录中的文件)，并且由小到大排序方法1--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# du -ak /boot |sort -n # 注：以k为字节4 /boot/.bashrc4 /boot/efi/EFI/centos4 /boot/grub2/device.map4 /boot/grub2/grubenv4 /boot/grub2/i386-pc/adler32.mod4 /boot/grub2/i386-pc/all_video.mod4 /boot/grub2/i386-pc/aout.mod方法2--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# ll -R|grep root|tr -s &quot; &quot;|cut -d &quot; &quot; -f 5,9|sort -n0 1214.txt0 12244.txt0 1224.txt0 12456.txt0 200 200 2020-09-24-18_25_03.txt方法3--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# ll -R|grep root|awk &#x27;&#123;print $5,$9&#125;&#x27;|sort -n0 1214.txt0 12244.txt0 1224.txt0 12456.txt0 200 200 2020-09-24-18_25_03.txt0 abcd.txt============================================================================================示例3：3统计/etc/passwd中每种shell使用的次数（降序排序）[root@sanchuang-linux ~]# cut -d : -f7 /etc/passwd |sort|uniq -c|sort -nr 31 /bin/bash 19 /sbin/nologin 1 /sbin/shutdown 1 /sbin/halt 1 /bin/sync============================================================================================示例4：4统计一下/etc/passwd中sbin这个单词出现了多少次方法1--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# grep -o sbin /etc/passwdsbinsbin………………sbinsbin[root@sanchuang-linux ~]# grep -o sbin /etc/passwd|wc -l25方法2--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# cat /etc/passwd|tr &quot;:&quot; &quot;\\n&quot;|grep sbin|wc -l25 # 注：将: 换成 换行符 同一行换到不同的行去============================================================================================示例5：5只显示ens33的ip地址#ip a |grep ens33|grep inet|tr -s &quot; &quot;|cut -d &quot; &quot; -f3|cut -d&quot;/&quot; -f1--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# ip a |grep ens332: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 inet 192.168.0.34/24 brd 192.168.0.255 scope global dynamic noprefixroute ens33[root@sanchuang-linux ~]# ip a |grep ens33|grep inet|tr -s &quot; &quot;|cut -d &quot; &quot; -f3192.168.0.34/24[root@sanchuang-linux ~]# ip a |grep ens33|grep inet|tr -s &quot; &quot;|cut -d &quot; &quot; -f3|cut -d&quot;/&quot; -f1192.168.0.34 九. awk指定分隔符 -F awk指定分隔符 -F 12345678[root@sanchuang-linux ~]# awk -F&quot;:&quot; &#x27;&#123;print $1&#125;&#x27; /etc/passwdrootbindaemonadmlpsync………………………… 十. grep grep命令 文本三剑客 ==&gt; awk grep sed https://www.cnblogs.com/end/archive/2012/02/21/2360965.html grep 过滤 通用的正则表达式分析程序 grep、egrep、fgrep 做匹配来过滤的 用途：在文件中查找并显示包含指定字符串的行 格式：grep [选项]... 模式 目标文件 #注：模式pattern --》模板 ​ 可以接受一个正则表达式 -i：查找时忽略大小写 -v：反转查找，输出与模式不相符的行 -n：显示符合模式要求的行号 -r：递归搜索所有文件 -o：只显示匹配的内容 -E：支持更多的元字符（支持扩展正则） -A：找到匹配行以及后几行 -B：输出匹配行以及前几行 模式 ^…. ：以什么开头，整行以什么开头 …..$ ：以什么结尾，整行以什么结尾 注：grep 是文本操作命令，可以直接操作文本 12345678910111213141516171819202122232425262728293031323334353637383940=====================================================================示例1：-v：反转查找，输出与模式不相符的行---------------------------------------------------------------------[root@sanchuang-linux ~]# grep -v “#” /etc/yum.repos.d/centos.repo # 注：不输出包含# 的行============================================================================================示例2：-i 查找时忽略大小写---------------------------------------------------------------------[root@sanchuang-linux ~]# cd /etc/ssh/[root@sanchuang-linux ssh]# pwd/etc/ssh[root@sanchuang-linux ssh]# grep -i &quot;port&quot; /etc/ssh/sshd_config # 注：查找时忽略大小写# If you want to change the port on a SELinux system, you have to tell# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER#Port 22# WARNING: &#x27;UsePAM no&#x27; is not supported in Fedora and may cause several#GatewayPorts no============================================================================================示例3：忽略大小写，并显示查找到的行号--------------------------------------------------------------------------------------------[root@sanchuang-linux ssh]# grep -i -n &quot;port&quot; /etc/ssh/sshd_config # 注：显示符合模式要求的行号13:# If you want to change the port on a SELinux system, you have to tell15:# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER17:#Port 22102:# WARNING: &#x27;UsePAM no&#x27; is not supported in Fedora and may cause several108:#GatewayPorts no============================================================================================示例4：-r 递归搜索所有文件注：子目录以及子子目录下面查找--------------------------------------------------------------------------------------------[root@sanchuang-linux ssh]# grep &quot;xxxxx&quot; * -r # 注：当前目录所有目录及子目录文件下的 递归查找[root@sanchuang-linux ssh]# grep &quot;GET&quot; /var/log/nginx -r # 注：nginx目录下面 递归查找/var/log/nginx/error.log:2020/10/29 12:01:02 [error] 12767#0: *2 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 192.168.0.42, server: _, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.0.34&quot;, referrer: &quot;http://192.168.0.34/&quot;/var/log/nginx/error.log:2020/10/29 12:01:58 [error] 12767#0: *2 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 192.168.0.42, server: _, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.0.34&quot;--------------------------------------------------------------------------------------------#递归查找/var/log/nginx下的所有文件（包括其下面子目录里的文件）[root@mysql-binary nginx]# grep &quot;GET&quot; /var/log/nginx -r 十一. 正则表达式 正则表达式 ^aa 表示以aa开头的行 aa$ 表示以aa结尾的行 1234[] 表示一个字符集[a-z] 从a - z 中取一个[^a-z] 不取a-z的字符grep ^[^a-zA-Z0-9_] grep_test.txt 显示不以字母、数字、下划线开头的行 1234567891011121314151617181920212223242526272829303132333435示例1：不输出以#开头的行--------------------------------------------------------------------------------------------[root@sanchuang-linux yum.repos.d]# grep -v ^# centos.repo[root@sanchuang-linux yum.repos.d]# grep -v ^# centos.repo|grep -v ^$ # 注：不输出空白行注：不输出空白行 grep -v ^$ 不输出以#开头的行 grep -v ^#============================================================================================示例2：过滤出grep_test.txt中，不以#号开头的行 和 非空白行--------------------------------------------------------------------------------------------[root@sanchuang-linux chenpeng]# cat grep_test.txt#aaaaaa#bbb456#789[root@sanchuang-linux chenpeng]# grep -v ^# grep_test.txt # 注：过滤出不以#号开头的行aaa#bbb456789#方法1[root@sanchuang-linux chenpeng]# grep -v ^# grep_test.txt |grep -v ^$ # 注：过滤出空白行aaa#bbb # 注：如果是空白字符 不会被过滤456789#方法2过滤出grep_test.txt中 不以#开头的行和非空白行[root@sanchuang-linux chenpeng]# grep -v -E &quot;^#|^$&quot; grep_test.txt aaa#bbb # 注：-E 正则表达式 ，| 或者 ， -v 不显示456 # 注：-E：支持更多的元字符（支持扩展正则）789 十二. [] 表示一个字符集（正则表达式） [] 表示一个字符集（正则表达式） 123456789101112131415161718192021222324252627282930313233343536373839404142[root@localhost chenpeng]# cat grep_test.txt abcadcAbdcaca1caxyaxc123777示例1：过滤出abc adc--------------------------------------------------------------------------------------------[root@localhost chenpeng]# grep a[bd]c grep_test.txt # 注：取字符集[bd]里面的其中1个abcadc[root@sanchuang-linux chenpeng]# grep a[a-z]c grep_test.txt # 注：取出a-z中的1个字符abc # 注：ac 没有被过滤，必须有1个字符放在这里adc # 注：[a-z] 表示 从a - z 中取一个axc[root@sanchuang-linux chenpeng]# grep a[0-9]c grep_test.txt # 注：取出0-9中的1歌字符a1c--------------------------------------------------------------------------------------------示例2：[^a-z] 不取a-z的字符--------------------------------------------------------------------------------------------[root@sanchuang-linux chenpeng]# grep a[^a-z]c grep_test.txt # 注：^取反，ac之间不取a-z的字符a1c示例3：取出不以字母开头的行--------------------------------------------------------------------------------------------[root@sanchuang-linux chenpeng]# grep ^[^a-zA-Z] grep_test.txt # 注：不以a-zA-Z开头的行11c123 # 注：中间接空格 表示 包括空格777注：grep ^[a-zA-Z] grep_test.txt 以字母开头的行============================================================================================示例4：显示不以字母、数字、下划线开头的行写法1[root@sanchuang-linux chenpeng]# grep ^[^a-zA-Z0-9_] grep_test.txt写法2[root@sanchuang-linux chenpeng]# grep -v ^[a-zA-Z0-9_] grep_test.txt#注：显示不以字母、数字、下划线开头的行 十三. 通配符（正则表达式） 通配符（正则表达式） 1234567* 代表匹配前一个项任意次？ 代表匹配前一个项0次或者1次+ 代表匹配前一个项一次到多次. 占位符 除\\n之外的任意字符&#123;n,m&#125; 匹配前一项n到m次egrep 等同于 grep -Efgrep 不支持任何正则，普通文本过滤 1234567891011121314151617181920212223242526272829303132333435363738394041424344示例1：* ? + .--------------------------------------------------------------------------------------------#注：匹配的都是前面这个字符[root@localhost ~]# cat grep_test.txt alcaxxcac[root@localhost ~]# grep -E a.?c grep_test.txt # 注：-E 支持更多正则扩展alc # 注：. 占位符（注=一定要有1个字符）ac # 注：.? 表示a和c之间.可以出现0次到1次[root@localhost ~]# grep -E a.*c grep_test.txt # 注：.* 表示a和c之间可以有任意个.（任意个字符）alc # 注：egrep 等同于 grep -Eaxxcac[root@localhost ~]# grep -E a.c grep_test.txt # 注：. 表示a和c之间只有1个字符alc[root@localhost ~]# grep -E a.+c grep_test.txt # 注：代表前一个字符.出现1个到多个alcaxxc示例2：&#123; &#125;--------------------------------------------------------------------------------------------#注：匹配的都是前面这个字符[root@localhost ~]# egrep &quot;a.&#123;1&#125;c&quot; grep_test.txt # 注：指定 . 出现1次alc[root@localhost ~]# egrep &quot;a.&#123;1,2&#125;c&quot; grep_test.txt # 注：指定 . 出现1次到2次alcaxxc示例3：&#123; &#125;--------------------------------------------------------------------------------------------[root@localhost ~]# cat grep_test.txt alcaxxcacayy1caddddddc[root@localhost ~]# egrep &quot;a.&#123;1,5&#125;c&quot; grep_test.txt # 注：前1项 . 出现1次到5次alcaxxcayy1cegrep 等同于 grep -Efgrep 不支持正则，普通文本过滤 十四. 练习：grep 正则表达式 grep 正则表达式 1、进入/lianxi目录，复制/etc/passwd到当前目录下，然后对passwd进行操作 2、查找出当前passwd文件中以ftp或者mail开头的行，输出到屏幕 12grep -E &quot;^ftp|^mail&quot; passwdegrep &quot;^ftp|^mail&quot; passwd 3、查找出当前passwd文件中不以r、m、f开头的行 12grep -v -E &quot;^r|^m|^f&quot; passwdgrep ^[^rmp] passwd 4、查找出当前passwd中以bash结尾的行 1grep bash$ passwd 5、查找出/etc/login.defs文件中的有效行（不显示空行和注释行，以#号开头的行） 1grep -v -E &quot;^#|^$&quot; /etc/login.defs 6、查找出/var/log/messages 文档中有15个字母的单词 12grep -E &quot;[^a-zA-Z][a-zA-Z&#123;15&#125;][^a-zA-Z]&quot; /var/log/message # 注：左右不是单词，中间15个字母grep -E &quot;\\b[a-zA-Z&#123;15&#125;]\\b&quot; /var/log/message # 注：\\b自动匹配单词的边界 7、查找出/etc/passwd文件里用户名包含liu同时使用bash的用户 1grep liu /etc/passwd|grep bash$|cut -d&quot;:&quot; -f1 8、查找出/etc/ssh/sshd_config里的有效行 1grep -v -E &quot;^#|^$&quot; /etc/ssh/sshd_config 9、查找出/etc/ssh/sshd_config 文件里包含连续2个字符的行 12grep -E &quot;(.)\\1&quot; /etc/ssh/sshd_config grep -E &quot;(.)\\1&quot; # 注：.除了换行的任意一个字符 \\1前面这个组在\\1这里又出现一次（一模一样） 10、查找出包含特殊字符的行 1grep -E &quot;[^0-Z]&quot; grep_test.txt 11、查找出不包含数字的行 1grep -v &quot;[0-9]&quot; abc.txt 12、查找出/var/log/secure里的ip地址 1cut -d &quot; &quot; -f11 /var/log/secure|grep -E &quot;\\..&quot;|sort|uniq 注：\\.转义 第二个. 表示任1字符 12345678910111213141516171819--------------------------------------------------------------------------------------------grep -E &quot;((([0-9])|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5]))\\.)&#123;3&#125;(([0-9])|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5]))&quot; ip_test.txt============================================================================================ip地址匹配： Ipv4 0-255 4个 192.168.1.0注：匹配ip地址[root@sanchuang-linux ~]# grep -E &quot;((([0-9])|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5]))\\.)&#123;3&#125;(([0-9])|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5]))&quot; ip_test.txt192.168.0.1192.168.1.255172.0.0.1((([0-9])|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5]))\\.)&#123;3&#125;(([0-9])|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5]))#括号括起来表示一个组分析0-2550-9 个位数[1-9][0-9] 十位数(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5]) 百位数","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://blog1.cpen.top/tags/Shell/"}]},{"title":"11_Linux基础-SHELL入门2","slug":"Linux_基础/11_Linux基础-SHELL入门2","date":"2022-09-08T04:00:00.000Z","updated":"2022-09-08T05:00:00.000Z","comments":true,"path":"posts/35184.html","permalink":"https://blog1.cpen.top/posts/35184.html","excerpt":"","text":"一. 练习：用户 增删改查 脚本 编写一个脚本，实现如下功能 123456789101112====================1.增加用户并设置密码2.删除用户3.查看用户4.退出====================输入的指定不是1-4，给提示给予提醒，并且如果不输入退出的话，可以循环添加。按1 增加用户，并且设置密码 useradd passwd按2 删除用户 userdel -r 按3 查看用户 id 按4 退出 exit===================================================================== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465示例1：--------------------------------------------------------------------------------------------menu()&#123; #（注：函数）echo &quot;====================&quot;echo &quot;1.增加用户并增加密码&quot;echo &quot;2.删除用户&quot;echo &quot;3.查看用户&quot;echo &quot;4.退出&quot;echo &quot;====================&quot;read -p &quot;请选择您所需要的服务:&quot; ser&#125;-------------------------------------------------create_user()&#123; #（注：函数） read -p &quot;创建用户名:&quot; user1 id $user1 &amp;&gt;/dev/null &amp;&amp; echo &quot;用户已存在！&quot; &amp;&amp; return #（注：退出函数，接return） useradd $user1 &amp;&gt;/dev/null #（注：导入黑洞文件） id $user1 &amp;&gt;/dev/null || return #(注：用户已存在 用Id 判断比较好。返回值非0可能是命令执行错误) read -s -p &quot;设置密码:&quot; passwd1 #（注：-s密码隐藏） echo $passwd1|passwd $user1 --stdin &amp;&gt;/dev/null&#125;-----------------------------------------------------------while :domenu #（注：调用函数）case $ser in 1) clear #（注：清空屏幕） create_user ;;2)# ……………………………………4) echo “退出！” exit ;;*) #（注：表示其他的所有选项，从上至下依次匹配） echo “请输入1-4！”esacdone-----------------------------------------------------------------------------------------------------------示例2：if 语法--------------------------------------------------------------------- if [&quot;$options&quot;==1]||[&quot;$options&quot;==2]||[&quot;$options&quot;==3]||[&quot;$options&quot;==4] then case $options in 1) read -p &quot;请输入用户名:&quot; username if id $username &amp;&gt;/dev/null then echo &quot;$username is exist!&quot; else read -s -p &quot;请设置密码:&quot; password useradd $username &amp;&gt;/dev/null echo $password | $username --stdin &amp;&gt;/dev/null echo -e &quot;\\n create $username ok!&quot; fi ;; # …………………………………………………… 4) echo &quot;退出!&quot; exit esac else echo &quot;请输入数字1或2或3或4!&quot; fi 123456789101112补充：&amp;&amp;可以连接2个命令--------------------------------------------------------------------&amp;&amp;可以连接2个命令[root@sanchuang-linux ~]# id chen222uid=1017(chen222) gid=1017(chen222) 组=1017(chen222)[root@sanchuang-linux ~]# id chen222 &amp;&amp; echo &quot;chen222存在&quot;uid=1017(chen222) gid=1017(chen222) 组=1017(chen222)chen222存在[root@sanchuang-linux ~]# id chen222 &amp;&gt;/dev/null &amp;&amp; echo &quot;chen222存在&quot;chen222存在#注：用户已存在 用id 判断比较好。返回值非0可能是命令执行错误 二. 变量 变量 全局/局部 Shell Shell中定义的变量 默认全局变量 123456789101112131415161718192021222324===========================================================================================local a=10 局部变量示例1：local 局部变量--------------------------------------------------------------------------------------------func01()&#123; local a=10&#125;func01 #（注：调用函数）echo $a--------------------------------------------------------------------------------------------[root@sanchuang-linux chenpeng]# sh aaa.sh #（注：为空。局部变量）============================================================================================示例2：默认全局变量--------------------------------------------------------------------------------------------func01()&#123; a=10&#125;func01 #（注：调用函数）echo $a[root@sanchuang-linux chenpeng]# sh aaa.sh 10 #（注：全局变量） Python Python定义的变量 默认局部变量 1234567891011121314151617181920212223242526===========================================================================================global a 全局变量示例1：global a 全局变量--------------------------------------------------------------------------------------------def func01(): global a #（注：全局变量） a = 10func01()print(a)[root@sanchuang-linux ~]# python3 python_hanshu.py 10============================================================================================示例2：默认局部变量 只能在函数体内使用的变量--------------------------------------------------------------------------------------------def func01(): a = 10func01()print(a)[root@sanchuang-linux ~]# python3 python_hanshu.py Traceback (most recent call last): File &quot;python_hanshu.py&quot;, line 5, in &lt;module&gt; print(a)NameError: name &#x27;a&#x27; is not defined #（注：局部变量） Shell函数里传参（位置变量） shell函数里传参（位置变量） 123456789示例：--------------------------------------------------------------------------------------------Shell里传参func01()&#123; a=100 echo &quot;$1 $2 $3&quot; #（注：函数的参数 [位置变量]）&#125;func01 第一个参数 第二个参数 第三个参数 #（注：调用参数）echo $a Python里传参 python里传参 12345678示例：python里传参--------------------------------------------------------------------------------------------def func01(x,y): global a a = 10func01(1,2)print(a) 三. test test判断 等同于[] 1234567示例：test--------------------------------------------------------------------------------------------[root@sanchuang-linux chenpeng]# a=123[root@sanchuang-linux chenpeng]# b=123[root@sanchuang-linux chenpeng]# test a==b[root@sanchuang-linux chenpeng]# test a==b &amp;&amp; echo okok 四. 判断方式 [] [[]] (()) test 判断方式 [] [[]] (()) test (( )) 判断数字 &gt; &lt; == != [[ ]] 判断字符串 或者 -eq -ne -gt -lt 判断数字 是不支持的，建议使用[[ ]] test(测试)判断，等同于1个中括号 12345678示例：test---------------------------------------------------------------------[root@sanchuang-linux ~]# a=123[root@sanchuang-linux ~]# b=123[root@sanchuang-linux ~]# test a==b &amp;&amp; echo okok[root@sanchuang-linux ~]# test a==b &amp;&amp; echo ok || echo errorok 五. 连接运算 连接运算 使用分号(;)实现一行中写多条语句 12345示例：--------------------------------------------------------------------------------------------[root@sanchuang-linux chenpeng]# echo &quot;abc&quot;;echo &quot;xyz&quot;abcxyz 六. 函数 函数的定义/使用 1234567示例--------------------------------------------------------------------------------------------add()&#123; echo “两数相加为:$(( $num1 + $num2 ))”&#125;add============================================================================================ 函数的传参 123456789101112示例：位置参数传参--------------------------------------------------------------------------------------------func01()&#123; a=100 echo &quot;$1 $2 $3&quot;&#125;func01 第一个参数 第二个参数 第三个参数echo $a============================================================================================·函数内的变量定义 默认为全局变量·使用local关键字 可以转换为局部变量 七. seq seq命令 seq命令 类似于 python中的range函数 用途：**打印出一串有序的数字 ** 格式：seq [选项] 数字范围 -s：指定分隔符 -w：指定同等宽带输出 ---------------------------------------- 数字范围的展示： [start] [step] end start 和 step 都是选填的 step 为正，表示从小到大输出 step 为负，表示从大到小输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879示例1：[start] [step] end--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# seq 3 -1 1 # 注：中间是步长。左右是起始位置321[root@sanchuang-linux ~]# seq 1 2 6135[root@sanchuang-linux ~]# seq 1 -2 6 # 注：步长为负数时，从1到6没有输出[root@sanchuang-linux ~]# seq 6 -2 1642示例2：# seq 2 5 # seq -w 9 12--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# seq 2 52345[root@localhost ~]# seq -w 9 12 # -w 指定同等宽度输出09101112============================================================================================补充 获取命令的返回结果·使用反引号 ``·或者 $()示例3：获取/etc/passwd最后一行，赋给一个变量[root@sanchuang-linux ~]# tail -n1 /etc/passwd # 注：获取最后一行 # tail -n1wtc:x:1029:1029::/home/wtc:/bin/bash[root@sanchuang-linux ~]# line=`tail -n1 /etc/passwd` # 注：方法1[root@sanchuang-linux ~]# echo $linewtc:x:1029:1029::/home/wtc:/bin/bash[root@sanchuang-linux ~]# line1=$(tail -n1 /etc/passwd) # 注：方法2[root@sanchuang-linux ~]# echo $line1wtc:x:1029:1029::/home/wtc:/bin/bash============================================================================================示例4：seq命令 类似于 python中的range函数--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# vim seq_test.shfor i in `seq 2 10` # 注：反引号 执行这个命令，获取命令的返回值do # 注：seq 2 10 包括2，包括10 echo $idone-----------------------------------------------------------------------for i in $(seq 2 10) # 注：也表示执行这个命令，获取命令的返回值do echo $idone[root@sanchuang-linux ~]# bash seq_test.sh 2345678910============================================================================================示例5：-s：指定分隔符--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# seq -s &quot;+&quot; 10 # -s：指定分隔符1+2+3+4+5+6+7+8+9+10 # 注：不搞开头，默认情况下 从1开始，到10[root@sanchuang-linux ~]# seq 10 #注：默认情况下 连接符是 换行符12345678910 八. 练习：创建用户 创建用户（3次重试机会）脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667示例：seq命令 创建失败 重试--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# vim user_add.sh#!/bin/bash# 增加 # 注：用户增加的部分add()&#123; for i in `seq 3 -1 1` # 注：seq 命令类似于pythonrange函数 3 2 1 do echo &quot;增加用户&quot; read -p &quot;请输入用户名：&quot; username id $username &amp;&gt;/dev/null &amp;&amp; echo &quot;用户已存在,还有$(( $i - 1))次机会&quot; &amp;&amp; continue #if id $username &amp;&gt;/dev/null #then # echo &quot;用户已存在，还有$(( $i -1 ))次机会&quot; # continue #fi #useradd $username &amp;&gt;/dev/null &amp;&amp; echo &quot;创建成功！&quot; &amp;&amp; echo $password | passwd $username --stdin &amp;&gt;/dev/null &amp;&amp; break || echo -e &quot;\\n创建失败！&quot; if useradd $username &amp;&gt;/dev/null then echo &quot;创建$&#123;username&#125;成功！&quot; read -s -p &quot;请设置密码：&quot; password echo $password | passwd $username --stdin &amp;&gt;/dev/null break else echo &quot;创建失败！,还有$(($i-1))次机会！&quot; fi done&#125;# 删除del()&#123; echo &quot;删除用户&quot; read -p &quot;请输入用户名：&quot; username userdel -r $username &amp;&gt;/dev/null &amp;&amp; echo &quot;删除成功！&quot; || echo &quot;用户不存在，删除失败！&quot;&#125;# 查看seek()&#123; echo &quot;查看用户&quot; read -p &quot;请输入用户名：&quot; username id $username &#125;echo &quot;#############################&quot;echo &quot;按1 增加用户，并且设置密码&quot;echo &quot;按2 删除用户&quot;echo &quot;按3 查看用户&quot;echo &quot;按4 退出&quot;echo &quot;#############################&quot;while :do read -p &quot;请输入你的选择：&quot; options case $options in 1) add ;; 2) del ;; 3) seek ;; 4) echo &quot;退出！&quot; exit ;; *) echo &quot;请输入指定内容 1-4！&quot; esacdone 九. 循环获取文件或者命令输出的内容(3种) 重定向 12345678示例1：重定向 while read a b c ； &lt; a.txt--------------------------------------------------------------------------------------------#!/bin/bashwhile read a b cdo echo &quot;name is $a, sex is $b, age is $c &quot;done &lt; a.txt # 注：当前路径下的文件。可以接绝对路径============================================================================================ 管道符号 1234567示例2：管道符号 cat a.txt | while read a b c--------------------------------------------------------------------------------------------cat a.txt | while read a b cdo echo &quot;name is $a, sex is $b, age is $c &quot;done============================================================================================ for循环 123456789101112131415161718192021222324252627282930示例3：for 循环实现（注：使用for循环去做，不太好）#for循环默认以空白(空格/回车 制表符)分割--------------------------------------------------------------------------------------------echo &quot;for 循环实现...........&quot;for i in `ls` # i 代表空白输出的每个文件do echo $idone--------------------------------------------------------------------------------------------示例3.2：i代表文件的每一项，以空白分割[root@sanchuang-linux ~]# vim file_test.shfor i in `cat a.txt`do echo $idone[root@sanchuang-linux ~]# bash file_test.sh wenyaof18chenpengm19wtcf17[root@sanchuang-linux ~]# cat a.txt wenyao f 18chenpeng m 19wtc f 17示例3.3：for i in `ls -al` # i代表当前目录下详细信息，i代表以空白分割的每一项 十. 练习：找出list.xml中主机为ZF的行然后循环输出ip与区服对应的关系 找出list.xml中主机为ZF的行然后循环输出ip与区服对应的关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546示例--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# cat list.xml ####IP 主机名 区服#########127.0.0.1 ZF-1 1 33 49 57127.0.0.1 ZF-11 65 67 69127.0.0.1 HF-1 22 34 6127.0.0.1 HF-11 6 17 36127.0.0.1 ZF-12 1 2127.0.0.1 HF-1 34 7--------------------------------------------------------------------------------------------步骤1：首先过滤出ZF所在的行[root@sanchuang-linux ~]# vim test6.sh #!/bin/bash # 管道| 把输出 作为下一条命令的输入cat list.xml |grep ZF |while read ip host qufu # 首先过滤出ZF所在的行do # while read 获取内容 echo &quot;ip:$ip, qufu:$qufu&quot; # 注：参数3整个赋给$qufudone[root@sanchuang-linux ~]# cat list.xml | grep ZF127.0.0.1 ZF-1 1 33 49 57127.0.0.1 ZF-11 65 67 69127.0.0.1 ZF-12 1 2[root@sanchuang-linux ~]# sh test6.sh # 注：$ip $host $qufu 不一定需要对应ip:127.0.0.1, qufu:1 33 49 57 # 前两个对应的，把前两个都取了ip:127.0.0.1, qufu:65 67 69 # 后面有的话，就全部是后面的内容ip:127.0.0.1, qufu:1 2 # 没有的话就为空（取不到的话就为空）--------------------------------------------------------------------------------------------步骤2：套个循环#!/bin/bashcat list.xml |grep ZF |while read ip host qufudo for i in $qufu # 注：套个循环。for循环以空格进行分割 do echo &quot;ip:$ip, qufu:$i&quot; # 注：这里是i。对区服进行循环 donedone[root@sanchuang-linux ~]# sh test6.sh ip:127.0.0.1, qufu:1ip:127.0.0.1, qufu:33ip:127.0.0.1, qufu:49ip:127.0.0.1, qufu:57ip:127.0.0.1, qufu:65ip:127.0.0.1, qufu:67ip:127.0.0.1, qufu:69ip:127.0.0.1, qufu:1ip:127.0.0.1, qufu:2 十一. 循环获取文件或者命令输出的内容 循环获取文件或者命令输出的内容 for i in 默认 以空白分割 循环获取每个元素 while read 每次获取整行 while read的参数 可以接任意个，默认还是以空白分割 如果参数没有对应获取的值，那参数就为空 如果文件中空白分割的参数大于read接受的参数，那多出的参数都会赋给最后一个read接受的参数 1管道 进制之间通信的一种方式 十二. shell中的一维数组 shell中的一维数组 shell中的一维数组 使用 定义：使用圆括号，中间以 空格 作为分隔符 博客连接：https://www.cnblogs.com/tangshengwei/p/5446315.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273示例14.1：定义、索取--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# a=(xx yy zz) # 注：a 是一个数组[root@sanchuang-linux ~]# a=(xx yy zz ff) # 注：a 是一个数组[root@sanchuang-linux ~]# echo $&#123;a[0]&#125; # 注：通过索引查找，下标从0开始xx[root@sanchuang-linux ~]# echo $&#123;a[1]&#125; # 注：通过索引查找yy[root@sanchuang-linux ~]# echo $&#123;a[3]&#125;ff[root@sanchuang-linux ~]# echo $&#123;a[@]&#125; # 注：$&#123;a[@]&#125; 表示它里面的每一个数，@ 取它里面的全部值xx yy zz ff # 注：$@ 参数列表里面的全部内容[root@sanchuang-linux ~]# echo $&#123;a[@]:1:4&#125; # 注：索取（切片）yy zz ff--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# a=(xx yy zz ff)[root@sanchuang-linux ~]# echo $a # 注：echo $a 只取出一位数组里的第一个元素xx[root@sanchuang-linux ~]# echo $&#123;a[*]&#125; # 注：$&#123;a[*]&#125; 取出一位数组里面的全部内容，效果一样xx yy zz ff[root@sanchuang-linux ~]# echo $&#123;a[@]&#125; # 注：$&#123;a[@]&#125; 取出一位数组里面的全部内容xx yy zz ff[root@sanchuang-linux ~]# echo $&#123;a:0:4&#125; # 注：对字符 xx 进行截取 从0开始xx[root@sanchuang-linux ~]# echo $&#123;a:1:4&#125; # 注：对字符 xx 进行截取 从1开始x[root@sanchuang-linux ~]# echo $&#123;a[*]:1:3&#125; # 注：索取，效果一样（切片）yy zz ff--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# a=(1 2 3 4)[root@sanchuang-linux ~]# echo $&#123;a[*]:1:3&#125; # 注：索取，闭区间（切片）2 3 4============================================================================================获取长度（元素个数）#注：$# 获取参数列表长度# echo $&#123;#a[*]&#125;# echo $&#123;#a[@]&#125;示例14.2：获取一位数组长度（元素个数）--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# echo $&#123;#a[*]&#125; # 注：不能用$a直接获取，因为 $a 代表 里面第一个元素4[root@sanchuang-linux ~]# echo $&#123;#a[@]&#125;4[root@sanchuang-linux ~]# echo $&#123;#a&#125; # 注：第一个元素长度2###########################################################################################示例14.3：获取字符串长度 echo $&#123;#b&#125;[root@sanchuang-linux ~]# b=abc[root@sanchuang-linux ~]# echo $&#123;#b&#125;3============================================================================================修改/删除 元素（shell里面一维数组的修改/删除）示例14.4：修改/删除 元素[root@sanchuang-linux ~]# echo $&#123;a[*]&#125;xx yy zz ff[root@sanchuang-linux ~]# a[3]=&quot;hh&quot; # 注：修改元素[root@sanchuang-linux ~]# echo $&#123;a[*]&#125;xx yy zz hh # 注：清空数组 unset a[root@sanchuang-linux ~]# unset a[3] # 注：删除指定元素(下标为3)[root@sanchuang-linux ~]# echo $&#123;a[*]&#125;xx yy zz--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# echo $&#123;a[*]&#125;xx zz[root@sanchuang-linux ~]# unset a[1] # 注：删除不了[root@sanchuang-linux ~]# echo $&#123;a[*]&#125;xx zz[root@sanchuang-linux ~]# echo $&#123;!a[*]&#125; # 注：加！ 看元素的下标0 2 # 注：删除后，不会重新分配下标。一开始每个值的下标都一一对应了，不会改[root@sanchuang-linux ~]# unset a[2] # 注：删除zz元素，unset a[2]，下标为2[root@sanchuang-linux ~]# echo $&#123;a[*]&#125;xx[root@sanchuang-linux ~]# 十三. linux里 生成随机数 linux里 生成随机数 1234567891011121314151617示例--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# echo $RANDOM # 注：自定义的环境变量15386[root@sanchuang-linux ~]# echo $RANDOM 24960############################################################################################知识点15.2 生成指定范围内的随机数示例1：产生10以内的随机数（不含10）[root@sanchuang-linux ~]# echo $(($RANDOM % 10)) 1[root@sanchuang-linux ~]# echo $(($RANDOM % 10)) 8[root@sanchuang-linux ~]# echo $(($RANDOM % 10)) 2[root@sanchuang-linux ~]# echo $(($RANDOM % 10)) 3 十四. 练习：编写一个随机抽取同学唱歌的程序，如果唱过了，就不能再次被抽到了 编写一个随机抽取同学唱歌的程序，如果唱过了，就不能再次被抽到了 1、编写一个文件，里面存放我们歌手的名字 name.txt 2、随机抽取歌手 # 1.循环抽取 2.抽到了就丢掉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748============================================================================================#注：使用命令的输出 用``反引号#注：把读到的人员名单变成一个数组示例--------------------------------------------------------------------------------------------[root@sanchuang-linux chenpeng]# vim geshou_test.sh#!/bin/bash# 将name.txt的内容读取出来 # 注：反引号` ` 把cat命令的输出放到数组里singers=(`cat name.txt`) # 注：把读取的内容放到数组里面（cat读取）echo $&#123;singers[@]&#125; # 注：验证是否取出数据 # 注：相对路径 指当前下的文件# 有多少人total=$&#123;#singers[@]&#125; # 首先 获取人数（对singers长度进行统计）for i in `seq $total` # 然后循环（for 循环次数，$total 人数进行循环）do # 注：反引号` ` 命令去执行它 read -p &quot;请输入任意键进行抽取&quot; # 注：read 目的：敲一下键盘 才会接着循环 # 随机抽取一个人演唱 # 每次循环都是抽取 新的 列表里面的人数（因为下标问题） random_num=$(( $RANDOM % $&#123;#singers[*]&#125; )) #注：生成随机数，范围0 ~ 一维数组长度 echo &quot;随机数为：$random_num&quot; # 注：随机抽取索引/下标 echo &quot;有请$&#123;singers[$random_num]&#125;献唱一首！大家热烈欢迎！&quot; unset singers[$random_num] # 注：把选中的人删除（与python不同的是，删除以后下标不变） singers=(`echo $&#123;singers[@]&#125;`) # 注：解决办法 重新赋值,赋值给一个新的一维数组 echo &quot;未献唱者具体名单为： $&#123;singers[@]&#125;&quot; # 注：↑也可以使用 singers=($&#123;singers[@]&#125;)done # 注：↑也可以使用singers= `echo $&#123;singers[@]&#125;`[root@sanchuang-linux chenpeng]# cat name.txt # 注：↑重新赋值后 下标会变 从0~总长度fengchengzhanghuayoupengyifanchenpengxulilintangliangfeiwangtianchenglixinhailiangluyao--------------------------------------------------------------------------------------------演示[root@sanchuang-linux chenpeng]# sh geshou_test.sh fengcheng zhanghuayou pengyifan chenpeng xulilin tangliangfei wangtiancheng lixinhai liangluyao请输入任意键进行抽取随机数为：2有请pengyifan献唱一首！大家热烈欢迎！未献唱者具体名单为： fengcheng zhanghuayou chenpeng xulilin tangliangfei wangtiancheng lixinhai liangluyao请输入任意键进行抽取随机数为：2有请chenpeng献唱一首！大家热烈欢迎！未献唱者具体名单为： fengcheng zhanghuayou xulilin tangliangfei wangtiancheng lixinhai liangluyao#注：获取命令输出的时候 加``反引号 十五. 练习：产生5–10之间随机数 产生5–10之间随机数 123456789101112131415产生5--10之间随机数[root@sanchuang-linux chenpeng]# echo $(( $RANDOM % 10 )) # 注：产生10以内随机数3[root@sanchuang-linux chenpeng]# echo $(( $RANDOM % 5 +5 )) # 注：取5以内的随机数 +56[root@sanchuang-linux chenpeng]# echo $(( $RANDOM % 5 +5 ))8--------------------------------------------------------------------------------------------50--150之间随机数[root@sanchuang-linux chenpeng]# echo $(( $RANDOM % 100 +50 ))79 # 注：100是区间绝对值，50是初始值--------------------------------------------------------------------------------------------150-200之间随机数 # 注：150初始值， 50 + 150 末尾值[root@sanchuang-linux ~]# echo $(( $RANDOM % 50 + 150 )) # 注：150~200之间190 十六. tr（替换命令） tr命令（替换命令） tr命令（主要用来做字符的替换） # 注：对文本处理常用 字符转换工具 只能对stdin操作，不能直接对文件操作 # 注：只能对标准输入进行操作 ---------------------------------------------------- 使用tr转换字符 tr SET1 SET2 用SET2中的字符替换掉SET1中同一位置的字符 tr -d 删除指定字符 tr -s 压缩相同字符，将连续的指定字符压缩成一个字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748示例--------------------------------------------------------------------------------------------示例1：替换#注：替换同位置的[root@sanchuang-linux chenpeng]# echo 123456| tr 345 xyz # 注：把345替换成xyz12xyz6 # 注：只能对标准输入进行操作[root@sanchuang-linux chenpeng]# echo 123456| tr 3 xyz # 注：把3替换成xyz12x456 # 注：只替换了x，对应位置的 # 注：有几个位置，替换几个字符 # 注：替换同位置的============================================================================================示例2：删除 # echo 123456| tr -d 34tr -d 删除指定字符[root@sanchuang-linux chenpeng]# echo 123456| tr 3 &quot;&quot; # 注：&quot;&quot; 不能为空，它要替换同位置的tr: 当不截断设置1 时，字符串2 不能为空[root@sanchuang-linux chenpeng]# echo 123456| tr -d 34 # 注：删除接tr -d1256============================================================================================tr -s 压缩相同字符，将连续的指定字符压缩成一个字符将连续的指定字符压缩成一个字符示例3：tr -s 压缩相同字符[root@sanchuang-linux chenpeng]# echo 111223333444445556666| tr -s 3411122345556666 # 注：当有连续的时候压缩成一个[root@sanchuang-linux chenpeng]# echo 11122333344444555666633377744| tr -s 341112234555666637774 # 注：并不是去重============================================================================================练习4：把环境变量里 : 替换成空格 # 注：关键点 tr不能替换文件内容[root@sanchuang-linux chenpeng]# echo $PATH |tr &quot;:&quot; &quot; &quot; # 注：关键点 tr接收的是标准输入/lianxi/sc /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /root/bin /usr/local/nginx/sbin /root/bin /usr/local/nginx5/sbin /root/bin============================================================================================扩展5：替换文件里的内容，生成一个新文件#注：把文件导进来 进行标准输入示例：将/etc/passwd里的 ：替换成空格--------------------------------------------------------------------------------------------写法1：cat导入[root@sanchuang-linux chenpeng]# cat /etc/passwd |tr &quot;:&quot; &quot; &quot; &gt;/tmp/passwd[root@sanchuang-linux chenpeng]# less /tmp/passwd # 注：：全变空格了写法2：tr接收标准输入 重定向标准输入 tr &quot;:&quot; &quot; &quot; &lt;/etc/passwd[root@sanchuang-linux chenpeng]# tr &quot;:&quot; &quot; &quot; &lt;/etc/passwd &gt;/tmp/passwd2 [root@sanchuang-linux chenpeng]# less /tmp/passwd2 # 注：：全变空格了#注：写法2把一个文件导进来，进行标准输入 tr &quot;:&quot; &quot; &quot; &lt;/etc/passwd============================================================================================扩展5.1 重定向标准输入[root@sanchuang-linux chenpeng]# wc -l /etc/passwd # 注：wc -l 查看文件行数52 /etc/passwd示例：重定向标准输入[root@sanchuang-linux chenpeng]# wc -l &lt; /etc/passwd52","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://blog1.cpen.top/tags/Shell/"}]},{"title":"10_Linux基础-SHELL入门1","slug":"Linux_基础/10_Linux基础-SHELL入门1","date":"2022-09-07T04:00:00.000Z","updated":"2022-09-07T05:00:00.000Z","comments":true,"path":"posts/30664.html","permalink":"https://blog1.cpen.top/posts/30664.html","excerpt":"","text":"一. 输入输出重定向 回顾1 输入输出重定向 输入 read -p “请输入” a -p 提示 a 赋值给a read -s 密码隐藏 输出 ​ echo ​ # echo -e “abc\\t abc” 转义字符输出 ​ abc abc ​ # echo “abc\\t abc” ​ abc\\t abc echo -n 不接换行 echo -e 转义字符输出 二. 2个特殊文件 知识点2 2个特殊文件 两个特殊文件 ·/dev/null：过滤标准错误信息 ·/dev/zero：用来创建指定长度文件 /dev/null：黑洞文件，不保存，不输出的信息，就丢到黑洞文件 /dev/zero：用来生成指定大小的文件，生成一堆0 示例：/dev/zero：用来生成指定大小的文件，生成一堆0 /dev/zero一般用作生成指定大小的文件，做测试用 dd是一个备份命令，也可以产生一个指定大小的文件 if 输入文件 input file of 输出文件 output file bs 输出的数据的单位大小 count 输出的数据单位数量 示例：_______________________________________________________ 1234567[root@sanchuang-linux dev]# dd if=/dev/zero of=/tmp/test.dd bs=1M count=5记录了5+0 的读入记录了5+0 的写出5242880 bytes (5.2 MB, 5.0 MiB) copied, 0.00196718 s, 2.7 GB/s[root@sanchuang-linux dev]# du -sh /tmp/test.dd 5.0M /tmp/test.ddif 从哪里导进来 ， of 导出去这个文件 ， bs 数据单位大小 ， count数据单位数量 三. here document 知识点3 here document here document 文档就在这里 &lt;&lt; 生成一个指定内容的文档。 简单脚本中使用 示例： ----------------------------------------------------------- [root@sanchuang-linux chenpeng]# cat &gt;here_test.txt &lt;&lt;EOF &gt; nihao &gt; sanchuang &gt; huanying &gt; world… &gt; x y z \\&gt; EOF [root@sanchuang-linux chenpeng]# cat here_test.txt nihao sanchuang huanying world… x y z 知识点3.2 EOF是文档结束标志 可以自行定义 （end of file） 示例： ------------------------------------------------------ [root@sanchuang-linux chenpeng]# cat &gt;here_test &lt;&lt;XYZ &gt; nihao &gt; hello world &gt; XYZ [root@sanchuang-linux chenpeng]# cat here_test nihao hello world 四. tee命令 知识点4 tee命令 tee命令 输出到屏幕也重定向到文件 示例： ---------------------------------- [root@sanchuang-linux chenpeng]# echo “aa” &gt;test_aa.txt #（注：默认不输出到屏幕） [root@sanchuang-linux chenpeng]# cat test_aa.txt aa [root@sanchuang-linux chenpeng]# echo &quot;bb&quot; |tee test_bb.txt #（注：屏幕+文件） bb [root@sanchuang-linux chenpeng]# cat test_bb.txt bb 五. 清空文件内容 知识点5 清空文件内容 [root@sanchuang-linux chenpeng]# &gt;test_bb.txt [root@sanchuang-linux chenpeng]# echo &gt; test_bb.txt #（注：有换行） [root@sanchuang-linux chenpeng]# cat test_bb.txt [root@sanchuang-linux chenpeng]# echo -n &gt; test_bb.txt [root@sanchuang-linux chenpeng]# cat test_bb.txt [root@sanchuang-linux chenpeng]# :&gt;test_bb.txt [root@sanchuang-linux chenpeng]# cat test_bb.txt 知识点6 echo echo 在屏幕上显示一段文字或指定内容 输出变量，输出指定内容 -e 选项 转义字符输出 -n 选项 不接换行 六. SHELL入门 shell入门 shell 是一个用C语言写的程序，它是用户使用linux的桥梁 shell 脚本 实现自动化 重复性的操作编写脚本完成，减少人工失误 SHELL的变量 shell的变量 1、局部变量 定义在脚本或命令中 2、环境变量 shell启动的程序能访问到的环境变量 env、 echo $PATH 3、shell变量 123456789101112示例：环境变量------------------------------------------[root@sanchuang-linux chenpeng]# which lsalias ls=&#x27;ls --color=auto&#x27; /usr/bin/ls #（注：环境变量）[root@sanchuang-linux chenpeng]# echo $PATH #（注：环境变量）/lianxi/sc:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/nginx/sbin:/root/bin:/usr/local/nginx5/sbin:/root/bin示例2：局部变量-------------------------------------------a=1echo $aecho $&#123;a&#125; 知识点8.2 变量名命名规则 变量名命名规则： 由数字、字母、下划线组合，不能以数字开头 不能使用bash中的关键字 使用一个定义过的变量，需要在前面加上$符号 1234示例：--------------------------------------------[root@sanchuang-linux chenpeng]# echo $PATH #（注：环境变量）/lianxi/sc:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/nginx/sbin:/root/bin:/usr/local/nginx5/sbin:/root/bin SHELL接收参数 知识点9 shell接收参数 shell接收 位置变量 ：$1 - $9 ，分别代表参数列表中的 第1 - 9 个参数 可以重复使用（即脚本里可以出现两个$1） 预定义变量，系统预留的一些变量： $0 当前进程 或者 脚本名称 $! 后台运行的最后一个进程的pid号 $? 上一条命令程序返回值 $* 代表所有参数内容 $$ 表示当前进程pid号 $# 表示参数个数 $@ 代表所有参数（逐个提取） # perror 1 查看命令的返回值，并且看返回值的具体含义 $? 命令返回值为0 表示正常执行 ​ 不为0 都表示运行错误 12345示例如下：__________________________________[root@mysql-binary shell_test]# echo $?1[root@mysql-binary shell_test]# perror 1OS error code 1: Operation not permitted #!/bin/bash 脚本前最好加上这一行，默认使用什么解释器去执行 原因：类unix操作系统，unbuntu、debian、centos每个操作系统的默认bash可能不一样 示例1：位置变量$1、$2 __________________________________ [root@sanchuang-linux shell_test]# cat canshu.sh #!/bin/bash echo “########这是$1########” #（注：位置变量） echo “$1” #（注：位置变量） echo “########这是$2########” #（注：位置变量） echo “$2” #（注：位置变量） [root@sanchuang-linux shell_test]# sh canshu.sh &quot;hello&quot; &quot;world&quot; #（注：传了2个参数） ########这是hello######## #（注：参数1） hello ########这是world######## #（注：参数2） world 示例2：预定义变量 $0__________________________________________________________ 1234567891011121314151617[root@sanchuang-linux shell_test]# echo $0 #（注：$0 当前进程 或者 脚本名称）-bash[root@sanchuang-linux shell_test]# sh canshu.sh &quot;hello&quot; &quot;world&quot;########这是hello########hello########这是world########worldcanshu.sh #（注：$0 当前进程 或者 脚本名称）[root@sanchuang-linux shell_test]# cat canshu.sh #!/bin/bashecho &quot;########这是$1########&quot;echo &quot;$1&quot;echo &quot;########这是$2########&quot;echo &quot;$2&quot;echo &quot;$0&quot; 示例3：预定义变量 $* $# $@_____________________ 12345678910111213141516171819202122[root@sanchuang-linux shell_test]# vim canshu.sh#!/bin/bashecho &quot;########这是$1########&quot;echo &quot;$1&quot;echo &quot;########这是$2########&quot;echo &quot;$2&quot;echo &quot;$0&quot;echo &quot;这是所有:$*&quot; #（注：$* 代表所有参数内容）echo &quot;参数#：$#&quot; #（注：$# 表示参数个数）echo &quot;这是@：$@&quot; #（注：$@ 代表所有参数（逐个提取））──────────────────────────────────────────────[root@sanchuang-linux shell_test]# sh canshu.sh hello world 2020 #（注：3个参数）########这是hello########hello########这是world########worldcanshu.sh这是所有:hello world 2020参数#：3这是@：hello world 2020 知识点10 python中接收参数 sys模块 python中 sys模块里面的argv属性。python后面 传过来的参数是一个列表，然后获取第一个第二个 123456789[root@sanchuang-linux ~]# vim canshu.pyimport sysprint(sys.argv[1],sys.argv[2]) #（注：1接收参数1，2接收参数2）print(sys.argv[0]) #（注：0是文件名）----------------------------------------------------------------------[root@sanchuang-linux ~]# python3 canshu.py &quot;hello&quot; &quot;world&quot;hello worldcanshu.py 数据类型 知识点11 数据类型 shell常用数字、字符串、数组 字符串的定义，可以使用单引号，也可以使用双引号，也可以不用引号 12345678910111213141516示例：字符串的定义__________________[root@sanchuang-linux ~]# echo abcabc[root@sanchuang-linux ~]# a=b[root@sanchuang-linux ~]# echo $ab[root@sanchuang-linux ~]# a=&quot;b&quot;[root@sanchuang-linux ~]# echo $ab[root@sanchuang-linux ~]# a=&#x27;b&#x27;[root@sanchuang-linux ~]# echo $ab示例：数字的定义_________________[root@sanchuang-linux ~]# a=1[root@sanchuang-linux ~]# a=2 引号区别 知识点12 引号区别：双引号可以识别变量，单引号不可以识别变量 引号区别：双引号可以识别变量，单引号不可以 1234[root@sanchuang-linux ~]# head -n1 /etc/passwd #（注：输出passwd第一条）root:x:0:0:root:/root:/bin/bash[root@sanchuang-linux ~]# cat /etc/passwd |head -n1 #（注：不建议用这个 2条命令）root:x:0:0:root:/root:/bin/bash 12345678#!/bin/bash# 字符串操作line=`head -n1 /etc/passwd` #（注：使用反引号``）（注：把命令输出保存在line里面）echo $line---------------------------------------------------------------------------------[root@sanchuang-linux chenpeng]# bash test2.sh root:x:0:0:root:/root:/bin/bash 示例：双引号可以识别变量，单引号不可以识别变量_____________________________ 12345echo &quot;字符串为：$line&quot;字符串为：root:x:0:0:root:/root:/bin/bash------------------------------------------echo &#x27;字符串为：$line&#x27;字符串为：$line 字符串操作 知识点13 字符串操作 123456789截取截取前4个字符：echo $&#123;line:0:4&#125;截取后9个字符 echo $&#123;line:0-9&#125;从倒数第九个字符开始截取4个字符 echo $&#123;line:0-9:4&#125;从左向右截取最后一个：后的字符 echo $&#123;line##*:&#125;从左向右截取第一个：后的字符 echo $&#123;line#*:&#125;从右往左截取最后一个：后的字符 echo $&#123;line%%:*&#125;从右向左截取第一个：后的字符 echo $&#123;line%:*&#125;字符串长度 echo $&#123;#line&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253示例：字符串操作_______________________________# 字符串操作[root@sanchuang-linux chenpeng]# vim test2.shline=`head -n1 /etc/passwd`echo $line #（注：root:x:0:0:root:/root:/bin/bash）echo &quot;字符串为：$line&quot; #（注：字符串为：root:x:0:0:root:/root:/bin/bash）echo &#x27;字符串为：$line&#x27; #（注：字符串为：$line）echo &quot;截取前4个字符：&quot;echo $&#123;line:0:4&#125; #（注：root）echo &quot;截取后9个字符&quot;echo $&#123;line:0-9&#125; #（注：/bin/bash）echo &quot;从倒数第九个字符开始截取4个字符&quot;echo $&#123;line:0-9:4&#125; #（注：/bin）echo &quot;从左向右截取最后一个：后的字符&quot;echo $&#123;line##*:&#125; #（注：/bin/bash）echo &quot;从左向右截取第一个：后的字符&quot;echo $&#123;line#*:&#125; #（注：x:0:0:root:/root:/bin/bash）echo &quot;从右往左截取最后一个：后的字符&quot;echo $&#123;line%%:*&#125; #（注：root）echo &quot;从右向左截取第一个：后的字符&quot;echo $&#123;line%:*&#125; #（注：root:x:0:0:root:/root）echo &quot;字符串长度&quot;echo $&#123;#line&#125; #（注：31）-----------------------------------------------[root@sanchuang-linux chenpeng]# bash test2.sh root:x:0:0:root:/root:/bin/bash字符串为：root:x:0:0:root:/root:/bin/bash字符串为：$line截取前4个字符：root截取后9个字符/bin/bash从倒数第九个字符开始截取4个字符/bin从左向右截取最后一个：后的字符/bin/bash从左向右截取第一个：后的字符x:0:0:root:/root:/bin/bash从右往左截取最后一个：后的字符root从右向左截取第一个：后的字符root:x:0:0:root:/root字符串长度31 练习13 截取百度网址 1234567891011121314line=&quot;http://www.baidu.com/login&quot;# 截取出：loginecho $&#123;line:0-5&#125; #（注：取最后5个字符）echo $&#123;line##*/&#125; #（注：从左往右最后一个/后的内容）# 截取出：www.baidu.com/loginecho $&#123;line##*//&#125;# 截取出：http://www.baidu.comecho $&#123;line%/*&#125;# 截取出：http:echo $&#123;line%%/*&#125; 数值的运算与比较 知识点14 数值的运算与比较 数值的运算： 第一种： $(( 表达式 )) 第二种： $[ 表达式 ] 第三种： expr 表达式 注意表达式运算符左右空格 12345678910111213示例：↓↓↓↓↓↓↓↓↓↓↓↓↓↓[root@sanchuang-linux ~]# a=10[root@sanchuang-linux ~]# b=20[root@sanchuang-linux ~]# $(($a + $b))-bash: 30: 未找到命令[root@sanchuang-linux ~]# echo $(($a + $b))30[root@sanchuang-linux ~]# echo $[ $a +$b ]30[root@sanchuang-linux ~]# expr $a + $b30[root@sanchuang-linux ~]# expr $a+$b10+20 SHELL结构语句，循环和判断 知识点15 shell结构语句，循环和判断 知识点15.1 for循环 for循环 1234567891011121314语法1：↓↓↓↓↓↓↓↓-----------------------for 变量 in 值1 值2do 循环执行语句done=======================================语法2：↓↓↓↓↓↓↓---------------------------------------# for ((i=0;i&lt;3;i++))for ((初始化变量; 结束循环的条件; 运算))do 循环执行的语句done 知识点15.2 while循环 While循环 123456789101112131415语法1：↓↓↓↓↓---------------------------------------while read linedo 循环执行语句done=======================================语法2↓↓↓↓↓↓↓↓↓---------------------------------------while [条件(非必选)]:do 循环执行语句done=======================================注：也支持break，continue 知识点15 判断 知识点15.3 if语句 if语句 123456789101112131415161718192021222324语法1：↓↓↓↓↓-------------------------if 条件then 执行语句fi=========================语法2:↓↓↓↓↓if 条件then 执行语句else 执行语句fi==========================语法3：↓↓↓↓↓↓----------------------if [ command ];then符合该条件执行的语句elif [ command ];then符合该条件执行的语句else符合该条件执行的语句fi 知识点15.4 case语句 case语句 12345678910语法：↓↓↓↓↓________________case $变量名 in条件1) 执行语句一 ;;条件2) 执行语句二 ;;*）esac 练习16 编写一个shell脚本 接收用户输入的两个数，然后选择要对着两个数进行什么计算，并且输出结果 实现菜单选择 ================ add 加法 sub 减法 mul 乘法 exit 退出 ================ 注：菜单选择用case、服务重启脚本用case 12345678910111213141516171819202122232425262728293031323334353637383940示例：↓↓↓↓↓↓↓↓↓_________________________[root@sanchuang-linux chenpeng]# vim num_test.sh#!/bin/bashread -p &quot;请输入数字一：&quot; num1read -p &quot;请输入数字二：&quot; num2echo &quot;================&quot;echo &quot;1.add 加法&quot;echo &quot;2.sub 减法&quot;echo &quot;3.mul 乘法&quot;echo &quot;4.exit 退出&quot;echo &quot;================&quot;read -p &quot;请输入你的选择：&quot; optionscase $options in1) echo &quot;两数相加为：$(($num1 + $num2))&quot; ;;2) echo &quot;两数相减为：$(($num1 - $num2))&quot; ;;3) echo &quot;两数相乘为：$(($num1 * $num2))&quot; ;;4) echo &quot;退出！&quot; exitesac-------------------------------------------------------------------------------------------整成函数形式add()&#123; echo &quot;两数相加为：$(($num1 + $num2))&quot;&#125;case $options in1) add #（注：需要使用的时候调用） ;;2)………………………… /etc/init.d 服务的启动脚本 知识点17 /etc/init.d 服务的启动脚本 /etc/init.d/ 放着服务的启动脚本 123[root@sanchuang-linux chenpeng]# cd /etc/init.d/ [root@sanchuang-linux init.d]# ls functions README 12345678910111213141516示例：服务重启脚本用case↓↓↓↓↓__________________case $mode in start) 启动 ;; stop) 关闭(使用kill命令) ;; restart) 关闭 启动 ;; reload) 重新加载配置（使用kill -HUP） ;;esac kill 知识点18 kill 123456789101112kill 用来删除正在执行中的程序或者工作kill 可以将指定的信息发送给程序# kill -l 可以查看kill信号量 （kill -L(小写)）# kill -0 用来检测进程是否存在，当进程不存在时,kill -0 会报错# kill -1 pid 重新加载进程（常用）# kill -HUP pid 和 kill -1 pid是一样的# kill -1 pid 或者 kill -HUP pid 都表示重新加载这个文件# kill -9 强制杀死# kill -15 正常停止一个进程kill 不接信号量的时候，默认为信号15除了9号信号，其他信号进程都有权利拒绝执行！ 注：重新加载 相当于 加载最新的配置 服务还是正常运行的（连接不会断） ​ 重启 服务会断 123456示例：↓↓↓↓↓↓↓↓↓____________[root@sanchuang-linux ~]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1…………………………63) SIGRTMAX-1 64) SIGRTMAX SHELL编程 if判断 知识点19 shell编程 if判断 if 判断 123456789101112示例：↓↓↓↓↓↓____________________________________________________________[root@sanchuang-linux ~]# if id wenyao; then echo &quot;ok&quot;; else echo &quot;error&quot;; fiid: “wenyao”：无此用户error--------------------------------------------------------等同于：↓↓↓↓↓________________________________________________if id wenyao; then echo &quot;ok&quot;; else echo &quot;error&quot;; fi [ ] 知识点20 [ ] [ ]表示条件测试 注意这里的空格很重要。要注意在’[‘后面和’]'前面都必须要有空格。 12345678910111213141516171819202122232425262728常用判断：[ -d FILE ] 如果 FILE 存在且是一个目录则返回为真。[ -f FILE ] 如果 FILE 存在且是一个普通文件则返回为真。[ -e **** ] 判断文件/文件夹是否存在字符串判断：[ -z STRING ] 如果STRING的长度为零则返回为真，即空是真[ -n STRING ] 如果STRING的长度非零则返回为真，即非空是真[ STRING1 ] 如果字符串不为空则返回为真,与-n类似[ STRING1 == STRING2 ] 如果两个字符串相同则返回为真[ STRING1 != STRING2 ] 如果字符串不相同则返回为真[ STRING1 &lt; STRING2 ] 如果 “STRING1”字典排序在“STRING2”前面则返回为真。[ STRING1 &gt; STRING2 ] 如果 “STRING1”字典排序在“STRING2”后面则返回为真。数值判断[ INT1 -eq INT2 ] INT1和INT2两数相等返回为真 ,=[ INT1 -ne INT2 ] INT1和INT2两数不等返回为真 ,&lt;&gt;[ INT1 -gt INT2 ] INT1大于INT2返回为真 ,&gt;[ INT1 -ge INT2 ] INT1大于等于INT2返回为真,&gt;=[ INT1 -lt INT2 ] INT1小于INT2返回为真 ,&lt;[ INT1 -le INT2 ] INT1小于等于INT2返回为真,&lt;=逻辑判断[ ! EXPR ] 逻辑非，如果 EXPR 是false则返回为真。[ EXPR1 -a EXPR2 ] 逻辑与，如果 EXPR1 and EXPR2 全真则返回为真。[ EXPR1 -o EXPR2 ] 逻辑或，如果 EXPR1 或者 EXPR2 为真则返回为真。[ ] || [ ] 用OR来合并两个条件[ ] &amp;&amp; [ ] 用AND来合并两个条件 123456789101112示例：↓↓↓↓↓↓↓↓↓↓↓↓↓[root@sanchuang-linux ~]# a=10[root@sanchuang-linux ~]# b=20[root@sanchuang-linux ~]# if [ $a -gt $b ];then echo &quot;a&gt;b&quot;;else echo &quot;a&lt;b&quot;;fi #（注：正确）a&lt;b[root@sanchuang-linux ~]# if [ $a &gt; $b ];then echo &quot;a&gt;b&quot;;else echo &quot;a&lt;b&quot;;fi #（注：出错）a&gt;b （注：使用2个中括号不出错）[root@sanchuang-linux ~]# if [[ $a &gt; $b ]];then echo &quot;a&gt;b&quot;;else echo &quot;a&lt;b&quot;;fi #（注：正确）a&lt;b[root@sanchuang-linux ~]# if [ $a -gt $b ] &amp;&amp; [ $a -ne 20 ];then echo &quot;输出a&gt;b&quot;;else echo &quot;输出a&lt;b&quot;;fi输出a&lt;b 练习21 判断当前目录下是否存在文件a，没有的话就创建 有的话输出，输出文件已存在 12345678910示例：↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓写法1：if [ -f a.txt ]; then echo &quot;文件存在&quot;else touch a.txtfi-------------------------------------------------写法2：推荐（类似python的if三元运算符）[ -f a.txt ] &amp;&amp; echo &quot;文件已存在&quot; || touch a.txt 示例2： 编写一个脚本，实现如下功能 ============== 1.增加用户并设置密码 2.删除用户 3.查看用户 4.退出 ============== 输入的指定不是1-4，给提示给予提醒，并且如果不输入退出的话，可以循环添加。 按1 增加用户，并且设置密码 useradd passwd 按2 删除用户 userdel -r 按3 查看用户 id 按4 退出 exit &amp;&amp; || 知识点22 类似python的if三元运算符 使用&amp;&amp; || 来实现 ·cmd1 &amp;&amp; cmd2 如果cmd1执行成 功，或者为真，则执行cmd2 ·cmd1 || cmd2 如果cmd1执行不成功，或者为假，则执行cmd2 ·cmd1 &amp;&amp; cmd2 || cmd3 如果cmd1执行成功，就执行cmd2，不成功就执行cmd3 12345678910111213示例：上个练习↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓[ -f a.txt ] &amp;&amp; echo &quot;文件已存在&quot; || touch a.txt[[ -f a.txt ]] &amp;&amp; echo &quot;文件已存在&quot; || touch a.txt #（注：推荐使用两个中括号）示例：-------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# a=10[root@sanchuang-linux ~]# b=20[root@sanchuang-linux ~]# [ $a -gt $b ] &amp;&amp; echo &quot;输出 a&gt;b&quot;[root@sanchuang-linux ~]# [ $a -gt $b ] || echo &quot;输出 a&lt;b&quot;输出 a&lt;b[root@sanchuang-linux ~]# [ $a -gt $b ] &amp;&amp; echo &quot;输出 a&gt;b&quot; || echo &quot;输出 a&lt;b&quot;输出 a&lt;b [] 、[[]]、 (()) (判断方式) 知识点23 [] 、[[]]、 (()) (判断方式) 会做单词拆分 很多表示都不是很支持，建议使用[[ ]]判断（2个中括号） 总结： ·建议使用[[ ]]来比较运算，进行判断 ·字符串用[[ ]] （推荐） ·数字用比较用(( )) 结论：建议使用[[ ]]来比较运算，进行判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667示例1：if判断时-------------------------------------------------------------------------------------------[root@sanchuang-linux chenpeng]# name=&quot;wen yao&quot;[root@sanchuang-linux chenpeng]# [ $name == &quot;wen yao&quot; ] &amp;&amp; echo &quot;ok&quot; || echo &quot;error&quot;-bash: [: 参数太多 #（注：自动做单词拆分）error[root@sanchuang-linux chenpeng]# [[ $name == &quot;wen yao&quot; ]] &amp;&amp; echo &quot;ok&quot; || echo &quot;error&quot;ok #（注：推荐使用2个中括号）[root@sanchuang-linux chenpeng]# [ &quot;$name&quot; == &quot;wen yao&quot; ] &amp;&amp; echo &quot;ok&quot; || echo &quot;error&quot;ok #（注：使用引号连接在一起，表示一个整体）============================================================================================示例2：数值比较-------------------------------------------------------------------------------------------[root@mysql-binary shell_test]# echo $a10[root@mysql-binary shell_test]# echo $b20[root@mysql-binary shell_test]# [[ $a &gt; $b ]] &amp;&amp; echo &quot;ok&quot; || echo &quot;error&quot;error[root@mysql-binary shell_test]# [ $a &gt; $b ] &amp;&amp; echo &quot;ok&quot; || echo &quot;error&quot;ok #（注：出错）[root@mysql-binary shell_test]# (( $a == $b )) &amp;&amp; echo &quot;ok&quot; || echo &quot;error&quot; error示例：--------------------------------------------------------------------------------------------[root@mysql-binary shell_test]# a=10[root@mysql-binary shell_test]# b=20[root@mysql-binary shell_test]# [[ $a -eq $b ]] &amp;&amp; echo &quot;ok&quot; || echo &quot;eroor&quot;eroor[root@mysql-binary shell_test]# (( $a -eq $b )) &amp;&amp; echo &quot;ok&quot; || echo &quot;eroor&quot;-bash: ((: 10 -eq 20 : 表达式中有语法错误 （错误符号是 &quot;20 &quot;）Eroor----------------------------------------------------------------------------[root@mysql-binary shell_test]# c=102[root@mysql-binary shell_test]# b=20[root@mysql-binary shell_test]# [[ $c &gt; $b ]] &amp;&amp; echo &quot;ok&quot; || echo &quot;eroor&quot;eroor[root@mysql-binary shell_test]# (( $c &gt; $b )) &amp;&amp; echo &quot;ok&quot; || echo &quot;eroor&quot;ok示例3:if条件判断的2种写法--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# a=10[root@sanchuang-linux ~]# b=20[root@sanchuang-linux ~]# if [[ $a &gt; $b ]]; then echo &quot;ok&quot;; else echo &quot;error&quot;; fierror[root@sanchuang-linux ~]# [[ $a &gt; $b ]] &amp;&amp; echo &quot;ok&quot; || echo &quot;error&quot;error示例：字符串比较(( )) 也可以--------------------------------------------------------------------------------------------[root@sanchuang-linux ~]# a=abc[root@sanchuang-linux ~]# b=abc1[root@sanchuang-linux ~]# (( $a &gt; $b )) &amp;&amp; echo &quot;ok&quot; || echo &quot;error&quot;error[root@sanchuang-linux ~]# a=abc[root@sanchuang-linux ~]# b=bac1[root@sanchuang-linux ~]# (( $a &gt; $b )) &amp;&amp; echo &quot;ok&quot; || echo &quot;error&quot;error[root@sanchuang-linux ~]# a=abc[root@sanchuang-linux ~]# b=abc[root@sanchuang-linux ~]# (( $a == $b )) &amp;&amp; echo &quot;ok&quot; || echo &quot;error&quot;ok结论：建议使用[[ ]]来比较运算，进行判断 SHELL函数 定义 知识点24 Shell函数 定义 123456789101112131415161718192021示例：add() &#123; echo &quot;两数相加为：$(( $num1 + $num2 ))&quot; #（注：函数里面的操作内容）&#125;------------------------------------------------调用的时候 addcase $options in 1) add ;;2)……………………--------------------------------------------------------------------------------------------add()&#123; echo &quot;两数相加为：$(($num1 + $num2))&quot;&#125;case $options in1) add #（注：需要使用的时候调用） ;;2)………………………… 判断方式 [] [[]] (()) test 知识点25 判断方式 [] [[]] (()) test (( )) 判断数字 &gt; &lt; == != [[ ]] 判断字符串 或者 -eq -ne -gt -lt 判断数字 是不支持的，建议使用[[ ]] test(测试)判断，等同于1个中括号 12345678示例：test---------------------------------------------------------------------[root@sanchuang-linux ~]# a=123[root@sanchuang-linux ~]# b=123[root@sanchuang-linux ~]# test a==b &amp;&amp; echo okok[root@sanchuang-linux ~]# test a==b &amp;&amp; echo ok || echo errorok","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://blog1.cpen.top/tags/Shell/"}]},{"title":"09_Linux基础-SHELL-标准输入与标准输出-重定向-管道","slug":"Linux_基础/09_Linux基础-SHELL-标准输入与标准输出-重定向-管道","date":"2022-09-06T04:00:00.000Z","updated":"2022-09-06T05:00:00.000Z","comments":true,"path":"posts/5276.html","permalink":"https://blog1.cpen.top/posts/5276.html","excerpt":"","text":"1234567作业 编辑文本文件/home/text/file1，分4行输入bbb bbb bbb、 ddd ddd ddd、aaa aaa aaa、ccc ccc ccc。 保存不要退出； 在末行模式下打开一个新文件/text/file2； 在file2中输入内容为eee eee eee在这一行内容之后， 将file1的内容读入到file2中，接着在命令模式下按照 abcde的显示顺序调整每行的位置，最后保存退出； 同时编辑file1和file2，接着从file1切换到file2，然后 再快速切换回来，接着将file2的内容读到file1内容的末尾，显示文件file1内容的行号，复制3到6行到file1 内容的末尾； 利用替换命令将全文的每行第一个ccc都替换为333； 将全文中所有aaa都替换为111，撤销行号，最后不保 存退出； 123456789101112131415161718[root@sanchuang-linux chenpeng]# mkdir /home/text2[root@sanchuang-linux chenpeng]# cd /home/text2[root@sanchuang-linux chenpeng]# mkdir /text2[root@sanchuang-linux text2]# vim file1:r /text2/file2aaa aaa aaabbb bbb bbbccc ccc cccddd ddd dddeee eee eee[root@sanchuang-linux text2]# vim file1 /text2/file2:n:N:set nu:%s/ccc/333:%s/aaa/111/g:set nonu:q! 1234567891011121314151617181920212223练习1： 1.进入/lianxi目录# cd /lianxi 2.复制/etc/passwd文件到当前目录下，然后使用vim编辑当前目录下的passwd# cp /etc/passwd . # vim passwd 3.显示一下行号:set nu 4.复制第5到10行的内容，粘贴到末尾，删除最后一行的最后一个单词:5 ; 6yy ; G ; p ; dw 5.删除第9行和第10行:9 ; 2dd 6.将root改为gen:%s/root/gen/g 7.删除部分bash字符串:%s/bash//gc 8.快速到达第5行，然后再跳到第1行，再跳到最后一行:5 ; :1 ; G 9.剪切第6-7行，粘贴到末尾:6 ; 2dd ; G ; p 10.退出并且保存:wq 11.复制/etc/hosts文件到当前目录下，将第1列的ip地址复制，然后粘贴到文件的末尾# /etc/hosts . ; # vim hosts ; ctrl+v ; y ; G ;p 一. SHELL-标准输入与标准输出 学习内容：重定向和文件目录高级操作 1234知识要点输入输出重定向管道及相关配套命令 数据提取及过滤文件差异对比和补丁生成及打补丁 标准输入和标准输出 知识点1 标准输入和标准输出 12345678910111213141516171819202122232425262728---------------------------输入输出及重定向每个进程基本都会打开三个文件描述符0： 标准输入（从键盘）1： 标准输出 （输出到屏幕）2： 标准错误输出 （输出到屏幕）类型 设备文件 文件描述符（fd） 默认设备标准输入 /dev/stdin 0 键盘标准正确输出 /dev/stdout 1 显示器标准错误输出 /dev/stderr 2 显示器-------------------------------------------------------标准输入（stdin）和标准输出（stdout）------------------------------------python中 &gt;&gt;&gt;help(print) file=sys.stdout 默认输出到屏幕（标准输出）------------------------------------------------------------------进程：正在进行的程序---------------------键盘 =》 标准输入 =》 终端程序 =》 标准输出 =》显示器 标准错误输出 =》显示器----------------------------------------------------------https://blog.csdn.net/xiaofei0859/article/details/78448493?utm_source=blogxgwz9每个进程基本都会打开三个文件描述符0:标准输入 （从键盘、语音、人脸识别……）1:标准输出 （输出到屏幕）2:标准错误输入（输出到屏幕）---------------------------文件描述符：fd 就是每个进程打开的文件 文件描述符 知识点1.1 文件描述符 123文件描述符：linux内核给每个进程都创造一个文件描述符，这个表里记载了这个进程所打开的所有文件，为了方便进程知道自己打开了哪些文件呢，就给每个文件都进行了标号，这个编号就是文件描述符。此后，所有对文件的操作，就是用该编号。 linux下面一切皆文件 知识点1.2 linux下面一切皆文件 linux下面一切皆文件 disk磁盘 /dev目录下面基本都是块设备文件 123456789101112131415161718192021222324252627282930313233343536373839[root@sanchuang-linux ~]# cd /dev[root@sanchuang-linux dev]# cd disk[root@sanchuang-linux disk]# lsby-id by-label by-partuuid by-path by-uuid[root@sanchuang-linux disk]# cd ..[root@sanchuang-linux dev]# ls -ld sda1brw-rw----. 1 root disk 8, 1 10月 6 17:16 sda1[root@sanchuang-linux dev]# ls -ld sda2brw-rw----. 1 root disk 8, 2 10月 6 17:16 sda2------------------------------------------------[root@sanchuang-linux dev]# cd net[root@sanchuang-linux net]# lstun[root@sanchuang-linux net]# ----------------------------对文件的操作就是对设备的操作----------------------------[root@sanchuang-linux ~]# cd /dev[root@sanchuang-linux dev]# lsstderrstdinStdoutfd……---------------------------------[root@sanchuang-linux ~]# cd /dev[root@sanchuang-linux dev]# cd fd[root@sanchuang-linux fd]# ls0 1 2 255 [root@sanchuang-linux fd]# ls -al总用量 0dr-x------. 2 root root 0 10月 16 10:40 .dr-xr-xr-x. 9 root root 0 10月 16 10:40 ..lrwx------. 1 root root 64 10月 16 10:40 0 -&gt; /dev/pts/6 #（注：链接的意思，快捷方式 指向 /dev/pts/6，标准输入到虚拟终端6）lrwx------. 1 root root 64 10月 16 10:40 1 -&gt; /dev/pts/6 #（注：标准输出到虚拟终端6）lrwx------. 1 root root 64 10月 16 10:40 2 -&gt; /dev/pts/6 #（注：标准错误输出到虚拟终端6）lrwx------. 1 root root 64 10月 16 11:24 255 -&gt; /dev/pts/6[root@sanchuang-linux fd]# --------------------------------------- 虚拟终端pts 真实终端tty 知识点1.3 虚拟终端pts 真实终端tty [root@sanchuang-linux dev]# cd /dev/pts [root@sanchuang-linux pts]# ls 0 1 2 3 4 5 6 ptmx [root@sanchuang-linux pts]# pts是别人连接到服务器的虚拟终端（远程控制）。别人远程连接会创建虚拟终端 pts虚拟终端 12345678-----------------------------------------------------Linux centos登录——》本地的终端shell环境 真实终端xshell连接 ——》虚拟终端--------------------------------tty 本地真实终端[root@sanchuang-linux dev]# cd /dev[root@sanchuang-linux dev]# lstty 查看当前linux登陆的用户情况 知识点1.4 查看当前linux登陆的用户情况 查看当前linux登陆的用户情况 # w [root@sanchuang-linux dev]# w 11:32:52 up 16:23, 4 users, load average: 0.00, 0.00, 0.00 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root tty1 - 0610月20 1:32m 0.60s 0.60s -bash （注：bash环境） root pts/1 192.168.0.26 10:03 25:40 0.21s 0.21s -bash （注：bash环境） root pts/2 10.122.155.164 08:52 2:29m 0.16s 0.13s vim -r a （注：删除环境） root pts/6 192.168.0.26 10:40 4.00s 0.09s 0.01s w （注：输入w命令环境） ----------↓解释---------------------------------------------------------------------------- USER：登录用户 TTY：终端类型 terminal type 面向用户使用的接口 ​ tty1:真实终端 ​ tty1==&gt;直接登录进去 操纵的第一个终端（真实终端） ​ Linux里最多允许6个可以直接登录的终端（即真实终端tty） ​ tty2~tty6 需要的时候使用 ​ Alt+F1 tty1 回到第一个终端 ​ Alt+F2 tty2 回到第二个终端 ​ pts/1:虚拟终端，给别人用的。数量可以有很多个。有远程登录过来的时候，就会创建1个终端 FROM：从哪里来 WHAT：做什么事 load average机器的拼接负载 ------------------------------ [root@sanchuang-linux dev]# w 11:39:04 up 16:29, 4 users, load average: 0.00, 0.00, 0.00 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root tty1 - 0610月20 1:38m 0.60s 0.60s -bash root pts/1 192.168.0.26 10:03 31:52 0.21s 0.21s -bash root pts/2 10.122.155.164 08:52 2:35m 0.16s 0.13s vim -r a root pts/6 192.168.0.26 10:40 0.00s 0.09s 0.00s w [root@sanchuang-linux dev]# date 2020年 10月 16日 星期五 11:39:06 CST load average机器的平均负载 --------------------------- 本地终端（真实终端）的创建、切换 知识点1.5 本地终端（真实终端）的创建、切换 Alt+F2 本地最多能登录6个终端 Alt+F1~F6 切换本地登录的终端（真实终端） ----------------------------------------- Alt+F2、Alt+F6 [root@sanchuang-linux dev]# w 11:42:06 up 16:32, 6 users, load average: 0.00, 0.00, 0.00 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root tty1 - 0610月20 1:41m 0.60s 0.60s -bash root pts/1 192.168.0.26 10:03 34:54 0.21s 0.21s -bash root pts/2 10.122.155.164 08:52 2:38m 0.16s 0.13s vim -r a root pts/6 192.168.0.26 10:40 3.00s 0.09s 0.00s w root tty2 - 11:40 1:50 0.01s 0.01s -bash root tty6 - 11:41 13.00s 0.01s 0.01s -bash 如何拦截虚拟终端 知识点1.6 如何拦截虚拟终端 如何拦截虚拟终端 # kill -9 pid 1234567891011121314151617181920-----------------------------------[root@sanchuang-linux dev]# ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.7 179304 13536 ? Ss 10月15 0:07 /usr/lib/systemd/systemd --switched-root --system --deseroot 1450 0.0 0.2 25588 3996 tty1 Ss+ 10月15 0:00 -bashroot 12692 0.0 0.2 34480 4444 ? Ss 04:49 0:00 tmux……………………………………………………root 13025 0.0 0.2 25588 4048 pts/14 Ss+ 05:14 0:00 -bashroot 13046 0.0 0.2 25588 4032 pts/15 Ss+ 05:14 0:00 -bashroot 13286 0.0 0.2 25588 3940 pts/0 Ss+ 05:28 0:00 -bashroot 13614 0.0 0.2 25588 4016 pts/3 Ss+ 06:23 0:00 -bashroot 13635 0.0 0.2 25588 3956 pts/4 Ss 06:23 0:00 -bashroot 13657 0.0 0.4 48860 8596 pts/4 S+ 06:24 0:00 vim /home/text/file2[root@sanchuang-linux dev]# kill -9 13046 （注：杀死pid号13046的进程）------------------------------------------------------------------------ssh服务 22号端口 有端口肯定有服务起服务一定要有端口端口跟服务挂钩Mysql默认端口3306 查看服务的默认端口 知识点1.7 查看服务的默认端口 怎样查看服务的默认端口 # less /etc/services 查看服务的默认端口 123456# less /etc/servicestcpmux 1/tcp # TCP port service multiplexertcpmux 1/udp # TCP port service multiplexerrje 5/tcp # Remote Job Entryrje 5/udp # Remote Job Entry………… 知识点1.8 传输层协议 TCP、UDP 传输层协议 TCP、UDP 杀死连接 限制连接 知识点1.9 杀死连接 限制连接 杀死连接： ps aux 查看pts的连接pid 然后使用： kill -9 xxx ------------------------- 限制连接： iptables 防火墙 或使用其他ssh相关的限制 ------------------------- /proc目录 知识点2.0 /proc目录 /Proc目录 放一些正在运行的程序 # ls /proc 正在运行的程序 12345[root@sanchuang-linux ssh]# ls /proc………………………………………………（删了很多）11 13657 1450 158 171 186 29 508 632 906 999 fb loadavg self zoneinfo13025 14438 15 168 182 23 40 6 859 982 diskstats kmsg partitions tty………………………………………………（删了很多） 查看进程打开了哪些文件描述符 知识点2.1 查看进程打开了哪些文件描述符 proc/1450/fd 查看进程打开了哪些文件描述符 [root@mysql-binary fd]# ls 0 1 2 255 [root@mysql-binary fd]# pwd /proc/1680/fd 12345678910-----------------------------------------[root@sanchuang-linux ssh]# cd /proc/1450[root@sanchuang-linux 1450]# lsattr comm fd map_files net pagemap schedstat ………………………………（删了很多）[root@sanchuang-linux 1450]# cd fd[root@sanchuang-linux fd]# ls0 1 2 255 3 4[root@sanchuang-linux fd]# pwd/proc/1450/fd 二. 重定向 重定向：改变标准输入、标准输出的方向就是重定向 -------------------------------------------------------------------------------------------- 类型 操作符 用途 重定向标准输出 &gt; 将命令的执行结果输出到指定的文件中，而不是直接显示在屏幕上 ​ &gt;&gt; 将命令执行的结果追加输出到指定文件 重定向标准输入 &lt; 将命令中接收输入的途径由默认的键盘更改 为指定的文件 echo 知识点3.1 echo echo -n 不接换行 echo -e 转义字符输出 12345678910111213[root@sanchuang-linux redirect]# echo &quot;xxx&quot;xxx[root@sanchuang-linux redirect]# echo -n &quot;xxx&quot;xxx[root@sanchuang-linux redirect]#[root@sanchuang-linux redirect]# echo &quot;xx \\n x1x1&quot;xx \\n x1x1[root@sanchuang-linux redirect]# echo -e &quot;xx \\n x1x1&quot;xx x1x1[root@sanchuang-linux redirect]# ---------------------------------echo -n 不接换行echo -e 转义字符输出 重定向（改变原来的输出方式） 知识点3.2 重定向（改变原来的输出方式） 重定向（改变原来的输出方式） [root@sanchuang-linux redirect]# echo &quot;xxx&quot; &gt;file.txt [root@sanchuang-linux redirect]# cat file.txt xxx 脚本运行 标准错误输出、标准正确输出 （显示） 知识点3.3 脚本运行 标准错误输出、标准正确输出 （显示） 脚本一行一行 从上到下执行 [root@sanchuang-linux redirect]# vim test.sh [root@sanchuang-linux redirect]# cat test.sh t date [root@sanchuang-linux redirect]# sh test.sh test.sh:行1: t: 未找到命令 2020年 10月 16日 星期五 14:49:40 CST -------------------------------------------- 注↑：标注错误输出 、正常输出 重定向 知识点3 重定向 重定向：改变标准输入、标准输出的方向就是重定向 -------------------------------------------------------------------------------------------- 类型 操作符 用途 重定向标准输出 &gt; 将命令的执行结果输出到指定的文件中，而不是直接显示在屏幕上 ​ &gt;&gt; 将命令执行的结果追加输出到指定文件 重定向标准输入 &lt; 将命令中接收输入的途径由默认的键盘更改 为指定的文件 -------------------------------------------------------------------------------------------- 操作如下 知识点3.4 # sh test.sh &gt; test_result.txt 标准错误输出不会重定向到文件，正确输出会重定向到文件 [root@sanchuang-linux redirect]# vim test.sh [root@sanchuang-linux redirect]# cat test.sh t date [root@sanchuang-linux redirect]# sh test.sh test.sh:行1: t: 未找到命令 2020年 10月 16日 星期五 14:49:40 CST [root@sanchuang-linux redirect]# sh test.sh &gt; test_result.txt test.sh:行1: t: 未找到命令 （注：标准错误输出显示在屏幕上，不重定向到文件） [root@sanchuang-linux redirect]# cat test_result.txt 2020年 10月 16日 星期五 14:50:32 CST（注：正确输出会重定向到文件） ========================================================= 重定向 &gt; 默认只会重定向标准输出 重定向 标准错误 知识点3 重定向 标准错误 标准错误：通过该设备报告执行出错信息 -------------------------------------------------------------------------------------------- 类型 操作符 重定向标准错误 2&gt; ​ 2&gt;&gt; 重定向标准输出和标准错误到同一个文件 2&gt;&amp;1 或者&gt;&amp;或者 &amp;&gt; 重定向标准输出和标准错误到不同文件 &gt; 文件1 2 &gt;文件2 （没教） -------------------------------------------------------------------------------------------- 操作如下 知识点3.5.1 # sh test.sh 2&gt; test_result.txt # sh test.sh 2&gt; test_result.txt 重定向标准错误 （注：与&gt;效果相反） 正确输出显示在屏幕上，标准错误输出重定向到文件 只输出了错误的 [root@sanchuang-linux redirect]# sh test.sh 2&gt; test_result.txt 2020年 10月 16日 星期五 14:52:33 CST （注：正确输出显示在屏幕上） [root@sanchuang-linux redirect]# cat test_result.txt test.sh:行1: t: 未找到命令 （注：标准错误输出重定向到文件） 知识点3.5.2 # sh test.sh &amp;&gt; test_result.txt # sh test.sh &amp;&gt; test_result.txt 把正确的错误的都重定向到 文件 [root@sanchuang-linux redirect]# sh test.sh &amp;&gt; test_result.txt [root@sanchuang-linux redirect]# cat test_result.txt test.sh:行1: t: 未找到命令 2020年 10月 16日 星期五 14:54:05 CST 与下面效果相同 知识点3.5.3 # sh test.sh &gt; test_result.txt 2&gt;&amp;1 # sh test.sh &gt; test_result.txt 2&gt;&amp;1 把错误输出重定向向到标准输出 [root@sanchuang-linux redirect]# sh test.sh &gt; test_result.txt 2&gt;&amp;1 [root@sanchuang-linux redirect]# cat test_result.txt test.sh:行1: t: 未找到命令 2020年 10月 16日 星期五 14:55:16 CST 两者效果等同 知识点3.5.4 # sh test.sh &gt; test_result.txt 1&gt;&amp;2 # sh test.sh &gt; test_result.txt 1&gt;&amp;2 把标准输出重定向错误输出 *输出到屏幕上 （*注：不重定向到文件） [root@sanchuang-linux redirect]# sh test.sh &gt; test_result.txt 1&gt;&amp;2 test.sh:行1: t: 未找到命令 （注：输出到屏幕上） 2020年 10月 16日 星期五 14:56:19 CST （注：输出到屏幕上） [root@sanchuang-linux redirect]# cat test_result.txt [root@sanchuang-linux redirect]# 使用重定向清空文件的几种方式 知识点3.6 使用重定向清空文件的几种方式 使用重定向清空文件的几种方式： # &gt;stdout_test.txt # echo &gt;stdout_test.txt （注：有空格） # echo &quot;&quot;&gt;stdout_test.txt （注：有空格） # :&gt;stdout_test.txt # echo -n &quot;&quot; &gt; stdout_test.txt 代码如下 -------------------------------------------------------------------------------------------- [root@sanchuang-linux redirect]# vim stdout_test.txt [root@sanchuang-linux redirect]# &gt;stdout_test.txt （注：清空） [root@sanchuang-linux redirect]# cat stdout_test.txt [root@sanchuang-linux redirect]# echo “aaa”&gt; stdout_test.txt [root@sanchuang-linux redirect]# cat stdout_test.txt aaa [root@sanchuang-linux redirect]# echo &gt;stdout_test.txt （注：有空格） [root@sanchuang-linux redirect]# cat stdout_test.txt [root@sanchuang-linux redirect]# echo “aaa”&gt;stdout_test.txt [root@sanchuang-linux redirect]# echo &quot;&quot;&gt;stdout_test.txt （注：有空格） [root@sanchuang-linux redirect]# cat stdout_test.txt [root@sanchuang-linux redirect]# echo “aaa”&gt;stdout_test.txt [root@sanchuang-linux redirect]# :&gt;stdout_test.txt （注：清空） [root@sanchuang-linux redirect]# cat stdout_test.txt [root@sanchuang-linux chenpeng]# echo -n &quot;&quot; &gt; stdout_test.txt （注：清空） [root@sanchuang-linux chenpeng]# cat stdout_test.txt [root@sanchuang-linux chenpeng]# **知识点3.6.1 # echo -n &quot;&quot;&gt;stdout_test.txt ** # echo -n &quot;&quot;&gt;stdout_test.txt echo默认情况会接一个换行符 不想换行 接-n [root@sanchuang-linux redirect]# echo “aaa”&gt;stdout_test.txt [root@sanchuang-linux redirect]# cat stdout_test.txt aaa [root@sanchuang-linux redirect]# echo “”&gt;stdout_test.txt [root@sanchuang-linux redirect]# cat stdout_test.txt （注：有空格） [root@sanchuang-linux redirect]# echo -n &quot;&quot;&gt;stdout_test.txt （注：清空，没有空格） [root@sanchuang-linux redirect]# 重定向 &gt; 与 &gt;&gt; 知识点3.7 重定向 &gt; 与 &gt;&gt; 重定向&gt; 与 &gt;&gt; &gt; 是以覆盖的方式写入 &gt;&gt; 是以追加的方式写入 代码如下 -------------------------------------------------------------------------------------------- [root@sanchuang-linux redirect]# echo &quot;aaa&quot; &gt; stdout_test.txt [root@sanchuang-linux redirect]# cat stdout_test.txt aaa [root@sanchuang-linux redirect]# echo &quot;bb&quot; &gt;&gt; stdout_test.txt [root@sanchuang-linux redirect]# cat stdout_test.txt aaa bb [root@sanchuang-linux redirect]# 重定向标准输入 read输入 知识点3.8 重定向标准输入 read输入 重定向标准输入 read输入 （注：用到了tmux） While 循环 echo “$a $b $c” 123456789101112131415161718192021222324脚本1 3个参数 3个参数[root@sanchuang-linux redirect]# cat abc.shwhile read a b cdo echo &quot;$a $b $c&quot;done &lt; f1.txt[root@sanchuang-linux redirect]# （注：窗口1）──────────────────────────────────────────────[root@sanchuang-linux redirect]# vim f1.txt[root@sanchuang-linux redirect]# cat f1.txtxx yy zzaa bb cc（注：窗口2）──────────────────────────────────────────────[root@sanchuang-linux redirect]# sh abc.shxx yy zzaa bb cc[root@sanchuang-linux redirect]# （注：窗口3） echo “$a -- $b” 1234567891011121314151617181920212223242526脚本2 2个参数 3个参数[root@sanchuang-linux redirect]# vim abc.sh[root@sanchuang-linux redirect]# cat abc.shwhile read a bdo echo &quot;$a -- $b&quot;done &lt; f1.txt[root@sanchuang-linux redirect]#（注：窗口1）──────────────────────────────────────────────[root@sanchuang-linux redirect]# vim f1.txt[root@sanchuang-linux redirect]# cat f1.txt xx yy zzaa bb cc[root@sanchuang-linux redirect]# （注：窗口2）──────────────────────────────────────────────（注：默认空格分割参数，xx 和yy zz）[root@sanchuang-linux redirect]# sh abc.sh xx -- yy zzaa -- bb cc[root@sanchuang-linux redirect]# （注：窗口3） echo “line:$line” 12345678910111213141516171819202122232425脚本3 1个参数 3个参数[root@sanchuang-linux redirect]# vim abc.sh[root@sanchuang-linux redirect]# cat abc.sh while read line do echo &quot;line:$line&quot;done &lt; f1.txt[root@sanchuang-linux redirect]# （注：窗口1）──────────────────────────────────────────────[root@sanchuang-linux redirect]# vim f1.txt[root@sanchuang-linux redirect]# cat f1.txt xx yy zzaa bb cc[root@sanchuang-linux redirect]# （注：窗口2）──────────────────────────────────────────────[root@sanchuang-linux redirect]# sh abc.sh line:xx yy zzline:aa bb cc[root@sanchuang-linux redirect]# （注：窗口3） echo “$a -- $b -- $c -- $d -- $e” 1234567891011121314151617181920212223242526脚本4 5个参数 3个参数[root@sanchuang-linux redirect]# vim abc.sh[root@sanchuang-linux redirect]# cat abc.sh while read a b c d e do echo &quot;$a -- $b -- $c -- $d -- $e&quot;done &lt; f1.txt[root@sanchuang-linux redirect]# （注：窗口1）──────────────────────────────────────────────[root@sanchuang-linux redirect]# vim f1.txt[root@sanchuang-linux redirect]# cat f1.txt xx yy zzaa bb cc[root@sanchuang-linux redirect]# （注：窗口2）──────────────────────────────────────────────[root@sanchuang-linux redirect]# sh abc.sh xx -- yy -- zz -- -- aa -- bb -- cc -- -- [root@sanchuang-linux redirect]# （注：窗口3）================================= 知识点3.9 上课练习 重定向标准输入 read输入 1234567891011121314151617181920212223242526272829[root@sanchuang-linux redirect]# vim student_information.sh[root@sanchuang-linux redirect]# cat student_information.sh echo &quot;========学生信息管理系统===============&quot;while read name sex agedo echo &quot;==姓名：$name, 性别:$sex, 年龄:$age==&quot;done &lt; stu_info.txtecho &quot;========================================&quot;[root@sanchuang-linux redirect]# （注：窗口1 tmux）──────────────────────────────────────────────[root@sanchuang-linux redirect]# cat stu_info.txtwenyao 18 ffengcheng 78 mchenpeng 80 m[root@sanchuang-linux redirect]# （注：窗口2 tmux）──────────────────────────────────────────────[root@sanchuang-linux redirect]# sh student_information.sh ========学生信息管理系统=================姓名：wenyao, 性别:18, 年龄:f====姓名：fengcheng, 性别:78, 年龄:m====姓名：chenpeng, 性别:80, 年龄:m==========================================[root@sanchuang-linux redirect]#（注：窗口3 tmux） 三. SHELL-脚本练习及管道 知识点4.0 接受从键盘的输入 管道符号 脚本 接受从键盘的输入 要求：输入用户名和密码 创建相应的用户 需求分析：接受用户输入 ​ 创建用户 ​ 设置密码 -----相关知识点---------------------------------- 管道符号 | ：上一条命令的输出作为下一条命令的输入 yum list 默认输出到屏幕 yum list | grep tmux yumlist的输出 作为grep tmux命令的输入 123456789101112创建用户 useradd wy[root@sanchuang-linux ~]# useradd wy[root@sanchuang-linux ~]# passwd wy更改用户 wy 的密码 。新的 密码：无效的密码： 密码少于 8 个字符重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。==============================================================重新给用户wy设置密码[root@sanchuang-linux ~]# echo &quot;yyyzzz123&quot; |passwd wy --stdinstdin 标准输入 *4.1 初始脚本1 （注：# passwd在bash中执行时会在中间停止，让用户进行输入密码 ​ # 为了防止shell停止使用参数--stdin，让passwd介绍标准输入，echo是标准输出 ​ 来自：https://blog.csdn.net/qq_31820885/article/details/78100587） 1234567891011121314151617181920212223[root@sanchuang-linux chenpeng]# vim test.shread -p &quot;请输入用户名：&quot; usernameread -p &quot;请设置密码：&quot; passworduseradd $usernameecho $password | passwd $username --stdinecho $usernameecho $password[root@sanchuang-linux chenpeng]# sh test.sh请输入用户名：cp1请设置密码：123456更改用户 cp1 的密码 。passwd：所有的身份验证令牌已经成功更新。cp1123456[root@sanchuang-linux chenpeng]# id cp1uid=1009(cp1) gid=1009(cp1) 组=1009(cp1)[root@sanchuang-linux chenpeng]# less /etc/passwdroot:x:0:0:root:/root:/bin/bash………………wy:x:1008:1008::/home/wy:/bin/bashcp1:x:1009:1009::/home/cp1:/bin/bash ============================================================================================ *4.2 python 与 shell 程序运行出错 python中如果程序运行中出现错误，后续操作会终止 shell 中如果出现错误，操作会继续向下执行 *4.3 优化脚本2 用户创建脚本优化： 1.让命令的标准输出和标准错误输出都输出到黑洞文件 echo $password | passwd $username --stdin &amp;&gt;/dev/null 2.密码隐藏 -s read -s -p “请设置密码：” password 3.判断用户是否存在 条件语句： if 条件 then ​ 语句体1 else ​ 语句体2 fi *4.3 优化脚本2 12345678910111213141516171819202122[root@sanchuang-linux chenpeng]# vim test.shread -p &quot;请输入用户名：&quot; usernameif cat /etc/passwd |grep $username &amp;&gt;/dev/nullthen echo &quot;$username is exist!&quot;else read -s -p &quot;请设置密码：&quot; password useradd $username &amp;&gt;/dev/null echo $password | passwd $username --stdin &amp;&gt;/dev/null echo -e &quot;\\n create $username ok!&quot;fi----------------------------------------------------------[root@sanchuang-linux chenpeng]# sh test.sh 请输入用户名：cp1cp1 is exist![root@sanchuang-linux chenpeng]# sh test.sh 请输入用户名：cp8请设置密码： create cp8 ok![root@sanchuang-linux chenpeng]# 4.3.2 脚本优化3 12345678910111213141516171819202122232425[root@sanchuang-linux chenpeng]# vim test.shread -p &quot;请输入用户名：&quot; usernameif cat /etc/passwd |grep $username &amp;&gt;/dev/nullthen echo &quot;$username is exist!&quot;else read -s -p &quot;请设置密码：&quot; password useradd $username &amp;&gt;/dev/null echo $password | passwd $username --stdin &amp;&gt;/dev/null echo -e &quot;\\n create $username ok!&quot;fi （tmux 窗口1） ──────────────────────────────────────────────[root@sanchuang-linux chenpeng]# sh test.sh 请输入用户名：chen5556chen5556 is exist![root@sanchuang-linux chenpeng]# sh test.sh 请输入用户名：chen7778请设置密码： create chen7778 ok![root@sanchuang-linux chenpeng]# （tmux 窗口2） 4.3.4 脚本改善 最终版 [root@sanchuang-linux chenpeng]# id chen5557 uid=1019(chen5557) gid=1019(chen5557) 组=1019(chen5557) -------------------------------------------------------- 12345678910111213141516171819202122232425[root@sanchuang-linux chenpeng]# vim test.shread -p &quot;请输入用户名:&quot; usernameif id $username &amp;&gt;/dev/nullthen echo &quot;$username is exist!&quot;else read -s -p &quot;请设置密码:&quot; password useradd $username &amp;&gt;/dev/null echo $password | passwd $username --stdin &amp;&gt;/dev/null echo -e &quot;\\n create $username ok!&quot;fi（tmux 窗口1）──────────────────────────────────────────────[root@sanchuang-linux chenpeng]# sh test.sh 请输入用户名:chen5556chen5556 is exist![root@sanchuang-linux chenpeng]# sh test.sh 请输入用户名:chen7777请设置密码: create chen7777 ok![root@sanchuang-linux chenpeng]# （tmux 窗口2） 查看用户是否存在 *4.4 查看用户是否存在 [root@sanchuang-linux ~]# cat /etc/passwd |grep cp1 cp1: x:1009:1009::/home/cp1:/bin/bash 上一条命令返回值 $? *4.5 上一条命令返回值 $? $? 上一个命令的返回值 上一条命令返回值： 保存在 --&gt;$? 为0是成功 为1是失败 命令返回值为0 表示执行成功 ​ 1 执行失败 ​ 227 没有这条命令 命令返回值 $? *4.6 命令返回值 不精确的判断用户是否存在 不精确地判断用户是否存在 [root@sanchuang-linux ~]# cat /etc/passwd |grep cp1 （注：不精确地判断用户是否存在） cp1: x:1009:1009::/home/cp1:/bin/bash [root@sanchuang-linux ~]# echo $? （注：为0是成功） 0 [root@sanchuang-linux ~]# cat /etc/passwd |grep cp9 [root@sanchuang-linux ~]# echo $? （注：为1是失败） 1 ======================================================= 命令返回值 id [root@sanchuang-linux ~]# id cp1 uid=1009(cp1) gid=1009(cp1) 组=1009(cp1) [root@sanchuang-linux ~]# echo $? 0 [root@sanchuang-linux ~]# id cp9 id: “cp9”：无此用户 [root@sanchuang-linux ~]# echo $? 1 [root@sanchuang-linux ~]# 上一条命令返回值： 保存在 ——&gt;$? -------------------------------------------------------- 命令返回值为0 表示执行成功 ​ 1 执行失败 ​ 227 没有这条命令 *4.7 精确的判断用户是否存在 （完善脚本） 想要精确匹配的话，就把过滤的范围缩小一点： ^wy: 以wy: 开头 ^…：以什么开头，整行以什么开头 …$：以什么结尾，整行以什么结尾 [root@sanchuang-linux ~]# cat /etc/passwd |grep &quot;^wy:&quot; wy: x:1008:1008::/home/wy:/bin/bash [root@sanchuang-linux ~]# useradd wy: useradd：无效的用户名“wy:” wc命令 &lt;重定向标准输入 知识点5.1 wc命令 &lt;重定向标准输入 wc（字数统计）命令 格式：wc [选项]... 目标文件... -l：统计行数 -w：统计字数 （前后都是空白的一组字符） -c：统计字符数（可见和不可见的字符） 例： # wc /etc/hosts 4 23 185 /etc/hosts （* 注：4行，23个单词，185个字节） 代码如下 --------------------------------------------------------------- [root@sanchuang-linux ~]# wc -l backup_log.sh （注：查看文件有多少行） 0 backup_log.sh [root@sanchuang-linux ~]# wc &lt; backup_log.sh （输入重定向） 0 0 0 [root@sanchuang-linux ~]# wc backup_log.sh 0 0 0 backup_log.sh [root@sanchuang-linux lianxi]# wc -l sshd_config2 （注：查看文件有多少行） 148 sshd_config2 [root@sanchuang-linux lianxi]# wc &lt; sshd_config2 （注：标准输入 输入重定向） 148 559 4425 [root@sanchuang-linux lianxi]# wc sshd_config2 （注：wc(字数统计)命令） 148 559 4425 sshd_config2 知识点5.2 重定向 发信息 echo “hello brother” &gt; /dev/pts/22 [root@sanchuang-linux ~]# w 17:20:37 up 19:51, 7 users, load average: 0.00, 0.00, 0.02 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root tty1 - 0610月20 7:20m 0.60s 0.60s -bash root pts/7 192.168.0.30 14:30 42:37 0.09s 0.00s tmux root pts/21 192.168.0.30 16:48 21.00s 0.14s 0.14s -bash root pts/22 192.168.0.30 17:20 0.00s 0.02s 0.01s w ---------------------------------------------------------------------- # echo &quot;hello brother&quot; &gt; /dev/pts/22 重定向 发信息 xargs 管道符号 知识点5.3 xargs 管道符号 xargs 将前面命令的输出送给后面的命令作为参数使用 xargs 和 管道符号 一般配套使用 ------------------------------------------------- 在当前路径查看.txt结尾的文件 find . -name “*.txt” ------------------------------------ 管道 与 xargs 将管道前的输出作为参数赋给后面的命令 find . -name &quot;*.txt&quot; | xargs rm -rf -------------------------------------------------------------------------------------- 管道与xargs xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。 [root@mysql-binary vim_test]# find . -name “*.sh” |xargs ls -al [root@mysql-binary vim_test]# find . -name “*.txt” | xargs rm -rf （注：ls -al 看文件详细信息） 代码如下 ------------------------------------------------------------------ [root@sanchuang-linux chenpeng]# find . -name “*.sh” |xargs ls -al -rw-r–r–. 1 root root 77 10月 16 15:30 ./redirect/abc.sh -rw-r–r–. 1 root root 206 10月 16 15:45 ./redirect/student_information.sh -rw-r–r–. 1 root root 300 10月 16 17:15 ./test.sh [root@sanchuang-linux chenpeng]# ls -al test.sh -rw-r–r–. 1 root root 300 10月 16 17:15 test.sh","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://blog1.cpen.top/tags/Shell/"}]},{"title":"08_Linux基础-vim-tmux-字符编码","slug":"Linux_基础/08_Linux基础-vim-tmux-字符编码","date":"2022-09-05T04:00:00.000Z","updated":"2022-09-05T05:00:00.000Z","comments":true,"path":"posts/33007.html","permalink":"https://blog1.cpen.top/posts/33007.html","excerpt":"","text":"一. vim 文本编辑器-vim（编辑文本） Windows：记事本、word、sublime、pycharm 能编辑音乐、视频、图片？答：不能，只能编辑文本 Linux： ​ vi（字符界面），vim（字符界面），gedit（图形化） unix 都会安装vi vim 是vi的加强版（在vi基础上添加其他功能） vim编辑器作用 vim编辑器作用： 1、编写脚本、程序 2、修改配置文件 3、做一些文本处理 vim模式 vim有三种最常用最基本的模式：命令模式、编辑模式（插入模式）、末行模式、可视模式，替换模式 vim有三种最常用最基本的模式： 命令模式 编辑模式 末行模式 还有另外两种不常用模式： 视图模式 替换模式 vim命令模式 命令模式：vim a / ESC ​ 无法编辑，只允许删除、复制、粘贴、撤销等快捷操作，打开文件时默认进行此模式 yy 复制 p 粘贴 dd 删除 u 撤销 命令模式 相当于一个中间介 每个模式退出 都会回到命令模式，命令模式可以进入所有模式 vim编辑模式 编辑模式 ESC i – 插入 – ​ 插入模式，进行文本编辑 ----------------------------------------------------------------------- 操作键 功能 ​ i 光标在当前位置进入插入模式 ​ I 光标跳到行首并进入插入模式 ​ a 光标后退一格并进入插入模式 ​ A 光标退到行尾并进入插入模式 ​ o 在光标所在行下新起一行并进入插入模式 ​ O 在光标所在行上新起一行并进入插入模式 ​ s 删除光标所在字符并进入插入模式 ​ S 删除光标所在行并进入插入模式 vim末行模式 末行模式 ESC : : 输入命令，设置环境，保存文件，查找替换 ---------------------------------------------------- 操作键 功能 ​ :q 如果未对文件做改动则退出 ​ :q! 放弃保存并退出 ​ :wq 保存当前文件并退出 ​ :wq! 强制保存当前文件并退出 ​ :x 保存当前文件并退出 ​ :x! 强制保存当前文件并退出 ​ ZZ 保存当前文件并退出 vim视图模式 视图模式 ESC v、V、ctrl+v – 可视 行 – ​ 选择特定的块文本，进行复制，修改等 小v：选择行指定的部分 大V：选择整个行 Ctrl + v :选择块 插入按I 退出模式进人命令模式（Esc），这个时候就全部加上 vim替换模式 替换模式 ESC R – 替换 – ----------------------------------- 123 hello456 789 xxx helloyyy zzz xxx yyy zzz 练习 课堂练习1 插入模式 123 456 123 4 xyz 789 4 xyz 789 --------------------------------------------------------- 步骤： v 小v 可视模式 visual —》选择一部分 y 按y复制 o 按o另起一行，进入插入模式 P 再按esc，再p，按p粘贴 课堂练习2 123 TEST 456 789 xxx TEST yyy zzz --------------------------------------------------------- 选择块插入 ctrl + v：选择块 插入按大I ESC 退出模式进入命令模式，这个时候就全部加上 vim常用快捷方式 vim 常用快捷方式 vim打开文件： # vim e # vim +5 e 表示打开文件e，并且将光标移动到第3行 # vim +/aa e 打开文件e，并且高亮显示aa字符 退出vim编辑器的方法 vim保存退出： 操作键 功能 ​ :q 如果未对文件做改动则退出 ​ :q! 放弃保存并退出 ​ :wq 保存当前文件并退出 ​ :wq! 强制保存当前文件并退出 ​ :x 保存当前文件并退出 ​ :x! 强制保存当前文件并退出 ​ ZZ 保存当前文件并退出 （注：命令模式退出） 光标移动 光标移动：上下左右方向键（k，j，h，l） ------------------------------------------------- 操作类型 操作键 功能 光标方向移动 k，j，h，l 上、下、左、右 ============================================================== 翻页 Page Down或Ctrl+F 向下翻动一整页内容 ​ Page Up或Ctrl+B 向上翻动一整页内容 ============================================================== 行内快速跳转 Home键或“^”、数字“0” 跳转至行首 （注：“^”尖符号） ​ End键或“$”键 跳转到行尾 ============================================================== 行间快速跳转 1G或者gg 跳转到文件的首行 G 跳转到文件的末尾行 #G 跳转到文件中的第#行 （末行模式）:40 跳转到40行 w 每个单词的首字母跳转 e 每个单词的尾字母跳转 vim设置 vim设置 （末行模式）:set number 设置行数 （末行模式）:set nonumber 取消设置 -------------------------------------- 1234567:set number 1 aa bb cc 2 dd ee ff 1 aa bb cc 2 dd ee ff 3 aa bb cc 删除（剪切）、复制、粘贴 操作类型 操作键 功能 -------------------------------------- 删除 （*注：一般==^行首，$行尾==） x或d或Del 删除光标处的单个字符 dd 删除当前光标所在行 #dd 删除从光标处开始的==#行内容== d==^== 删除当前光标之前到行首的所有字符 d==$== 删除当前光标处到行尾的所有字符 dw 删除一个单词（word)，以空格、冒号等 符号 ------------------------------------------------------ 复制 yy 复制当前行整行的内容到剪贴板 #yy 复制从光标处开始的==#行==内容 ------------------------------------------------------ 粘贴 小p 将缓冲区中的内容粘贴到光标位置处之后 大P 粘贴到光标位置处之前 文件内容查找 文件内容查找 操作键 功能 ==/==word 从上而下在文件中查找字符串“word” ==?==word 从下而上在文件中查找字符串“word” 小n 定位下一个匹配的被查找字符串 大N 定位上一个匹配的被查找字符串 （注：/word 和 ?word 不同点：方向相反） 取消高亮、设置行数、取消行数设置 123取消高亮 ：noh设置行数：set nu取消：set nonu 二. vim-tmux及字符编码问题 文件内容替换 文件内容替换(末行模式） 命令 功能 😒 /old/new 将当前行中查找到的第一个字符“old”串替换为“new” 😒 /old/new/g 将当前行中查找到的所有字符串“old”替换为“new” :#,# s/old/new/g 在行号“#,#”范围内替换所有的字符串“old”为“new” :% s/old/new/g 在整个文件范围内替换所有的字符串“old”为“new” global 😒 /old/new/gc 在替换命令末尾加入c命令，将对每个替换动作提示用 户进行确认 Confirm :%s/feng//g 将所有的feng删除 （注：😒/…/… 当前行 第一个str ​ 😒/…/…/g当前行 所有str ​ :#,#s/…/…/g 行号#,# 所有str ​ :%s/…/…/g 整个文档 所有str ​ 😒/…/…/gc 整个文档 所有str 确认提示 ​ :%s/…//g 整个文档 所有str 删除） （注：s —— 替换 ​ 😒 —— 当前行替换 ​ #,# —— 行号#到# ​ % —— 整个文档 ​ g —— 所有字符串 ​ c —— 确认提示 ​ :%s/…//g —— 整个文档 所有str 删除） 缓存：swp文件 编写文件时 1.txt 先把1.txt文件拷贝一份，拷贝成.1.txt.swp文件，真正编辑的是这个文件 保存时，会将.1.txt.swp覆盖1.txt ------------------------------------------------------------------------------------------- 相关操作 一个终端下# vim 2.txt,另一个终端敲# ls -al,提示如下 [root@sanchuang-linux cp]# ls -al 总用量 88 -rw-r–r–. 1 root root 4096 10月 15 15:05 .2.txt.swp =========================================================================================== 在另一个终端# vim 2.txt，提示如下 1234567891011121314151617181920发现交换文件 &quot;.2.txt.swp&quot; 所有者: root 日期: Thu Oct 15 15:05:45 2020 文件名: ~root/cp/2.txt 修改过: 否 用户名: root 主机名: sanchuang-linux 进程 ID: 3129 (仍在运行)正在打开文件 &quot;2.txt&quot; 日期: Thu Oct 15 15:05:22 2020(1) Another program may be editing the same file. If this is the case, be careful not to end up with two different instances of the same file when making changes. Quit, or continue with caution.(2) An edit session for this file crashed. 如果是这样，请用 &quot;:recover&quot; 或 &quot;vim -r 2.txt&quot; 恢复修改的内容 (请见 &quot;:help recovery&quot;)。 如果你已经进行了恢复，请删除交换文件 &quot;.2.txt.swp&quot; 以避免再看到此消息。交换文件 &quot;.2.txt.swp&quot; 已存在！以只读方式打开([O]), 直接编辑((E)), 恢复((R)), 退出((Q)), 中止((A)): =========================================================================================== :wq 写入时，提示如下 123&quot;2.txt&quot; 警告: 此文件自读入后已发生变动！！！确实要写入吗 (y/n)? * 注意：进入命令模式，按数字键，之后再进入插入模式的话，会将输入内容按照之前按的数字大小复制成多份 （注：步骤 ​ vim 1.txt ——&gt; 先按数字3 ——&gt; 按i进入插入模式 ——&gt; abc ——&gt; Esc ——&gt; abcabcabc） 打开新文件或读入其他文件内容 &amp;&amp; 撤销和另存为 打开新文件 :e 或 读入其他文件内容 :r 命令 功能 :e ~/install.log 打开新的文件进行编辑 :r /etc/filesystems 在当前文件中读入其他文件内容 （注：即追加内容） 撤销和另存为 :w :w /tmp/hello.txt 把当前文件另存为/tmp目录下的hello.txt 同时编辑多个文件 # vim 1.txt 2.txt :n 编辑上一个 :N 编辑下一个 =========================================================================================== 例： # vim 2.txt :e 1.txt （注：进入1.txt进行编辑） -------------------------- # vim 2.txt :r 1.txt （注：读入1.txt文件的内容。在当前光标下一行插入1.txt文件内容） =========================================================================================== 撤销和另存为 :w 命令 功能 :w /tmp/hello.txt 把当前文件另存为/tmp目录下的hello.txt =========================================================================================== 例： # vim 1.txt :w /root/cp/test.txt （注：将文件1.txt另存为在/root/cp/目录下，改名为test.txt） vim的配置（3种） -------------------------------------------------------------------------------------------- 第一种 vim设置：（末行模式） 一次性设置行数：（只在当前编辑时生效） :set number 取消 :set nonumber -------------------------------------------------------------------------------------------- 第二种 全局配置文件： # vim /etc/vimrc # cp /etc/vimrc{,.bak} （注：效果等同于 # cp /etc/vimrc /etc/vimrc.bak） ​ （* 注↑：备份操作。修改全局配置文件前先备份。出错就回滚） set number （注：设置行数） set showcmd （注：显示当前键入命令） set encoding=utf-8 （注：设置编码） set tabstop=4 （注：设置tab键的空格数） -------------------------------------------------------------------------------------------- 第三种：(只针对当前用户生效) 编写 ~/.vimrc [root@sanchuang-linux ~]# vim .vimrc [root@sanchuang-linux ~]# cat .vimrc set number set showcmd set encoding=utf-8 set tabstop=4 tmux 123456789101112131415tmux shell里面多屏幕编辑安装：# yum install tmux -y tmuxCtrl+b 上下左右Ctrl+b shift +＂Ctrl+b shift + %Ctrl+b + c 创造新的一页Ctrl+b + p 返回上一页Ctrl+b + n 返回下一页Ctrl+b + x 关闭当前小窗口 ctrl+d 关闭Ctrl+b + b + ! 删除Ctrl+b + d 暂存，保存当前的tmux状态并退出tmux tmux： 安装：yum install tmux tmux： 一：敲tmux 进入会话 窗口底部有绿杠表示进入了tmux ---------------------------------------------------------------------------------------------------------- 左右分屏：先按ctrl + b，然后再按shift+==%==号 上下分屏：先按ctrl + b, 然后再按shift+&quot; 上下左右移动光标： ctrl + b，再按上下左右方向键 删除一个分割： 光标移动到那个分割屏幕，然后按ctrl +d 新增一个新的窗口（新增一页）：ctrl+b，然后按c 返回上一页： ctrl+b 然后按p 返回下一页： ctrl+b 然后按n ---------------------------------------------------------------------------------------------------------- 保存当前的tmux状态，并退出tmux： 使用： ctrl+b 然后按d ---------------------------------------------------------------------------------------------------------- 查看当前保存的会话状态 [root@mysql-binary ~]# tmux ls 0: 2 windows (created Thu Oct 15 16:31:27 2020) [139x22] 1: 2 windows (created Thu Oct 15 16:45:40 2020) [139x22] ------------------------------------------------------------------------------------------------------------- 进入第一个会话状态： tmux a -t 0 ------------------------------------------------------------------------------------------------------------- 设置tmux，跟vim的末行模式很像： 按ctrl+b ,然后按==：（这时窗口底部就会有黄色==的杠） 设置同步： ctrl+b 然后按==：== 然后输入set synchronize-panes on ​ 取消同步set synchronize-panes off tmux终端关闭，执行的程序会继续执行 （* tmux的好处） tmux 终端关闭，不是tmux会话关闭。tmux 终端关闭，那之前执行的程序都会继续执行。 不使用tmux，默认情况下，终端关闭，执行的程序也会关闭。 测试如下 ================================================================ 测试： 编写脚本： # cat sleep.sh echo “begin…” sleep 100 echo “end…” ======================= 运行脚本 # sh sleep.sh begin… ======================= 运行脚本：（放到后台运行） # sh sleep.sh &amp; ======================= 查看进程有没有运行 # ps -ef |grep sleep root 13133 13112 0 17:12 pts/6 00:00:00 sh sleep.sh root 13134 13133 0 17:12 pts/6 00:00:00 sleep 100 root 13190 13140 0 17:12 pts/16 00:00:00 grep --color=auto sleep ======================= 关闭终端之后再重新开启连接，查看进程有没有运行。 结果：没有运行 …… ======================= 在tmux下 运行脚本 …… tmux关闭后 会话还在，程序还会一直运行 # ps -ef |grep sleep root 13278 13003 0 17:17 pts/13 00:00:00 sh sleep.sh root 13279 13278 0 17:17 pts/13 00:00:00 sleep 100 root 13284 13140 0 17:17 pts/16 00:00:00 grep --color=auto sleep ======================= 编码 编码 编码：http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html 文件编码一般2种方式：ascii 和 unicode UTF-8 是 Unicode 的实现方式之一 转编码： # iconv -f utf-8 -t gbk code_test.txt &gt;code_test1.txt ASCII 码 最多能表示256个字，不够用 unicode 万国码，每个字给你一个序号 UTF-8 是 Unicode 的实现方式之一，规定怎么存储在计算机。 （UTF-8对ascii码/英文码友好） 以什么编码方式存储，就要以什么编码方式解码 utf-8、utf-16 国内编码 gbk、gb2131 =============================================== 系统语言设置环境： # locale LANG=zh_CN.UTF-8 LC_CTYPE=“zh_CN.UTF-8” LC_NUMERIC=“zh_CN.UTF-8” LC_TIME=“zh_CN.UTF-8” LC_COLLATE=“zh_CN.UTF-8” LC_MONETARY=“zh_CN.UTF-8” LC_MESSAGES=“zh_CN.UTF-8” LC_PAPER=“zh_CN.UTF-8” LC_NAME=“zh_CN.UTF-8” LC_ADDRESS=“zh_CN.UTF-8” LC_TELEPHONE=“zh_CN.UTF-8” LC_MEASUREMENT=“zh_CN.UTF-8” LC_IDENTIFICATION=“zh_CN.UTF-8” LC_ALL= =============================================== file code_test.txt 注：查看文件编码类型 # locale 系统语言设置环境 # file code_test1.txt 看文件编码方式 系统、文件、shell 三者统一 ，不会乱码 =============================================== 上课代码操作： # mkdir vim_test # cd vim_test/ # ls # rz -E （注：将windows code_test.txt文件上传linux） rz waiting to receive. # ls code_test.txt # vim code_test.txt # file code_test.txt （注：查看文件编码类型） code_test.txt: UTF-8 Unicode text # iconv -f utf-8 -t gbk code_test.txt &gt;code_test1.txt （注：转国标码） # file code_test1.txt code_test1.txt: ISO-8859 text （注：国标码） # vim code_test1.txt （注：显示乱码） # 为什么出现乱码？答：以utf-8的方式打开gbk编码 以什么编码方式存储，就要以什么编码方式解码 总结（xmind） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144vim文本编辑器vi，vimvim常见模式 命令模式 文件打开默认就是命令模式 ESC键到达 编辑模式 a,i,o,s（支持大写） 末行模式 ： 可视模式 v 选中文本指定部分 V 选择文本指定行 ctrl+v 选择文本指定块 替换模式 R基本使用 命令模式 删除 x 、d dd 5dd 复制 yy 3yy 粘贴 p 撤销 u 查找 / 光标移动 上下左右方向键（k,j,h,l） 文件首 gg 文件尾 G 移动到特定行 5G ：5 行首 home键 0 ^ 行尾 end键 $ 上翻页 page up， ctrl+b 下翻页 pagedowm， ctrl+f 编辑模式 i I o O a A s S 可视模式 复制y 插入 I 末行模式 退出和保存 q q! wq wq! x ZZ命令模式退出 替换 ：s/old/new :s/old/new/g :%s/old/new :%s/old/new/g :3,5s/old/new/g :%s/old/new/gc 设置 文件操作 ：e 编辑新文件 ：r 导入文件内容 ：w 另存文件路径 vim 1.txt 2.txt ：n 编辑下一个 ：N 编辑上一个vim常见快捷方式使用 vim file1 file2 file3 vim +10 file vim +/aa filevim的配置 临时配置 末行模式 ：set nu 全局配置 /etc/vimrc 用户配置 ~/.vimrctmux tmux：安装：yum install tmuxtmux： 一：敲tmux 进入会话窗口底部有绿杠表示进入了tmux左右分屏：先按ctrl + b ，然后再按shift+% 号上下分屏：先按ctrl + b, 然后再按 shift+&quot;上下左右移动光标： ctrl + b 再按上下左右方向键删除一个分割： 光标移动到那个分割屏幕，然后按ctrl +d新增一个新的窗口（新增一页）： ctrl+b 然后按c返回上一页： ctrl+b 然后按p返回下一页： ctrl+b 然后按n保存当前的tmux状态，并退出tmux：使用： ctrl+b 然后按d查看当前保存的会话状态[root@mysql-binary ~]# tmux ls0: 2 windows (created Thu Oct 15 16:31:27 2020) [139x22]1: 2 windows (created Thu Oct 15 16:45:40 2020) [139x22]进入第一个会话状态：tmux a -t 0设置tmux，跟vim的末行模式很像：按ctrl+b ,然后按： （这时窗口底部就会有黄色的杠）设置同步： ctrl+b 然后按： 然后输入set synchronize-panes on 取消同步set synchronize-panes offtmux 终端关闭，不是tmux会话关闭。那之前执行的程序都会继续执行。不使用tmux，默认情况下，终端关闭，执行的程序也会关闭。文件编码 iconv -f utf-8 -t gbk file.txt &gt; file2.txt 查看系统语言环境 locale ascii unicode utf-8 utf-16 gbk gb2132","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Vim","slug":"Vim","permalink":"https://blog1.cpen.top/tags/Vim/"}]},{"title":"07_Linux基础-计划任务-备份脚本-变量定义和使用","slug":"Linux_基础/07_Linux基础-计划任务-备份脚本-变量定义和使用","date":"2022-09-04T04:00:00.000Z","updated":"2022-09-04T05:00:00.000Z","comments":true,"path":"posts/29955.html","permalink":"https://blog1.cpen.top/posts/29955.html","excerpt":"","text":"一. 计划任务 主要内容：周期性的计划任务crontab /var/spool/cron/ 统一存放计划任务的目录 /var/log/cron 日志文件 /etc/cron cron.daily/ cron.hourly/ cron.monthly/ cron.weekly/ crontab的顺风车 /etc/crontab crontab -l crontab -e crontab -u cali -e crontab -u cali -l ​ 如何知道计划任务是否执行？ ​ 用户没有登录，计划任务是否执行？答：会执行 ​ 黑客也会去利用计划任务定时执行程序，你如何去检查？ ​ annacron 将电脑主机因为系统故障关机导致计划任务没有被执行，正常启动后，anacron会去检测没有执行的计划任何，重新执行一次 at 一次性的计划任务 at 11:45 at -l cron 计划任务 ​ 1.什么是计划任务？ （闹钟） ​ 计划什么时候去做什么事情 一次性的计划任务 ​ at 周期性的计划任务 ​ crontab linux系统里的执行计划任务的进程–》crond crond会每分钟去检查下所有用户的计划任务 # ps aux|grep crond root 887 0.0 0.1 36300 3508 ? Ss 9月24 0:00 /usr/sbin/crond -n root 16948 0.0 0.0 12320 984 pts/0 S+ 10:05 0:00 grep --color=auto crond # cd /var/spool/cron/ （注：统一存放计划任务的目录） # ls # 计划任务 原理 原理 时间的格式和语法（笔试） （注：每个用户都可以用的命令） # crontab -l （注：查看当前用户的计划任务）（每个用户只能看自己的，root用户能看所有的） no crontab for root # # crontab -e （注：创建计划任务） …… （注：vim编辑器 本质上是文本文件） # crontab -l 30 4 * * * bash /lianxi/9_25/backup_log.sh */5 * * * * bash /lianxi/9_25/backup_log.sh 50 3 6-9 10 * bash /lianxi/9_25/backup_log.sh * 该范围内的任意时间 ， 间隔的多个不连续时间点 - 一个连续的时间范围 /n 指定间隔的时间频率 ​ （注：crond进程 最低的时间间隔是1分钟） （注：时间不能冲突 日期和星期不能冲突） # # cd /var/spool/cron/ （注：统一存放计划任务的目录，一个用户对应一个文件名） # ls cali liangluyao root # cat root （注：文件里面 就是cronta -e编辑的） 30 4 * * * bash /lianxi/9_25/backup_log.sh */5 * * * * bash /lianxi/9_25/backup_log.sh 50 3 6-9 10 * bash /lianxi/9_25/backup_log.sh # # ll （注：每一个用户的计划任务都会放在/var/spool/cron/目录下） 总用量 12 -rw-------. 1 cali cali 31 9月 25 10:27 cali -rw-------. 1 liangluyao liangluyao 31 9月 25 10:28 liangluyao -rw-------. 1 root root 139 9月 25 10:25 root # 问：如何知道计划任务是否执行？ 答：看日志文件，/var/log/cron。 ​ 或者直接去看效果。 ====================== 日志文件==（注：记录crond执行的计划任务，存放在/var/log/cron，用来排错。）== # tail -f /var/log/cron （注：tail -f 盯着文件末尾看） Sep 25 10:30:01 sanchuang-linux CROND[17143]: (root) CMD (bash /lianxi/9_25/backup_log.sh) Sep 25 10:30:01 sanchuang-linux CROND[17147]: (liangluyao) CMD (date &gt;&gt;~/liang.txt) Sep 25 10:30:02 sanchuang-linux CROND[17119]: (root) CMDOUT (tar: 从成员名中删除开头的“/”) Sep 25 10:30:02 sanchuang-linux CROND[17119]: (root) CMDOUT (tar: /var/log/audit/audit.log: 在我们读入文件时文件发生了变化) Sep 25 10:30:02 sanchuang-linux CROND[17155]: (cali) CMD (date &gt;&gt;~/cali.txt) 示例1（root用户）： 每天早上7:50自动开启sshd服务，22点50时关闭 service sshd start （注：开启sshd服务） service sshd stop （注：关闭sshd服务） 50 7 * * * service sshd start 50 22 * * * service sshd stop 每隔5天的12点整清空一次FTP服务器公共目录/var/ftp/pub 0 12 /5 * * rm -rf /var/ftp/pub==/ （注：清空：删除里面所有东西）== 每周六的7:30时，重新启动httpd服务 service httpd restart （注：重启httpd服务） 30 7 * * 6 service httpd restart 每周一、三、五的17:30时，打包备份/etc/httpd目录 30 17 * * 1,3,5 tar czf /backup/httpd.tar.gz /etc/httpd （注：/backup/是备份目录） 示例2（jerry用户）： （注：宿主目录：~/） 每周日晚上23:55时将“/etc/passwd”文件的内容复制到宿主目录中，保存为pwd.txt文件 55 23 * * 0 /usr/bin/cp /etc/passwd ~/pwd.txt （注：命令的绝对路径） /etc/crontab 是cron的一个配置文件 # vim /etc/crontab SHELL=/bin/bash （注：计划任务执行命令时用/bin/bash执行） PATH=/sbin:/bin:/usr/sbin:/usr/bin （注：它有自己的PATH变量，和shell的PATH变量不同） MAILTO=root （注：所有 计划任务里的命令，建议使用命令的绝对路径，因为PATH变量的问题） ​ （注↑：默认情况，计划任务出了问题，crontab会给root发邮件） # For details see man 4 crontabs # Example of job definition: （注：对命令的解释） # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr … # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed # crontab -u cali -e （注：用root用户为cali创建计划任务） # crontab -u cali -l （注：查看） 1.电脑关机了计划任务是否执行？答：不执行 2.用户没有登录，计划任务是否执行？答：会执行 # w （注：查看哪个用户从哪里登录） # tail -f /var/log/cron （注：日志文件） 3.黑客也会去利用计划任务定时执行程序，你如何去检查？ ​ 去==/var/spool/cron==目录下查看每一个计划任务文件 ​ 看日志 /var/log/cron ​ crontd的顺风车目录 （如下） # # cd /etc/cron******* cron.d/ cron.daily/ cron.deny cron.hourly/ cron.monthly/ crontab cron.weekly/ # cd /etc/cron （注：crontab的顺风车） 黑客也可以把需要执行的程序放到这些文件夹里 cron.daily --》Linux系统里要求crond每天去执行的事情 cron.hourly --》Linux系统里要求crond每小时去执行的事情 cron.monthly --》Linux系统里要求crond每月去执行的事情 cron.weekly --》Linux系统里要求crond每周去执行的事情 （注：# ls cron.daily ​ logrotate (每天都会执行，crond每天运行一次（脚本，用sh执行）) ​ # ls cron.hourly ​ 0anacron (annacron 将电脑主机因为系统故障关机导致计划任务没有被执行，正常启动后，anacron会去检测没有执行的计划任何，重新执行一次) at at 命令 一次性的计划任务 yum install at -y # at 11:45 warning: commands will be executed using /bin/sh at&gt; touch $(date +%F).txt at&gt; （注：退出 Ctrl+D） job 1 at Fri Sep 25 11:45:00 2020 Can’t open /var/run/atd.pid to signal atd. No atd running? # at -l （注：查看） 1 Fri Sep 25 11:45:00 2020 a root # 二. 计划任务练习-备份脚本 主要内容：chmod 777 /opt/fnum.txt （注：设置任何用户都可以对文件/opt/fnum.txt读写执行） 2&gt;/dev/null /dev/null 特殊的文件，相当于黑洞文件，任何的内容重定向到这个文件都会消失，不保存 正确的输出重定向 &gt; &gt;&gt; 错误的输出重定向 2&gt; 2&gt;&gt; 追加 不管正确的还是错误的都往一个文件里重定向 &amp;&gt; &amp;&gt;&gt; 追加 &gt;1.txt 清空1.txt文件里的内容 删除xull这个用户所有的计划任务 rm -rf /var/spool/cron/xull ​ # crontab -u xull -r （注 *） 取消计划任务 脚本+计划任务=自动化 先编写脚本，再创建计划任务 计划任务实验 计划任务实验： 1.为root用户编写计划任务：每周2、4、6的10点到17点的每隔5分钟自动将/etc/passwd、/etc/shadow这2个重要系统文件到user.备份的日期和时间.tar.gz这种名称的文件里（例如：user.201202011615.tar.gz）备份文件放到/opt/目录下面。 backup_shadow_pwd.sh # cat backup_shadow_pwd.sh #!/bin/bash mkdir -p /opt #注：date +%Y%m%d%H%M%S ， date后面有空格 tar czf /opt/user.$(date +%Y%m%d%H%M%S).tar.gz /etc/passwd /etc/shadow # $(date +%Y-%m-%d-%H) 注意空格 上面的 crontab -e */5 10-17 * * 2,4,6 bash /lianxi/9_25/backup_shadow_pwd.sh #（注：路径要接对，绝对路径） 2.root用户在/opt新建了一个文件fnum.txt专门用来统计普通用户的文件个数。请为普通用户hello编写计划任务：要求每5分钟，将系统中属于hello用户的文件的个数自动保存到/opt/fnum.txt文件中。内容格式为：“日期时间 姓名 拥有的文件个数是：数目”。每行中间用“*************************”隔开 file_num.sh # touch /opt/fnum.txt （注：新建空文件，普通用户建不了，root用户去建） # chmod 777 /opt/fnum.txt （注：设置任何用户都可以对文件/opt/fnum.txt读写执行） [cali@sanchuang-linux ~]$ crontab -l */5 * * * * date &gt;&gt;~/cali.txt 5 12-18 * * * date &gt;&gt;~/cali.txt */1 * * * * bash /home/cali/file_num.sh [cali@sanchuang-linux ~]$ pwd /home/cali $ cat file_num.sh （注：脚本放在普通用户家目录里） #!/bin/bash fnum=$(find / -user cali -type f 2&gt;/dev/null |wc -l) （注：普通用户 文件权限不够 是出错的） （注↑：错误重对象） ctime=$(date +%F_%H%M%S) echo “${ctime} cali the number of files : $fnum” &gt;&gt;/opt/fnum.txt （注：追加重定向 写到文件里去） echo “******************************” &gt;&gt;/opt/fnum.txt （注：追加重定向 写到文件里去） $ $ crontab -e ==（注：是哪个用户就哪个用户创建计划任务，==cali创建） */1 * * * * bash /home/cali/file_num.sh $ pwd /home/cali （注：脚本的路径） 每行中间用“*************************”隔开 解决方法 # cat a.sh echo “helllo” echo “**********************” echo “cali” echo “**********************” # # num=$(find / -user liangluyao |wc -l) $ find / -user cali -type f 2&gt;/dev/null|wc -l /dev/null 特殊的文件，相当于黑洞文件，任何的内容重定向到这个文件都会消失，不保存 null 零，空，无效的 重定向 正确的输出重定向 &gt; &gt;&gt; ====== 错误的输出重定向 2&gt; 2&gt;&gt; 追加 ====== 不管正确的还是错误的都往一个文件里重定向 &amp;&gt; &amp;&gt;&gt; 追加 ls 命令执行成功重定向到1.txt 执行失败重定向到2.txt $ ls &gt;1.txt 2&gt;2.txt $ &gt;1.txt 清空1.txt文件里的内容 $ cat 1.txt $ $ ls &amp;&gt;1.txt 不管正确的还是错误的都往一个文件里重定向 练习总结 练习总结： 问题： 2&gt;/dev/null 如何查看效果 # cat fnum.txt # tail -f /var/log/cron （日志文件） 取消计划任务 删除xull这个用户所有的计划任务 rm -rf /var/spool/cron/xull ​ # crontab -u xull -r （注 *） 将文件里的计划任务注释或者删除 #*/1 * * * * bash /home/xull/file_num.sh # cd /var/spool/cron/ ——》# rm -rf xull # crontab -u xull -r # cd /var/spool/cron/ ——》# vim xull ——》 加 # 注释掉 某个用户的计划任务如何创建 文件的路径问题和权限问题（root可以访问任务地方的文件，但是普通不行，只能访问有限的路径） 将root用户的所有计划任务追加到xull用户的计划任务里 # cd /var/spool/cron # cat root &gt;&gt;xull （注：注意权限问题，能否访问） 每一个用户的计划任务都存放在一个文件里 /var/spool/cron/ 2.root用户在/opt2新建了一个文件fnum.txt专门用来统计普通用户的文件个数。请为普通用户xull编写计划任务：要求每5分钟，将系统中属于xull用户的文件的个数自动保存到/opt2/fnum.txt文件中。内容格式为：“日期时间 姓名 拥有的文件个数是：数目”。每行中间用“*************************”隔开 使用root用户新建/opt2目录 mkdir /opt2 cd /opt2/ touch /opt2/fnum.txt 文件 chmod 777 /opt2/fnum.txt 授权 xull用户需要去编写脚本，创建计划任务（普通用户） 脚本：建议放在用户的家目录下 # su - xull 上一次登录：五 9月 25 15:53:35 CST 2020pts/1 上 $ pwd /home/xull $ ls $ vim file_num.sh （注：脚本放到自己的家目录下，用户xull去创建） $ cat file_num.sh #!/bin/bash num=$(find / -user xull -type f 2&gt;/dev/null |wc -l) #current time （注：当前的时间） ctime=$(date +%F%H%M%S) echo “ctimexull文件数量是{ctime} xull 文件数量是ctimexull文件数量是num” &gt;&gt;/opt2/fnum.txt （注：&gt;&gt;追加） echo “****************************” &gt;&gt;/opt2/fnum.txt （注：一行隔开） $ （注：vim交互式的。脚本是背后执行的，用echo） $ crontab -e */1 * * * * bash /home/xull/file_num.sh $ 切换到root用户 $ exit # cd /var/spool/cron/ （注：该目录下文件存放计划任务） # ls cali liangluyao root xull #cat xull （注：文件存放计划任务） */1 * * * * bash /home/xull/file_num.sh 三. 黑客-计划任务 主要内容：假如你是黑客，想在别人的机器上，每10分钟让它的服务器重启一次或者每天重启一次 关机命令：init 6 ​ reboot 1.停止crond服务 # service crond stop 2.查找可能存放计划任务的目录 /var/spool/cron （注：先挪走） /etc/cron.d （注：与cron.hourly 有关） /etc/cron.weekly /etc/cron.daily /etc/cron.monthly 3.检查发现没有问题了，再重新启动crond服务 # service crond start Redirecting to /bin/systemctl start crond.service # ps aux|grep crond 实在有的话 # tail -f /var/log/cron （日志文件） 开机启动流程 # cd /root （注：root用户家目录下） # ls -a （注：隐藏文件） # vim .bashrc # vim .bash_profile # vim /etc/profile （注：可以快捷筛选查找 /reboot /init） # vim /etc/bashrc （注：可以快捷筛选查找 /reboot /init） # cat /etc/rc.local 假如你是黑客，想在别人的机器上，每10分钟让它的服务器重启一次或者每天重启一次 ==== 192.168.0.45 root 123456 关机命令：init 6 ​ reboot ============================ 在各个路径下看 有没有可疑的 init6 和 reboot 1.停止crond服务 # service crond stop 2.查找可能存放计划任务的目录 /var/spool/cron （注：先挪走） /etc/cron.d （注：与cron.hourly 有关） /etc/cron.weekly /etc/cron.daily /etc/cron.monthly 3.检查发现没有问题了，再重新启动crond服务 # service crond start Redirecting to /bin/systemctl start crond.service # ps aux|grep crond root 1506 3.6 0.1 36304 3656 ? Ss 16:54 0:00 /usr/sbin/crond -n root 1511 0.0 0.0 12320 1052 pts/0 S+ 16:54 0:00 grep --color=auto crond # 实在有的话 # tail -f /var/log/cron （日志文件） （注：通过日志去排查） ============================= 集中放计划任务的地方 /var/spool/cron/ # cd /var/spool/cron/ # ls cali liangluyao root xull # cat cali ……（查看有没有可疑的，vim全部注释掉） 或者把所有文件全部挪走，如下操作 # ls cali liangluyao root xull # mkdir /backup （注：根下面建一个/backup 目录）/backup 备份目录 mv * /backup/ （把文件cali liangluyao root xull 挪到 /backup 目录下） 计划任务停了，crond不会执行 # cd /backup/ # ls cali liangluyao root xull # cat cali （注：把计划任务文件挪走后，再再/backup目录下 一个个排查） …… # cat liangluyao …… # w （注：查看哪些用户登录） ======================================= 顺风车 # cd /etc/cron.daily ​ # ls ​ # vim … # cd /etc/cron.hourly/ # cd /etc/cron.monthly # cd /etc/cron.weekly # cd /etc/cron.d （注：每小时执行是每小时的第一分钟执行） （注：run-parts 是一个命令，运行这个文件夹里的所有文件） ======================================================= 开机启动流程 # cd /root （注：root用户家目录下） # ls -a （注：隐藏文件） # vim .bashrc # vim .bash_profile # vim /etc/profile （注：可以快捷筛选查找 /reboot /init） # vim /etc/bashrc （注：可以快捷筛选查找 /reboot /init） # cat /etc/rc.local =============================================================================== 四. 变量定义和使用 主要内容： ​ 变量的命名：1.下划线命名法 （shell里建议）2.驼峰命名法3.匈牙利命名法 ​ 变量命名的注意事项 ​ shell里如果变量没有定义，输出的是空值 ​ env 查看shell里的环境变量 ​ set 查看当前shell里所有的变量 ​ export 输出变量为全局变量 ​ # echo $$ （注：显示当前bash的进程号）（注：$$代表当前bash的进程号） ​ # bash （注：起一个子进程，子bash） ​ # echo “$mv $sg hello” （注：输出一串内容的时候，用双引号引起来） ​ # echo ‘$mv $sg hello’ （注：单引号：所见即所得 $接变量名不会引用变量的值） 12345678910111213141516shell编程1.变量的定义variable 变量的sg=tanglf变量的命名：1.下划线命名法 （shell里建议） sc_sg=tanglf2.驼峰命名法 ScSg=wangtc 小驼峰 scSg=wangtc 大驼峰 ScSg=wangtc3.匈牙利命名法 12345变量命名的注意事项： 1.不是以数字开头 2.不要全部是数字 3.不要包含特殊符号 #!@^$&lt;&gt;等 4.=左右不能有空格 linux系统里的环境变量都是大写的 自定义变量尽量使用小写 变量尽量要先定义后使用 shell里如果变量没有定义，输出的是空值 # sc_sg=zhangxueyou # echo $sg_sg ​ （←注：变量sg_sg没有定义，输出的是空值） # echo $sc_sg zhangxueyou # echo sgsg/sgsg/sgsg/mvmv / （←注：变量{sgsg} {mvmv}没有定义，输出的是“/”根） # # rm -rf sgsg/sgsg/sgsg/mvmv rm: 在’/’ 进行递归操作十分危险 rm: 使用 --no-preserve-root 选项跳过安全模式 # env 查看shell里的环境变量 set 查看当前shell里所有的变量 变量是有作用域 全局变量 局部变量 export 输出变量为全局变量 ​ 用法：先定义再输出 ssh访问22号端口，sshd监听22号端口 web服务是80端口 # echo $$ （注：显示当前bash的进程号）（注：$$代表当前bash的进程号） 1425 # # export sg （注：输出sg这个变量为全局变量） # echo $$ 1425 # mv=xull # bash （注：起一个子进程，子bash） # echo $mv ​ （注：输出为空，变量不继承） # echo $$ 1598 # mv=xull # export mv （注：输出变量为全局变量）（注：export 输出） # bash （注：起一个子进程，子bash） # echo $mv Xull （注：子进程继承了变量） # # vim /root/.bash_profile 输出一串内容的时候，用双引号引起来 单引号：所见即所得 $接变量名不会引用变量的值 # echo “$mv $sg hello” （注：输出一串内容的时候，用双引号引起来） xull wangtc hello # echo ‘$mv $sg hello’ （注：单引号：所见即所得 $接变量名不会引用变量的值） $mv $sg hello #","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Crontab","slug":"Crontab","permalink":"https://blog1.cpen.top/tags/Crontab/"}]},{"title":"06_Linux基础-NGINX和浏览器、网页的关系-压缩命令-配置NGINX支持下载功能-备份脚本","slug":"Linux_基础/06_Linux基础-NGINX和浏览器、网页的关系-云服务器ssh登陆-安装NGINX-上传网页-压缩命令-xz-gzip-bzip2-zip-tar-配置NGINX服务器支持下载功能-备份脚本","date":"2022-09-03T04:00:00.000Z","updated":"2022-09-03T05:00:00.000Z","comments":true,"path":"posts/10149.html","permalink":"https://blog1.cpen.top/posts/10149.html","excerpt":"","text":"一. NGINX和浏览器、网页的关系 12345nginx是一个web服务器html语言编写网页cd /usr/local/nginx htmlcd html/ （注：存放网页路径） 12345678思考： 1.网页和nginx的关系 nginx将网页发送给浏览器 2.浏览器和nginx的关系 浏览器问nginx要网页 nginx将网页发送给浏览器 3.浏览器和网页的关系 浏览器是能读懂网页的html，js，css代码，渲染出效果 12web:网站表单信息放到数据库里去，nginx只能访问静态页面，Python把信息传到数据库里。Python——》flask web后端——》user表 12345如何判断nginx是否运行？1.看进程 ps aux|grep nginx2.看端口 netstat -anplut 1234567项目组： 1.前端 2.后端 3.运维 4.测试 5.dba 6.项目经理 12cd /usr/local/nginx/html/ 放网页rz 只能传文件，不能传文件夹 二. 云服务器ssh登陆-安装NGINX-上传网页 12345678自己的虚拟机的linux系统里呢？（如何上传自己的网页到linux系统呢） Xshell连过去自己的云服务器，如何上传自己的网页到云服务器呢？ 1.xshell --》公网ip（云服务器的公网ip）106.54.83.86 （注：xshell连接） 用户名root --》密码是有个初始密码 （注：passwd 改密码） 2.自己去编译安装nginx--》建议使用脚本安装--&gt;启动nignx 3.上传自己的网页到nginx的html目录下 （注：scp或上传Windows【中间环节】） 4.去访问106.54.83.86 12345678910111213141516171819202122232425262728293031323334（注）脚本：# cat onekey_install_nginx_v2.sh #!/bin/bash#1.下载nginx软件包mkdir -p /nginx2cd /nginx2curl -O http://nginx.org/download/nginx-1.19.2.tar.gz#2.解压,进入文件夹tar xf nginx-1.19.2.tar.gzcd nginx-1.19.2#3.编译前的配置 #新建用户sanchuang9useradd sanchuang9 #安装gcc和pcre-devel软件包，因为nginx需要这些软件，解决软件的依赖关系yum install gcc make pcre-devel zlib-devel -y #配置nginx，指定安装路径和启动nginx的用户名./configure --prefix=/usr/local/nginx2 --user=sanchuang9 #4.编译make#5.编译安装make install#6.关闭防火墙服务和设置开机不要启动service firewalld stopsystemctl disable firewalld #7.修改PATH变量，方便可以直接使用nginxecho &quot;PATH=$PATH:/usr/local/nginx2/sbin&quot; &gt;&gt;/root/.bashrc 1234ip add 看的是私网IPscp 远程copy/usr/local/nginx/sbin/nginx 启动nginxps aux|grep nginx 查看nginx进程 123456搞一个自己的网站 1.购买一个云服务器--》阿里云或者腾讯云，华为云，亚马逊免费试用 --》学生版 10元/月 2.购买域名 5元/年 在哪里购买的云服务器，就在哪里买域名，方便备案 3.备案 如果不备案，不能正常的使用域名去访问 1cat /etc/centos-release 查看centos版本 三. 压缩命令-xz-gzip-bzip2-zip-tar-配置NGINX服务器支持下载功能 主要内容：压缩命令-tar（重点） 对文件和文件夹进行压缩 ​ tar -czf --&gt;.tar.gz ​ tar cjf --&gt;.tar.bz2 ​ tar cJf --&gt;.tar.xz ==tar tf \\*.tar.\\*== ​ tar xf *.tar.* ​ # tar xf boot_log_passwd.tar.gz -C /zhanghuayou/ ​ 压缩命令-xz-gzip-bzip2-zip：都只能对文件进行压缩 ​ zip --&gt;.zip ​ gzip --&gt;.gz ​ xz —&gt;.xz ​ bzip2 --&gt;.bz2 ​ zip yum install zip unzip -y ​ zip chenpeng.txt.zip chenpeng.txt ​ unzip passwd.zip ​ gzip ​ gzip hosts ​ gunzip hosts.gz ​ zcat messages.gz ​ xz ​ xz hosts ​ unxz hosts.xz ​ xzcat messages.xz ​ bzip2 yum install bzip2 -y ​ bzip2 passwd ​ bunzip2 passwd.bz2 ​ bzcat passwd.bz2 ​ 配置nginx服务器支持下载功能 压缩命令-xz-gzip-bzip2-zip-tar 123为什么要打压缩包？ 备份的时候，能节约空间 网络传送的时候，能节约时间 123456windows里有哪些解压缩软件？ winrar 7z 好压 快压 Zip 1234windows里的.rar压缩文件传递到linux里，是否能打开 sc.rar （注：rar解压不了，linux里没这个软件，需要安装才有） sc.zip --&gt;linux默认支持windows能解压linux里的所有的压缩文件 12nginx-1.19.2.tar.gz linux里的压缩文件压缩文件红色的，可执行文件绿色的 zip zip zip只能对文件进行压缩，不能对文件夹进行压缩 ​ yum install zip unzip -y （注：zip需要安装） zip 打压缩包 unzip 解压的 # zip chenpeng.txt.zip chenpeng.txt （注：用法） ​ 压缩后的文件 源文件 [root@sanchuang-linux lianxi]# zip passwd.zip passwd adding: passwd (deflated 61%) （注:deflated压缩，泄气） ll -h 看大小 passwd.zip # unzip passwd.zip 解压 Archive: passwd.zip inflating: passwd # ls passwd passwd.zip zip的缺点：有源文件和新文件 gzip gzip gzip可以直接在源文件上压缩，后缀名是.gz （注：与zip的区别，理解为zip的升级版） ​ （注：gzip不需要安装） hosts passwd passwd.zip # gzip hosts （用法） gzip + 源文件 # ls hosts.gz passwd passwd.zip # gunzip hosts.gz （解压） # zcat messages.gz （查看压缩文件） xz xz （注：xz不需要安装） https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.8.11.tar.xz # xz hosts （用法） # ls hosts.xz passwd passwd.zip # unxz hosts.xz （解压） # ls hosts passwd passwd.zip # xzcat messages.xz （查看压缩文件） gz与xz 比较，xz效果好 推荐使用xz bzip2 bzip2 （注：bzip2需要安装） yum install bzip2 -y # bzip2 passwd （用法） passwd.bz2 # bunzip2 passwd.bz2 （解压） passwd # bzcat passwd.bz2 （查看压缩文件） zip --&gt;.zip gzip --&gt;.gz xz —&gt;.xz bzip2 --&gt;.bz2 tar 123456789101112tar --&gt;兼并了gzip,xz,bzip2tarball --&gt;使用tar命令打的压缩包--》归档文件--》压缩文件--》一个压缩包里可以包含很多的文件tar是可以对文件和文件夹进行压缩的Compressed TAR Archive [compressed压缩的 archive归档]https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.8.11.tar.xzhttp://nginx.org/download/nginx-1.19.2.tar.gzmysql-8.0.21-linux-glibc2.12-i686.tar.xzhttps://mirrors.tuna.tsinghua.edu.cn/apache/httpd/httpd-2.4.46.tar.bz2 配置NGINX服务器支持下载功能 (autoindex auto 自动 index索引) # cd /usr/local/nginx/conf/ （注：配置目录） # # vim nginx.conf （注2：修改配置文件）即加上autoindex on；这一行 ​ location / { ​ root html; （注4：指定nginx的存放网页的目录为html–》网页根目录） ​ index index.html index.htm; （注5：配置nginx服务器支持的首页为index.html 或者index.htm index.html的优先级要高，没有index.html的时候，就会去查找index.htm） ​ autoindex on; （注3：添加配置，让nginx支持显示文件夹里的内容） ​ } # /usr/local/nginx/sbin/nginx -s reload 重新加载nginx 压缩包上传 四. tar命令 tar命令 用途：制作归档文件、释放归档文件 格式：tar [选项]… 归档文件名 源文件或目录 ​ tar [选项]… 归档文件名 [-C 目标目录] 常用命令选项 -c：创建 .tar 格式的包文件 create -x：解开.tar格式的包文件 extract提取 -v：输出详细信息 verbose冗余的 -f：表示使用归档文件 file -t：列表查看包内的文件 list 常用命令选项 -C：解包时进入指定的目标文件夹 -z：调用gzip程序进行压缩或解压 -j：调用bzip2程序进行压缩或解 -J：调用xz程序进行压缩或解压 === （经典组合） 创建压缩包 ​ tar -czf --&gt;.tar.gz ​ tar cjf --&gt;.tar.bz2 ​ tar cJf --&gt;.tar.xz 创建压缩包到指定的路径 使用绝对路径 # tar czf /zhanghuayou/passwd.tar.gz /etc/passwd tar: 从成员名中删除开头的“/” 查看压缩包里的内容 ==tar tf \\*.tar.\\*== 解压–》默认解压到当前目录 ​ tar xf *.tar.* ​ -C 解压到指定的路径 # tar xf boot_log_passwd.tar.gz -C /zhanghuayou/ # mkdir tar # cd tar # ls # tar czf passwd.tar.gz /etc/passwd tar: 从成员名中删除开头的“/” # ls passwd.tar.gz # tar tf passwd.tar.gz etc/passwd （注：/ 没有了） [root@sanchuang-linux tar]# ls passwd.tar.gz # tar xf passwd.tar.gz # ls etc passwd.tar.gz （注2：解压后是文件夹etc,没有“/”） # cd etc/ # ls passwd # 给文件夹打压缩包 # tar cJf boot.tar.xz /boot # tar czf boot.tar.gz /boot # tar cjf boot.tar.bz2 /boot # time tar czf boot.tar.gz /boot （注：压缩命令前接 time 可以看时间） tar: 从成员名中删除开头的“/” real 0m8.467s user 0m6.851s sys 0m2.226s # （注：↓接v可以看过程，信息输出。一般写脚本不接v） # tar czvf boot_log_passwd.tar.gz /boot /var/log /etc/passwd （注：文件和目录） # tar czf boot_log_passwd.tar.gz /boot /var/log /etc/passwd tar: 从成员名中删除开头的“/” tar: 从硬连接目标中删除开头的“/” # 后面打包的文件如果压缩文件的名字一样，会覆盖 五. 压缩练习-备份脚本 主要内容： 排错多个文件 exclude 排除 （难点） # tar –exclude=/boot/{grub2,efi,loader} -czvf no_grub_boot.tar.gz /boot # date +%Y%m%d%H%M%S 20200924170954 当前的日期往后面推10天 # date -d “10 days” 如何得到命令的执行结果赋值给变量 方法1： ​ ctime=$(date +%F) 方法2：反引号 ​ ctime=`date +%F` 命令的嵌套 设置时间 -s # date -s ‘2020-10-10’ （注：调时间） # date -s ‘2020-10-10 9:53:00’ （注：指定小时分钟秒） # cal 看日历 calendar（日历） # cal 2020 看2020年日历 12345678910111213压缩练习： 1.在windows里使用winrar软件压缩2个文件，一个是.rar格式的文件，一个是.zip的文件，具体压缩那个文件，你自己定义 2.将文件传输到linux系统的/lianxi目录下，尝试解压.zip的文件# unzip 3.复制/etc/passwd文件到/lianxi目录下，将/lianxi目录下的passwd文件压缩成passwd.xz# cp /etc/passwd . # xz passwd 4.复制/etc/ssh/sshd_config 文件到/lianxi目录下，然后进行压缩为sshd_config.gz# cp /etc/ssh/sshd_config . # gzip sshd_config 5.查看passwd.xz里的内容，查看sshd_config.gz里的内容# xzcat passwd.xz # zcat sshd_config.gz 6.新建文件夹/backup_sc，然后复制/lianxi下的passwd.xz和sshd_config.gz到/backup_sc目录里 7.到/backup_sc目录里解压passwd.xz和sshd_config.gz文件 8.将/lianxi下的sshd_config.gz传到windows系统里看是否可以解压？ 练习8： ​ 1.创建一个目录在/lianxi下叫tar # mkdir /lianxi/tar ​ 2.进入tar目录，复制/etc/hosts文件和/etc/passwd到tar目录下 # cd /lianxi/tar # cp /etc/hosts . # cp /etc/passwd . ​ 3.复制/boot目录到tar目录下 # cp /boot . -r ​ 4.将当前目录下的boot目录打包放在/lianxi/tar目录下叫boot.tar.gz # tar czf boot.tar.gz boot ​ 5.查看boot.tar.gz文件里的内容 # tar tf boot.tar.gz ​ 6.将hosts文件和passwd文件打包放到host_passwd.tar.bz2文件 # tar cjf host_passwd.tar.bz2 hosts passwd ​ 7.查看host_passwd.tar.bz2文件里的内容 # tar tf host_passwd.tar.bz2 ​ 8.将/boot/目录和/etc/passwd、/var/log目录备份到/lianxi目录下叫boot_pw_log.tar.xz # tar cJf /lianxi/boot_pw_log.tar.xz /boot /etc/passwd /var/log ​ 9.新建/bak目录，然后将/lianxi目录下的boot_pw_log.tar.xz解压到/bak目录下 # mkdir -p /bak # tar xf boot_pw_log.tar.xz -C /bak ​ 10.将/boot目录下的除grub2目录以外的所有文件都备份到/bak目录下叫no-grub.tar.gz tar czvf --exclude （难点） # tar –exclude=/boot/grub2 -czvf no_grub_boot.tar.gz /boot centos8里的 （注：–exclude=/boot/grub2 -czvf 前后不能错，grub2不能接/，-czvf -不能省略） # tar –exclude=/boot/grub2 -czvf no_grub_boot.tar.gz /boot centos7里的 # tar czvf no_grub2_boot.tar.gz /boot –exclude=/boot/grub2 排错多个文件 exclude 排除 （难点） # tar –exclude=/boot/{grub2,efi,loader} -czvf no_grub_boot.tar.gz /boot （注：目录结构 {} 表示多个） 123练习：编写一个脚本实现备份/var/log目录下的所有文件到/bak目录下，要求文件名是包含当天日期，精确到秒，文件名例如：2013-6-6-2_30_20-log.tar.gz。同时要求删除/bak目录下七天前的备份文件，只保留最近7天的文件。 需求分析： 年月日小时分钟秒 时间戳：年月日小时分钟秒 ​ 获得当前的日期 date %Y year （注：年） %m month (01…12) （注：月） %M minute (00..59) ==（注：分钟）== %d day of month (e.g., 01) （注：日） %H hour (00…23) （注：小时） %S second (00…60) （注：秒） %F full date; same as %Y-%m-%d （注：年月日） # date +%Y%m%d%H%M%S 20200924170954 # date +%Y-%m-%d%H%M%S 2020-09-24171008 # date +%Y-%m-%d_%H_%M_%S 2020-09-24_17_10_31 # 当前的日期往后面推10天 （推迟时间） # date -d “10 days” 2020年 10月 04日 星期日 17:21:27 CST # date -d 10days 2020年 10月 04日 星期日 17:21:37 CST # # date -d 10hours 2020年 09月 25日 星期五 03:22:13 CST # 如何得到命令的执行结果赋值给变量 方法1：$( ) （更好，因为可以嵌套） ​ ctime=$(date +%F) 方法2：反引号 （不能嵌套） ​ ctime=`date +%F` # ctime=$(date +%F) # echo $ctime 2020-09-24 # sctime=`date +%F` # echo $sctime 2020-09-24 # # touch $(date +%F).txt # sg=zhanghuayou # echo $sg zhanghuayou # echo $sg1 ​ （注：该行输出为空） # echo ==${sg}==1 zhanghuayou1 # 删除/bak目录下七天前的备份文件 find /bak -type f -mtime +7 -name “*.tar.gz” -exec rm -rf {} ; 脚本名字： ​ backup_log.sh 命令的嵌套 # which mkdir /usr/bin/mkdir # rpm -qf /usr/bin/mkdir coreutils-8.30-6.el8_1.1.x86_64 # softname=$(rpm -qf (whichmkdir))（注：(which mkdir)) （注：(whichmkdir))（注：( ) 好，可以嵌套） # echo $softname coreutils-8.30-6.el8_1.1.x86_64 # softname2=`rpm -qf `which mkdir`` rpm：未给出要查询的参数 mkdir: 缺少操作数 请尝试执行 “mkdir --help” 来获取更多信息。 # 编写一个脚本实现备份/var/log目录下的所有文件到/bak目录下，要求文件名是包含当天日期，精确到秒，文件名例如：2013-6-6-2_30_20-log==.tar.gz==。同时要求删除/bak目录下七天前的备份文件，只保留最近7天的文件。 通过文件名知道使用tar命令，而不是cp # mkdir /lianxi/9_25 # cd /lianxi/9_25 # vim backup_log.sh #!/bin/bash #获得当前的时间，精确到秒 ctime=$(date +%Y%m%d%H%M%S) #备份 mkdir -p /bak tar czf /bak/${ctime}-log.tar.gz /var/log #删除7天前的备份文件，只保留最近的7天内的文件 find /bak -type f -mtime +7 -name “*log.tar.gz” -exec rm -rf {} ; 怎么验证删除7天前的文件？ 答：调时间 设置时间 -s # date 2020年 09月 25日 星期五 09:53:18 CST # date -s ‘2020-10-10’ （注：调时间） 2020年 10月 10日 星期六 00:00:00 CST # # date -s ‘2020-10-10 9:53:00’ （注：指定小时分钟秒） 2020年 10月 10日 星期六 09:53:00 CST # # date -s ‘2020-9-25 9:55:00’ 2020年 09月 25日 星期五 09:55:00 CST # # cal 看日历 calendar（日历） # cal 2020 看2020年日历","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog1.cpen.top/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"}]},{"title":"05_Linux基础-NGINX编译安装^判断是否启动^修改端口^启动停止重启^相关路径^中文乱码","slug":"Linux_基础/05_Linux基础-NGINX编译安装^判断是否启动^修改端口^启动停止重启^相关路径^中文乱码-Windows、Linux文件传输","date":"2022-09-02T04:00:00.000Z","updated":"2022-09-02T05:00:00.000Z","comments":true,"path":"posts/43579.html","permalink":"https://blog1.cpen.top/posts/43579.html","excerpt":"","text":"一. 回顾 1234567891011121314151617181920// service sshd restart 刷新sshd服务 信息会写到/var/log/messages里，tail -f /var/log/messages动态监控 /var/log/messages 记录日志// root用户有权限，可以更改普通用户密码，密码123也能成功 一个安全的密码有：大小写、数字、特殊符号、足够的长度 Sanchuang123#// 1.显示ps aux查看进程命令输出信息，从第2行到9行，并且显示行号。 ps aux|cat -n|head -9|tail -8 ps aux|cat -n|sed -n ‘2,9p’ 2.使用find命令查找出/find目录下大小大于1M并且名字里包含vmlinuz的文件 find /find -size +1M -iname “*vmlinuz*” find /find -size +1M -iname “*vmlinuz*” -exec ls -hl &#123;&#125; \\; （注1：ls -hl命令） 查找出daydayup的文件然后删除它 find / -name “daydayup” -exec rm -rf &#123;&#125; \\; （注2：字符串用””引号引起来） 3.将最近3小时内/lianxi目录下文件大小大于10K的文件 移动到/back目录下 find /lianxi -mmin -180 -size +10k -type f -exec mv &#123;&#125; /back \\; 4.查找/home目录下用户是root，文件类型是f，这2个条件必须满足，然后再满足大小大于2k或者文件名包含cali的文件中的一个条件，查找出来后，复制到/lianxi目录下。 find /home -user root -type f \\( -size +2k -o -name &quot;*cali*&quot; \\) -exec cp &#123;&#125; /lianxi \\; 二. NGINX 123456// nginx是一个web服务器软件，是使用c语言开发的软件，俄罗斯人开发 http://nginx.org/ nginx是开源免费的软件（增值的插件收费） 国内知名互联网公司都在使用nginx： 淘宝，腾讯，百度，京东，小米，美团，字节跳动，金山云，37互娱等 http://nginx.org/en/download.html 12 前端 —— web服务器 —— 后端数据库Html,css,js nginx,python mysql,redis 编译安装 1234567891011121314151617181920212223242526272829303132// 一键安装脚本 [root@sanchuang-linux nginx]# cat onekey_install_nginx.sh #!/bin/bash #↑声明脚本用bash去执行 #1.下载nginx软件包 mkdir -p /nginx2 cd /nginx2 curl -O http://nginx.org/download/nginx-1.19.2.tar.gz #2.解压,进入文件夹 tar xf nginx-1.19.2.tar.gz cd nginx-1.19.2 #3.编译前的配置 #新建用户sanchuang9 useradd sanchuang9 #安装gcc和pcre-devel软件包，因为nginx需要这些软件，解决软件的依赖关系 yum install gcc make pcre-devel zlib-devel -y #配置nginx，指定安装路径和启动nginx的用户名 ./configure --prefix=/usr/local/nginx2 --user=sanchuang9 #4.编译 make #5.编译安装 make install #6.关闭防火墙服务和设置开机不要启动 service firewalld stop systemctl disable firewalld #7.修改PATH变量，方便可以直接使用nginx echo &quot;PATH=$PATH:/usr/local/nginx2/sbin&quot; &gt;&gt;/root/.bashrc 具体步骤 1234567891011具体步骤// nginx的安装部署 #1.下载nginx软件包 mkdir -p /nginx cd /nginx（注2：进入指定路径） curl -O http://nginx.org/download/nginx-1.19.2.tar.gz（注1:curl是linux下面的字符界面浏览器） curl是字符界面的一个浏览器 （注3：-O就是下载到当前） #2.解压,进入文件夹（注3：#1完成后，nginx软件包下载完成，是一个红色的压缩包.tar.gz） tar xf nginx-1.19.2.tar.gz（注1：解压后得到一个文件夹，深蓝色。.tar.gz是linux的压缩格式） cd nginx-1.19.2（注2：进入这个得到的目录下） 12详细操作 //cd nginx-1.19.2 12 configure配置# ./configure --help（注1：告诉我们可以配置什么东西） ​ –prefix=PATH 指定安装路径 ​ --sbin-path=PATH 指定二进制程序路径 ​ --error-log-path=PATH 指定错误日志路径 ​ --pid-path=PATH 指定pid路径 ​ –user=USER 指定启动nginx的用户 ​ –group=GROUP 指定启动nginx的组 ​ --with 开启某样功能 ​ --without 禁用某样功能 详细操作 ​ 新建用户sanchuang（自动建一个同名的组） ​ # ./configure --prefix=/usr/local/nginx --user=sanchuang ​ （注1：配置nginx，指定安装路径和启动nginx的用户名）（下一步） 详细操作 ​ 解决依赖关系 1234//没有PCRE这个库 yum install gcc pcre-devel -y （devel开发包）//装好后，继续配置# ./configure --prefix=/usr/local/nginx --user=sanchuang 12345//没有zlib这个库 yum install zlib-devel -y （注1：开发库一般会提供很多的接口、很多的包、函数给我们）//装好后继续# ./configure --prefix=/usr/local/nginx --user=sanchuang ​ 生成makefile文件（配置单）后面根据这个文件编译 ​ 指定路径↓↓ ​ 编译前的配置完成，如下 1234567# 3.编译前的配置# 新建用户sanchuanguseradd sanchuang# 安装gcc和pcre-devel软件包，因为nginx需要这些软件，解决软件的依赖关系yum install gcc make pcre-devel zlib-devel -y# 配置nginx，指定安装路径和启动nginx的用户名./configure --prefix=/usr/local/nginx --user=sanchuang 12345# 4.编译（注1：源码 编译成 二进制代码）makeyum install make -y# 5.编译安装（注2：本质上是cp，编译好的二进制程序是放在当前目录下）make install（注2：make install 就是把当前下面的东西拷贝到/usr/local/niginx/下指定路径下去） 123456789// 进入/usr/local/nginx/目录（安装完成后）# cd /usr/local/nginx/# lsconf html logs sbinconf是存放nginx的配置文件html是存放网页的目录logs 是存放日志文件的目录sbin 是存放可执行程序，也就是nginx的启动程序 12345// 运行nginx程序 # cd sbin/ # ls nginx # ./nginx 运行nginx程序 ​ //接下来判断nginx是否启动 判断服务是否启动 123判断一个服务是否启动的方法：// 1.看是否有相关的进程 # ps aux|grep nginx 1234 有两个进程，主进程和工作进程（注1：有这两个进程，说明nginx程序起来了）2.看是否有进程占用的端口号 # yum install lsof net-tools -y（注2：用来看端口号的软件”） # lsof -i:80 只是看80端口被那个进程占用了（注3：两个命令都可以看端口号开没开） 1# netstat -anplut 查看本机上所有的开放的端口（注3：两个命令都可以看端口号开没开） 12345（注4：0.0.0.0表示本机上所有的ip地址，：80表示所有ip地址上的80端口）（注5：端口号在：80体现）开启了防火墙，所以Windows上的浏览器访问不过去# service firewalld stop 关闭防火墙服务# systemctl disable firewalld 设置防火墙服务开机不要启动 1如下↓↓ 123#6.关闭防火墙服务和设置开机不要启动 service firewalld stop systemctl disable firewalld 123详细操作 刚在启动nginx 是在/usr/local/nginx/sbin目录下启动的 ./nginx 怎么样让我们在任何地方敲nginx它都能找到 12 做法：修改PATH变量如下 1234#7.修改PATH变量，方便可以直接使用nginxecho &quot;PATH=$PATH:/usr/local/nginx/sbin&quot; &gt;&gt;/root/.bashrc（注1：echo 在屏幕上输出，&gt;&gt;输出重对象，追加进去，把它写到/root/.bashrc里）（注2：写脚本特别喜欢用重对象） 1234567编译安装的步骤：3部曲1. 编译前的配置 --》 生成配置单 （Makefile） ./configure --prefix=/usr/local/nginx --user=sanchuang2. 编译 --》根据配置单制作 make3. 编译安装 --》将编译好的程序安装 make install 123456改首页 # cd /usr/local/nginx/html/ # ls 50x.html index.html # vim index.html 编辑下首页文件 （注1：index.html 首页：打开网站看到的第一个页面 --》首先看到的页面） 123vim 编辑器的复制和粘贴 yy 是复制当前行（注2：按下ESC后） p 粘贴到下一行 12// vim chenpeng.html ls 12（注3：这里建的html叫什么名字，外面接的时候就要/接它）（注4：默认情况下首页都叫index.html nginx里的规定） 回顾 12345678910web服务器：网站方面的应用 web server提供网站服务server 服务器client 客户机broswer 浏览器http访问的端口是80https访问的端口是443nginx可以监听两个端口（80、443）（要记）https传输的内容经过加密，更加安全（注1：很多电商网站和银行网上支付都是https） 12345// 安装两个nginx不冲突，路径不同就行。同时启动不能占用相同的端口 nginx卸载，直接把这个目录删掉 rm -rf 脚本的意义：提前设置好的程序，按照程序去走 下到指定目录的路径 1// 80端口被占用，新建的nginx启动不了 修改 8080 端口 // 配置新的nginx使用8080端口 （注2：vim nginx.conf 80 /usr/local/nginx2/conf） ​ （注3：改端口号，改了配置文件一定要重启reload） 123456# pwd/usr/local/nginx2/conf# lsfastcgi.conf fastcgi_params.default mime.types nginx.conf.default uwsgi_paramsfastcgi.conf.default koi-utf mime.types.default scgi_params uwsgi_params.defaultfastcgi_params koi-win nginx.conf scgi_params.default win-utf 12# vim nginx.conf listen 8080; 修改端口号80为8080（注1：找到这一行，修改8080） // 启动nginx的路径 /usr/local/nginx/sbin/nginx // netstat -anplut 查看端口号 ​ 有两个nginx，一个nginx监听8080端口，一个nginx监听80端口 ​ 两个nginx不冲突，多个nginx可以共存 // 访问 ​ 192.168.0.45 ​ 192.168.0.45:8080 ​ 可以 1个机器里面跑了2个网站 启动/停止/重启 NGINX 123456789// 启动nginx # /usr/local/nginx/sbin/nginx # /usr/local/nginx2/sbin/nginx 停止nginx # /usr/local/nginx/sbin/nginx -s stop # /usr/local/nginx2/sbin/nginx -s stop 重启(重新加载) （注1：修改了配置文件一定要reload重启） # /usr/local/nginx2/sbin/nginx -s reload （注1：修改了配置文件一定要reload重启，不然不会生效） 相关路径 12345//conf 放配置文件修改nginx监听的端口号 conf/nginx.conf修改nginx首页index.html内容 html/index.html启动nginx /usr/local/nginx/sbin/nginx重启nginx /usr/local/nginx/sbin/nginx -s reload（注1：前提条件nginx启动了） 编写自己的网页 12345678910111213141516171819202122232425262728// 编写一个自己的网页 sc.html 里面需要有文字，图片，链接 /usr/local/nginx2/html （注1：存放网页的地方） # vim sc.html &lt;html&gt; （注4：html语言 有头有尾） &lt;head&gt; （注2：头部） &lt;title&gt;welcome to sanchuang&lt;/title&gt; （注3：标题） &lt;/head&gt; &lt;body&gt; （注5：body部分就是一段一段的话） &lt;p&gt;my name is chenpeng&lt;/p&gt; （注6：p段落标记，表示一段） &lt;p&gt;my phone number is 18874991147&lt;/p&gt; &lt;p&gt;&lt;h1&gt;chenpeng linux&lt;/h1&gt; （注7：h1字体加粗） &lt;p&gt;&lt;a href=&quot;https://www.qq.com&quot;&gt;qq.com&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://www.taobao.com&quot;&gt;taobao.com&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://www.jd.com&quot;&gt;jd.com&lt;/a&gt;&lt;/p&gt; （注10：链接 a标签 href） &lt;img src=&quot;linghuchong.jpg&quot;&gt;（注12：图片img src，图片放在sc.html同一文件夹下） &lt;p&gt;&lt;a href=&quot;index.html&quot;&gt;index.html&lt;/a&gt;（注13：链接到首页） &lt;/body&gt; &lt;/html&gt; （注8：ESC :w 只保存，不退出） （注9：访问 192.168.0.45:8080/sc.html） （注11：首页（样例）/usr/local/nginx/html/index.html） 修改网页不需要重新启动nginx服务,只要刷新浏览器就可以了 只有修改了nginx的配置文件，才需要重新启动nginx服务 nginx -s reload// 这是在8080端口，放到80端口操作↓↓ vim 基本使用 123456789// vim的基本使用 1.按i 进入输入模式 2.按ESC返回到命令模式 yy 复制当前行 2yy 复制两行 nyy复制多行 p 粘贴（往下粘贴) u 撤销 dd 删除当前行 2dd 删除两行 ndd删除多行 中文乱码 12345// 解决访问时中文乱码问题 &lt;head&gt; &lt;meta charset=”utf8”&gt; &lt;/head&gt; （注1：可以在Windows sublime软件写*.html文件 上传到linux /usr/local/nginx/hml 里） 三. Windows、Linux 文件传输 12345678// Windows、linux文件传输 解决文件传输的问题 1.rz 和sz # yum install lrzsz -y # rz 从windows里上传文件到linux里 receive （注3：传到你当前路径 z是模式） # sz abcd.txt 从linux里发送文件abcd.txt到windows里 send （注4:z是模式） 2.xftp传输 需要安装xftp（注1：左右边直接拖过来） 1（yum provides rz 注2：查询rz命令是哪个软件包提供的）","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog1.cpen.top/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"}]},{"title":"04_Linux基础-.&..-cat-tac-重定向-EOF-基本命令","slug":"Linux_基础/04_Linux基础-.&..-cat-tac-重定向-EOF-Shell-more-ps-less-head-tail-sed-grep-which-whereis-PATH-bash-usr-locate-find","date":"2022-09-01T04:00:00.000Z","updated":"2022-09-01T05:00:00.000Z","comments":true,"path":"posts/62964.html","permalink":"https://blog1.cpen.top/posts/62964.html","excerpt":"","text":"一. 回顾 123456789101112131415161718192021222324252627282930313233343536回顾// 将/home/目录下的所有文件和文件夹复制到/jindafu目录下 cp /home/* . -r#注：复制文件夹 接-r 递归复制(因为提到了文件夹)#注：所有 通配符*// 复制/etc/hosts文件到jindafu,不给予覆盖提醒 用cp的绝对路径 which cp 得到cp的路径 /usr/bin/cp /etc/hosts .#注：不给予提醒 输入cp命令的绝对路径 因为cp命令是别名 所有会有提醒// 将xiena目录改名为xienana mv xiena/ xienana// 将singer目录下的所有文件复制到hejiong目录下 cp haiquan/singer/* hejiong/#注：所有 通配符*#注：复制文件不接-r// 删除所有的xienana目录 find命令 或 tree查看xienana在哪 rm -rf 路径 find /hunantv/ -name “xienana” -exec rm -rf &#123;&#125; \\;// 查看目录结构 tree 查看类型 file// echo $PS1 $PS2 怎么看PS1 PS2// hostname 查看主机名// echo $SHELL 查看默认shell （是bash）// cat /ect/shells 查看机器里有哪些shell sh bash exit#/etc 存放配置文件// d 目录 - 普通文件 l 链接文件 c 字符设备文件（显示） b 块设备文件 （磁盘）// reboot 重启机器// clear 清屏// 别名 alias , unalias , vim /root/.bashrc// env 环境变量 set 所有变量 二. . … 删不掉 123// rm -rf 不会删除隐藏文件 rm -rf .lixh 删除隐藏文件 .和..删不掉 三. cat 123456// ls 查看文件夹里的内容 cat 1.查看文件里的内容 2.可以将多个文件连接到一起输出 -n, --number 给输出的行进行编号 用处2： cat tangliangfei.txt wangtc.txt （连接功能） 先将tangliangfei.txt内容输出，再将wangtc.txt内容输出 tac 与 cat 123// tac 逆序显示，从最后一行到第一行 不能接-n cat 正序显示，从第一行到最后一行 (有-n选项) 四. 重定向 1234567// &gt; 输出重定向，会覆盖原来的内容，如果文件不存在会自动新建 重定向：就是将在屏幕上输出的内容，改变输出的方向，输出到文件里 &gt;&gt; 追加输出重定向，不会覆盖原来的内容，只是在末尾追加，如果文件不存在会自动新建 &gt;会覆盖原来的内容，&gt;&gt;不覆盖，末尾追加 # cat tangliangfei.txt wangtc.txt &gt;tang_wang.txt # echo 123456789 &gt;&gt;tang_wang.txt （学会cat与&gt;、&gt;&gt;的组合） 五. here document 123// 生成指定内容的文件 --》here document --》主要用在写脚本生成指定的内容 // &lt;&lt;EOF 定义的结束字符串 当输入EOF的时候，结束 end of file 12345678910111213# cat &gt;chenpeng.txt &lt;&lt;EOF （注1：后面不一定非得EOF，但要起的有意义）&gt; chen peng （注2:1个&gt;符号，原来内容会被覆盖）&gt; jiangsu&gt; xinhua&gt; nongda&gt; linux&gt; cali&gt; EOF （注3：点回车）# cat &gt;&gt;cali.txt &lt;&lt;end（注1：2个&gt;符号，内容追加，不覆盖）&gt; sanchuang&gt; nongda&gt; changsha 六. Shell 脚本 1// shell脚本： 其实是一个文件，文件里面有很多的linux命令，这个文件可以执行，被执行的时候，会执行文件里的所有的命令 12345678910111213141516171819202122# vim first_shell.sh#!/bin/bash（注1：声明这个脚本使用的解释器是bash）mkdir -p /test（注2：存在不报错，不存在就新建）cd /testmkdir sc&#123;1..100&#125;touch pengyf&#123;1..100&#125;.txtcp /etc/hosts /testcat &gt;sanchuang.txt &lt;&lt;EOF（注3：回车后直接打，文本文件里没有提示符&gt;）sanchuang hunan changsha furongqu hunannongdafeng de yonglinuxEOF（注4：结束）echo &quot;####################################&quot;cat -n sanchuang.txt echo &quot;####################################&quot; 1脚本写好了↑↑↑ 1234567# bash first_shell.sh 执行脚本（注：内容如下）#################################### 1 sanchuang hunan changsha furongqu hunannongda 2 feng de yong 3 linux####################################// 脚本在执行的时候，是从第1条命令，自上而下执行，如果中间有命令执行失败，后面的命令还是会执行的（Python中间出错，没有异常捕获的话，不再执行） 七. more 123456// more命令 分页显示 （注1：没有-n选项，cat有-n选项） 用途：全屏方式分页显示文件内容交互操作方法： 按Enter键向下逐行滚动 按空格键向下翻一屏、按b键向上翻一屏 back 按q键退出 （注2：显示完自动退出，与less的差别） 1# more messages 八. ps aux 1234// # ps aux 查看linux当前运行的进程的信息--》任务管理器（ps -aux也可以） # ps -aux|more # cat messages |more 和 more messages 一样 # cat -n messages |more 显示行号 九. less 1234567// less命令 用途：与more命令相同，但扩展功能更多 交互操作方法： 与more命令基本类似，但个别操作会有些出入 【page down】【page up】上翻下翻页（注1：more不支持） 显示完不退出，按q退出 （注2：与more的差别） （注3：也支持空格、b、Enter，凡是more支持的less都支持） 12# less messages # cat messages |less 十. head 1234// head命令（注1：默认取前10行，连续的几行） 用途：查看文件开头的一部分内容（默认为10行） 格式：head -n number 文件名 格式：head -数字 文件名 1234cat -n passwd |head 显示前10行，有编号head passwd 显示前10行，没有编号head -5 passwd 显示前5行（没编号）head -n 5 passwd 显示前5行（没编号，与上一条命令效果一样） 十一. tail 123456// tail命令 用途：查看文件结尾的少部分内容（默认为10行） 格式：tail -n number 文件名 格式：tail -数字 文件名 tail -f 文件名 = tailf # 注：tailf不知道怎么用 #注：tail -f 动态的监控文件末尾的变化 12345678910111213141516tail passwd 取末尾10行（无编号）cat -n passwd |tail 取末尾10行（有编号）cat -n passwd |tail -5 取末尾5行（有编号）cat -n passwd |tail -1 最后1行（有编号）cat -n passwd |tail -n 3 取末尾3行（有编号）tail -n 2 passwd 显示最后2行tail -n -2 passwd 与上条效果一样tail -n +2 passwd 显示从第2行到末尾 （注1：用处：统计有多少行的时候，不想显示首行，统计磁盘挂载的时候不想看到标题这一行） （注2：df -Th 显示linux里的磁盘分区的使用情况） df -Th|tail -n +2 统计磁盘挂载不显示标题行 df -Th|tail -n +2|wc -l 统计行数# tail -f feng.txt 动态的监控文件末尾的变化（注4：经常用来查看日志文件的变化，根据日志的记录去排错）（注2：重新打开窗口连过去，右边修改文件内容，左边动态监控文件末尾的变化，一有新的内容就显示）（注3：Ctrl+C 强行终止） 1234tail -f 扩展 特别适合看某些日志文件 /var 存放动态变化的文件 variable 变量，变化的，可变的 log 日志：是程序记录它发生的事情 123# cd /var/log （注1：/var/log 存放大量日志文件）# tail -f secure 查看secure日志文件 （注2：secure 安全）（注3：别的窗口做操作，日志文件末尾动态更新） 十二. sed 1234567891011121314151617181920212223242526 1.取出passwd的第3行 # cat -n /etc/passwd|head -3|tail -1 （注1：先取前3行，再取最后1行，用|管道） # cat /etc/passwd|head -3|tail -1 （注2：与上面命令比，没有编号3） 2.取出passwd文件的第5行到10行 #注：这种 先看末尾 用head 因为行数是从前到后计算的 # cat -n /etc/passwd|head |tail -6 （注3：先head取默认前10行，再取后六行） （注4：从第5行到10行，tail -6，不是-5） # cat -n messages |head -200|tail -101 （100到200行） 3.取出第3行，第5行，第10行 # sed -n &#x27;1p;3p;5p&#x27; passwd （注5：-n是选项，符合要求的选项显示出来，不是显示行号的意思） 练习3扩展 // sed -n 作用：只是显示符合要求的行（注9：不符合要求的行不显示） 1p;3p;5p 1p 显示第1行 p 是print命令 ; 命令连接符号 # cat -n passwd |sed -n ‘1p;3p;5p’ （注6：显示1、3、5行，有编号） # sed -n &#x27;1p;3p;5p&#x27; passwd （注7：没有编号） （注10：用双引号””也可以） # cat -n passwd |sed -n &#x27;3p;5p;10p&#x27; 显示不连续的3,5,10行的内容 (这样写显示行号) # cat -n passwd |sed -n &#x27;3,10p&#x27; 显示第3行到第10行的内容，中间是连续的 # cat -n passwd |sed &#x27;3,10p&#x27;（注8：sed后不接-n的话，会显示所有的行[包括不符合要求的行]，只不过3到10行输出两遍，所有一定要接-n）总结：sed 1.显示连续的 2.显示不连续的 十三. grep 123456// grep 文本过滤 （过滤的是文件，不是文件夹目录） grep “root” /etc/passwd 包含root的行 grep “^liang” /etc/passwd 以liang开头的行 grep “bash$” /etc/passwd 以bash结尾的行 Ctrl + c 终止// 文本处理三剑客 sed grep awk 十四. which 1234567891011121314151617181920212223which 查找可执行文件并显示所在的位置 搜索范围由PATH环境变量指定 # which mkdir /usr/bin/mkdir # cd /usr/bin/ # ll mkdir -rwxr-xr-x. 1 root root 195192 4月 10 02:53 mkdir rwxr-xr-x 权限 r 读 read --》cat vim w 写 write --》 vim &gt;&gt; x 执行 execute ---》运行 # ll first_shell.sh -rw-r--r--. 1 root root…… （注1：脚本无可执行权限） # bash first_shell.sh （注2：用bash去执行它） # chmod +x first_shell.sh （注3：给它可执行权限） -rwxr-xr-x. root root…… （注4：有可执行权限了） # ./first_shell.sh （注5：直接执行，直接在当前终端执行，当前bash执行） # /lianxi/first_shell.sh （注6：接绝对路径，接文件，直接执行） # chmod -x first_shell.sh （注7：取消可执行权限） # /lianxi/first_shell.sh -bash: /lianxi/first_shell.sh: 权限不够 （取消可执行权限后不能直接执行） whereis 12345678910111213// whereis 查找命令放到哪里（注1：跟which很像）（注2：没什么用，man手册在哪里不是很重要） # whereis mkdir mkdir: /usr/bin/mkdir /usr/share/man/man1/mkdir.1.gz （注2：压缩文件，是它的文档） 1.查看命令安放路径 2.该命令man手册的路径（man的时候看的内容的存放路径） //whereis和which的区别 Which不显示man手册的路径，whereis显示man手册的路径 # whereis mkdir mkdir: /usr/bin/mkdir /usr/share/man/man1/mkdir.1.gz # which mkidr /usr/bin/mkdir //whereis和which 都是到PATH变量里去找的 （共同点） 十五. PATH 12345678//PATH是路径which命令在查找命令的时候，会到PATH变量指定的路径下查找# which fengdeyong/usr/bin/which: no fengdeyong in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)(备注1：红色为路径 备注2：多个文件夹用：冒号隔开)# echo $PATH （注3：$PATH 引用PATH变量）/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin查找的顺序是从左往右找，如果在第1个里面找到了，就不会往后面找，以此类推 深入理解 PATH 变量的作用 1.编写一个schello.c的文件 123456789# vim schello.c （注1：编写脚本如下）#include&lt;stdio.h&gt;int main()&#123; printf(&quot;hello,world\\n&quot;); （注2：\\n 换行） printf(&quot;i am cali\\n&quot;); return 0;&#125;# file schello.c schello.c: C source, ASCII text （注3：C语言文件，文本文件，机器不能识别） 2.编译成二进制程序文件 gcc 是linux里的一个编译器，将c源码文件编译成二进制文件 gcc 是linux里的一个编译器，将c源码文件编译成二进制文件 12345678910111213# yum install gcc -y# gcc -o schello schello.c （注1：-o 输出一个二进制文件）（注2：编译schello.c的命令）# ls （↑↑注3：schello产生的文件，schello原来文件）schello schello.c （注2：生成绿色可执行权限的文件 schello）# ll总用量 20-rwxr-xr-x. 1 root root 12744 9月 18 15:12 schello-rw-r--r--. 1 root root 93 9月 18 15:08 schello.c# ./schello （注4：./ 运行）# /lianxi/sc/schello （注5：绝对路径运行，./相对路径或绝对路径都可以运行）# schello 不能运行 （注6：linux不知道schello放在哪里，它只会到PATH变量里去找）-bash: schello:未找到命令 （注7：PATH变量没有当前所在路径，没有/lianxi/sc）（解决如下） 要让 Linux 系统知道我们的命令在哪里？ 1234567891011121314151617181920212223242526271.适应PATH变量，将我们的命令复制到PATH变量已有的路径下# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin# cp schello /usr/local/bin/# schello （注1：成功运行）hello,worldi am cali# which schello/usr/local/bin/schello （注2：复制到PATH变量的路径下后bash可以找到schello）2.修改PATH变量，添加我们自己的命令所在的路径①临时修改PATH变量# PATH=/lianxi/sc:$PATH 临时修改PATH变量（注3：先引用PATH变量的值，在和/lianxi/sc:字符串拼凑在一起再赋值给PATH变量）（注3：$PATH——》/lianxi/sc:+$PATH重新组合——》赋值PATH变量 从右到左）# echo $PATH/lianxi/sc:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin（注4：新的PATH变量，前面多了/lianxi/sc:）[root@sanchuang-linux sc]# which schello（注5：which 可以找到）/lianxi/sc/schello# schello （注6：bash可以运行）hello,worldi am cali②永久有效修改文件，添加PATH变量，让它永久生效# vim /root/.bashrc .bashrc这个文件是linux系统开机启动或者用户登录都会运行这个文件里的命令，所以才会永久有效PATH=/lianxi/sc:$PATH （注1:打进去，放到最后一行） 12345678910111213// mkdir 用C写的// # yum install python3 -y 安装python3软件 # python3 （注1：进入Python3解释器） &gt;&gt;&gt; a = 10 （注2：提示符&gt;&gt;&gt;） &gt;&gt;&gt; b = 20 （注4：Python不需要编译，Python代码直接运行，用Python解释器去解释） &gt;&gt;&gt; sg = &quot;tangliangfei&quot; &gt;&gt;&gt; c = a + b &gt;&gt;&gt; c 30 &gt;&gt;&gt; print(sg) （注3：输出） tangliangfei &gt;&gt;&gt; exit() （注5：exit()退出出 exit()是exit函数） 1234567891011121314151617181920212223242526272829303132333435//扩展.py结尾的文件，是python程序文件.sh结尾，shell脚本.c结尾，c语言# vim sc_py_hello.py#!/usr/bin/python3 （注1：which python3——》/usr/bin/python3） （注2：申明脚本是Python脚本，里面的命令用Python3解释器去解释）username = input(&quot;please input your name:&quot;)（注3：引号里面只是提示符，提示输什么） （注4：input()函数会接收你输入的东西，赋值给username）age = input(&quot;please input your age:&quot;)print(f&quot;your name is &#123;username&#125; ,your age is &#123;age&#125;&quot;)（注5：print(f ) 语法） （注6：&#123;username&#125;&#123;age&#125; 引用变量的值）# lsschello schello.c sc_py_hello.py# python3 sc_py_hello.py （注7：直接执行Python3，类似于bash a.sh）please input your name:caliplease input your age:18your name is cali ,your age is 18[root@sanchuang-linux sc]# cat sc_py_hello.py # /lianxi/sc/sc_py_hello.py （注1：不能直接运行，如下 权限不够，pwd查看路径）-bash: /lianxi/sc/sc_py_hello.py: 权限不够# chmod +x sc_py_hello.py （注2：给它可执行权限）# /lianxi/sc/sc_py_hello.py （注3：可以直接执行了）please input your name:wangtcplease input your age:18your name is wangtc ,your age is 18//怎样让sc_py_hello.py 在PATH变量里运行 # which sc_py_hello.py （注1：能运行，因为之前在PATH变量里已经添加这个路径了(/lianxi/sc)） # sc_py_hello.py （注2：能运行，因为之前在PATH变量里已经添加这个路径了(/lianxi/sc)） # echo $PATH /lianxi/sc:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin 123456789101112131415 总结：跟是用什么语言写的关系不大 1.把它放到PATH变量所在的路径里面，并2.给它可执行权限 就能直接运行 # chmod -x sc_py_hello.py （注3：取消可执行权限） # sc_py_hello.py （注4：不给它可执行权限，路径放在PATH变量所在的路径下，也不能直接执行）-bash: /lianxi/sc/sc_py_hello.py： 权限不够 总结：写的Python程序，一定要1.给它可执行权限，并2.把它放到PATH变量所在路径下面，不然不能执行 //扩展 （注2:总结:文件名字很长，想敲个短一点的命令，考虑用别名 [快捷键]） # alias sc_py_hello=sc_py_hello.py 定义别名，可以缩短命令的长度 # sc_py_hello（注1：不想输这么长，可以使用别名，别名可以用来偷懒） please input your name:feng （运行成功，条件是在PATH变量路径下和可执行权限，如上面的操作） please input your age:19 your name is feng ,your age is 19 # which sc_py_hello alias sc_py_hello=&#x27;sc_py_hello.py&#x27; /lianxi/sc/sc_py_hello.py 十六. bash 123//bash 是linux非常好的shell解析器 （注1：2件事要做） 1.查找命令 --》PATH变量的路径下 2.告诉内核去启动命令（运行这个命令） 十七. /usr 123// /usr 存放linux程序的目录 unix system resource /usr/bin 存放二进制程序，所有的用户都可以使用 binary /usr/sbin 存放二进制程序，有比较高的权限（root）的用户执行的程序 super user binary 1234567# which useradd（注1：查找useradd命令路径）/usr/sbin/useradd （注2：存放在sbin目录下）# su - xulilin （注3：切换为普通用户）$ which useradd$ /usr/sbin/useradd$ useradd xu123 （注4：普通用户不能执行sbin/下高级别命令）……报错useradd:Permission denied （注5：权限被拒绝） 十八. locate 123456// locate 知识点（注4：需要安装）（注5经常需要更新# updatedb）# yum provides locate -y 查询locate是哪个软件包提供的（注1：新知识点）mlocate-0.26-20.el8.x86_64 : An utility for finding files by name（注3：yum provides …… -y 查询某命令是哪个软件包提供的）（注2：从结果知道 mlocate提供locate命令）# yum install mlocate -y 安装mlocate软件 123456789locate命令格式：locate 文件名（注5：locate是到自己的数据库查找的，能具体到/下面，且必须更新自己的数据库）根据每天更新的数据库(/var/lib/mlocate)查找，速度块 /var/lib/mlocate/mlocate.db database 数据库（注6：db的解释）数据库里的内容还是根据/目录下的内容生成每天会自动更新数据库 /var/lib/mlocate/mlocate.db手动更新数据库updatedb 123456789101112# updatedb 生成和更新数据库mlocate.db （注1：手动更新）# cd /var/lib/mlocate/# lsmlocate.db# locate mkdir（注2：将linux系统里面文件名里面包含了mkdir的文件全部找出来）/usr/bin/mkdir/usr/lib/python3.6/site-packages/pip/_vendor/lockfile/mkdirlockfile.py/usr/lib/python3.6/site-packages/pip/_vendor/lockfile/__pycache__/mkdirlockfile.cpython-36.opt-1.pyc/usr/lib/python3.6/site-packages/pip/_vendor/lockfile/__pycache__/mkdirlockfile.cpython-36.pyc/usr/share/man/man1/mkdir.1.gz# which mkdir（注3：只是找到/usr下的mkdir，其他地方的mkdir没找出来）/usr/bin/mkdir 12345678locate查找的范围： /--》mlocate.db里去查找（注2：在 根下面自己的数据库mlocate.db下面去查找） 方式：模糊查找，文件名里包含就可以 缺点：新的文件，有时候找不到，因为没有更新数据库 --》updatedb（注3：手动更新） 可以查找任何文件（注4：新建的文件，# updatedb手动更新数据库，否则找不到）which 查找的范围：PATH变量 方式：精确查找（注1：文件名必须一模一样） 只能查找命令 which、whereis、locate、find 123// which、whereis、locate、find 命令查找类 Which、whereis 只能找命令 loacte 也可以查找普通文件、可以查找任何文件 十九. find //* find命令 ​ 格式：find [查找范围] [查找条件] [动作] ​ find 可以找1.命令、2.文件 （即任何文件） ​ （注1：融合了which、whereis、locate所有功能） ​ find命令 ​ 用途：用于查找文件或目录 ​ 格式：find [查找范围] [查找条件] [动作] ​ 常用查找条件 ​ -name：按文件名称查找 ​ -iname：按文件名称查找,不区分大小写 ​ -size： 按文件大小查找 ​ -user： 按文件属主查找 ​ -type： 按文件类型查找 ​ -perm ：按文件权限查找 ​ -mtime ：按文件更改时间查找 ​ -newer：按比某个文件更新的查找 123456789101112-name和-iname # find /lianxi -name &quot;lixh.txt&quot;（注1：精确查找，-name根据文件名来） /lianxi/lixh.txt # find / -name &quot;schello&quot;（注2：精确查找，可以/下查找） /lianxi/sc/schello # find / -name &quot;schello*&quot;（注3：*模糊查找，可以/下查找） /lianxi/sc/schello.c /lianxi/sc/schello # find / -name &quot;li*.txt&quot;（注4：*模糊查找） # find / -iname &quot;lixh.txt&quot; （注5：-iname 查找的文件名不区分大小写） /lianxi/lixh.txt /lianxi/LIXH.TXT 12345678-size （大小） # ll -h 看文件夹下的每个文件的大小 # du -a 查看文件夹下的每个文件的大小（单位KB） du -ah 查看文件夹下的每个文件的大小 （单位K、M、G） # find /boot -size +1M（注1：+1M 大于1M的 全部找出来）（注2：-1M、1M：小于1M，等于1M） /boot/grub2/fonts/unicode.pf2 （注3:查找的结果不是特别精准） /boot/initramfs-4.18.0-193.el8.x86_64kdump.img /boot/initramfs-4.18.0-193.el8.x86_64.img 12345678-type （类型） # find . -type d （注1：查找目录） # find . -type f （注2：查找普通文件） # find . -type l （注3：链接文件） # find . -type c （注4：字符设备文件） # find . -type b （注5：块设备文件） # find . -type p （注6：管道文件） # find . -type s （注7：socket文件）（进程与进程通信的文件） 123456-mtime （以24小时为单位） 按文件更改时间查找-mmin （以分钟为单位） # find . -time +1 1天以前 # find . -time -1 1天以内 # find . -mmin -30 30分钟以内 # find . -mmin +30 30分钟以前 123-user （属于哪个用户创建的文件）（用处不大） # find . -user root # find / -user cali 12-newer （比指定文件更新的文件，后建的文件） # find . -newer feng.txt 1234567891011121314// 特殊查找条件-o ：逻辑或，只要所给的条件中有一个满足，寻找条件就算满足 or-not :逻辑非，在命令中可用“!”表示。该运算符表示查找不满足所给条件的文件-a：逻辑与，系统默认是与，可不加，表示只有当所给的条件都满足时，寻找条件才算满and find /boot -size +1024k -a -name “vmlinuz*”（注1：逻辑与 -a可不加，系统默认逻辑与） find /boot -size +1024k -o -name “vmlinuz*” find . -user nie -type f -size +1k -o -name &quot;vmlinuz*&quot; find . -user nie -type f \\( -size +1k -o -name &quot;vmlinuz*&quot; \\) （注3：()改变了优先级,\\解释在下方）（注5：\\( \\)即() 改变了优先级） find /home ！-user hello -exec ls -ld &#123;&#125; \\;\\ 转义字符 （注2：因为小括号()有特殊作用，接上/以后让它表示只是小括号）默认情况下-a的优先级高，先执行逻辑与（-a），再执行逻辑或（-o）# find / -iname &quot;*.conf&quot; -size +1k -type f -user root -o -size +10M（注4：前面先组合成一个条件，要么满足-o前面的，要么满足-o后面的条件） 1234567891011121314151617// 扩展，接上面的命令 -exec 和 -ok # find /lianxi -name &quot;li*.txt&quot; -exec rm -rf &#123;&#125; \\;（注1：前面是查找，-exec表示要执行的动作）相关解释如下 -exec 执行后面的命令 rm -rf 具体删除命令 &#123;&#125; 代表前面的find查找出来的内容，理解为一个容器存放前面find查找到的内容 \\; 表示find命令结束符号 # find /lianxi -name &quot;*.txt&quot; -size +1k -type f -exec cp &#123;&#125; /fengdeyong \\; （注2：文件名.txt结尾的，大小大于1k的，文件，拷贝到fengdeyong里面） （注3：find 找/lianxi 下的每一层） -ok -ok 让你确认一下，再执行 # find . -name &quot;*wang*&quot; -ok rm -rf &#123;&#125; \\; &lt; rm ... ./wangtc.txt &gt; ? y &lt; rm ... ./tang_wang.txt &gt; ? y总结：-exec执行命令，不给与确认（写脚本常用，方便） -ok 执行命令，需要确认 1234567891011121314151617181920212223242526272829-maxdepth 查找文件时，目录的深度 # find . -name bb ./aa/bb ./aa/bb/bb ./bb # find . -maxdepth 1 -name bb（注2：只挖1级） ./bb # find . -maxdepth 2 -name bb（注3：只挖2级） ./aa/bb ./bb # find . -maxdepth 3 -name bb（注4：只挖3级） ./aa/bb ./aa/bb/bb ./bb （注1：不接-maxdepth的话，有多少层挖多少层） # find /lianxi -name &quot;*.txt&quot; （注6：不接-maxdepth，东西太多了，挖的太深了） /lianxi/tangliangfei.txt /lianxi/chenpeng.txt /lianxi/cali.txt /lianxi/feng.txt /lianxi/aa/bb/feng.txt /lianxi/aa/feng.txt # find /lianxi -maxdepth 1 -name &quot;*.txt&quot; （注5：这种情况用的多，只想找1层的，只挖/lianxi下面的，子文件夹、子子文件夹下面都不要） /lianxi/tangliangfei.txt（注7：显示如下） /lianxi/chenpeng.txt /lianxi/cali.txt /lianxi/feng.txt 12345678910// ！取反 的使用，接上面的命令（注1：lianxi下面的不是*.txt的） # find /lianxi -maxdepth 1 ! -name &quot;*.txt&quot;（只对后面的条件取反） /lianxi /lianxi/passwd /lianxi/first_shell.sh /lianxi/messages /lianxi/sc /lianxi/LIXH.TXT /lianxi/aa /lianxi/bb","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"}]},{"title":"03_Linux基础-文件类型-主辅提示符-第1提示符-3个时间-stat-其他基础命令","slug":"Linux_基础/03_Linux基础-文件类型-主辅提示符-第1提示符-Linux命令-内外部命令-快捷键-改为英文编码-3个时间-stat-其他基础命令","date":"2022-08-30T04:00:00.000Z","updated":"2022-08-30T05:00:00.000Z","comments":true,"path":"posts/43225.html","permalink":"https://blog1.cpen.top/posts/43225.html","excerpt":"","text":"一. stat 与 ll 1234567// stat 与 ll stat 只能看自己。 ll能看文件夹下面的东西。// 选项组合（不分先后顺序） 如 ls -Al （2个功能一起显示）// du -sh 统计文件和文件夹大小// mkdir -p 如果父目录不存在，就新建 如果文件夹存在，就不报错 // 写脚本经常用到 -v 给提醒（显示已经创建成功）（没什么用） stat 与 ll 与 ls -l -d 1234// stat 与 ll 与 ls -l -d stat 只能看本身的文件信息（文件夹本身） ll 能看文件夹下面的东西（文件夹里面的） ls -l -d 只看它自己的详细信息 不看里面的（文件夹本身） 二. 集合 1条命令建多个文件夹 123#注：关键点&#123;&#125;// mkdir hunantv/&#123;weishi,jingshi,dushi&#125; 一条命令建多个文件夹 在 China_voice路径下建 hunantv文件夹下的 文件夹（hunantv在 China_voice下） 1&#123;weishi,jingshi,dushi&#125; 表示一个集合，有共同的上一级目录 123 只建一个文件夹的时候，不能用 &#123; &#125; 括起来，&#123; &#125; 会成为文件名。// 一条命令完成（日常用的不多） 里面有好几级 父目录不存在时候 接 -p 选项 三. {1..100} 1234567891011#注：mkdir sc&#123;1..100&#125;#注：rm -rf sc&#123;1..100&#125;// mkdir sc&#123;1..100&#125; 产生1到100的文件 &#123;1..100&#125; 代表 1 到 100的集合 和前面的sc 组合 mkdir 可以一次性建立多个 的功能 // rm -rf sc&#123;1..100&#125; rm -rf sc* 2种都能删// mandatory 命令的 arguments 参数// mkdir -p 如果父目录不存在，就新建 如果文件夹存在，就不报错 1// mkdir -v 给提醒 四. du -sh 12// du -sh 查看目录大小 命令 选项 参数 五. cd 1234567891011121314151617181920// cd - 返回上一次所在的路径 cd . 进入当前目录 cd .. 返回到上一级目录 cd ~ 返回到当前用户的家目录 cd 返回到当前用户的家目录cd命令用途：切换工作目录（Change Directory） 格式：cd [目录位置]#注：特殊目录 . 当前目录.. 上一级目录~ 用户主目录（家目录）- 上一次所在的工作目录（遥控器上的返回键）// useradd xulilin 新建用户 cd ~xulilin 进入xulilin这个用户的家目录 [root@localhost xulilin]# pwd /home/xulilin// mkdir 新建目录 touch qijian 新建空文件 touch hengshan/yilin.txt 六. cp -r 12// cp /etc/hosts songshan/ 复制文件不接 -r cp hengshan/ songsahn/ -r 复制文件夹接 -r 七. file 1// file taishan 查看文件类型 八. 文件类型 123// 经典文件类型：目录 directory 空文件 empty 文本文件 text 12// du -sh taishan/ 查看文件大小// rm -rf tianshan/ 删除 九. cp 123456// cp 复制的时候： 复制，粘贴，重命名一步到位（重命名要后面不存在） cp a.txt abc.txt （目录下有2个文件 a.txt abc.txt） cp a.txt songshan/feng.txt （复制到songshan下改名叫feng.txt） cp hengshan/ songshan/nanyue_hs -r（复制文件夹接-r） 复制hengshan到songshan下 改名nanyue_hs 十. mv 1234// mv 剪切，粘贴，重命名一步到位（重命名要后面不存在） mv a.txt hengshan/aaa.txt （剪切粘贴，重命名为aaa.txt） mv songshan/ hengshan/shaolinshi （移动粘贴重命名为shaolinshi） 移动重命名不需要接-r选项（与 cp 的不同点） 十一. 主辅提示符 12// 主提示符 [登录用户@主机名 工作目录] 12345678 辅助提示符 # $ [root@localhost xuxia]# [root@localhost wuxia]# [xulilin@localhost ~]$ // linux是一个多用户多任务的操作系统 root用户家目录 /root 普通用户家目录 /home下面跟用户名同名 十二. echo 12// echo 输出 相当于print PS1 是linux系统里内置的一个变量，不需要我们定义 十三. 第1提示符 1第1提示符变量 PS1 prompt symbol 提示 符号 variable 变量 [\\u@\\h \\W]$解释 123456789// # echo $PS1 # 注：第一提示符 [\\u@\\h \\W]\\$ 解释： \\u 引用当前的用户 user \\u the username of the current user \\h 引用当前的主机名 hostname \\W 引用当前工作的目录的名字 working \\$ 当用户为root的时候，就输出#,如果不是root就是$符号 \\t 当前的时间 临时修改PS1变量 1// # PS1=&#x27;[\\h@\\u \\t@\\W]\\$&#x27; 临时修改PS1变量（没必要改知道就行） \\t 当前的时间 123[localhost@root 11:01:07@~]#[localhost@xulilin 11:03:08@boot]$PS1=&#x27;[\\h#\\u \\t@\\W]\\$&#x27;[localhost#xulilin 11:03:32@boot]$ // # 也可以 第1、2提示符 12345// # echo $PS1 [\\u@\\h \\W]\\$ # echo $PS2 第2提示符 &gt;// 一行没输完 会显示第2提示符&gt;（只是提醒的作用） 十四. $+变量名 12345678910 $PS1 $+变量名 引用某个变量// # echo $PS1 [\\u@\\h \\W]\\$// sg=&quot;tangliangfei&quot; 定义一个变量sg 赋值tangliangfei 右边赋值左边 echo $sg 输出sg这个变量的值 shell编程里引用变量需要接$+变量名 Shell编程 linux里的命令编程// mv=&quot;liangly&quot; echo $sg $mv tangliangfei liangly （都显示） 十五. id 123456// id 命令 [root@localhost china_voice]# id uid=0(root) gid=0(root) 组=0(root) 环境=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 root用户 uid 为0 user id 用户的编号 uid group id 组的编号 gid 十六. Linux命令 123456789101112131415// Linux命令 用于实现某一类功能的指令或程序 命令的执行依赖于解释器程序（例如：/bin/bash）// 人 &lt;——&gt; bash &lt;——&gt; 内核 &lt;——&gt; 硬件 bash 就是解释器 相当于翻译 C语言写的 程序 工具 Linux命令的分类 内部命令：属于Shell解释器的一部分 外部命令：独立于Shell解释器之外的程序文件// shell：是一类程序，用来解释用户输入的命令，然后告诉内核去执行这些命令 bsh sh csh bash ksh bash是最流行的shell--》几乎所有的linux系统默认的shell都是bash 1人——BASH——kernel 1（大概了解） 十七. cat /etc/shells 1234567// cat /etc/shells 查看本机里有哪些shell /bin/sh 比较老的shell /bin/bash /usr/bin/sh /usr/bin/bash// sh 敲sh，使用sh，没有提示符，退出去 敲bash 或者 exit （父子进程）// 切换shell sh 和 bash 命令 exit 十八. ln -s 123456#注：链接文件 天蓝色// ln -s ln 创建链接文件（快捷方式） 不要去删除原文件，不然会导致链接文件不可用 (一闪一闪 冒红) ln -s 源文件 链接文件 ln -s xulilin xll -s symbol link 符号链接（软链接 soft） 1234# mkdir changsha# ln -s changsha cs # lllrwxrwxrwx. 1 root root 8 9月 17 11:19 cs -&gt; changsha 十九. echo $SHELL 12// # echo $SHELL 查看linux系统里默认的shell /bin/bash 二十. env 123// # env 查看当前用户的环境变量（linux系统里预先定义的变量） environment 当前用户的很多进程都可以使用的变量 环境变量--》全局变量 二一. set 1# set 查看所有的变量（自定义变量和环境变量） 二二. 内部外部命令 123456// bash - GNU Bourne-Again SHell BASH_BUILTINS builtin 内置（内部） built in 额外安装的命令--》外部命令 通过安装bash这个程序就可以得到的命令--》bash的内部命令 yum install tree -y tree命令是外部命令，需要额外安装 mkdir ip 外部命令 cd echo exit 内部命令 二三. which 12// which bash 查看bash命令存放在哪里 /usr/bin/bash 二四. rpm rpm -qf 1234#注：rpm -qf 查询命令通过那个软件包安装过来的#注：先用which 查看命令的绝对路径// rpm -qf /usr/bin/bash 查询/usr/bin/bash是通过哪个软件包安装过来的 bash-4.4.19-10.el8.x86_64 rpm 1234567// rpm 是linux里的软件管理的命令，例如安装，卸载软件 -qf 查询文件是通过那个软件安装过来的// # which ip /usr/sbin/ip # rpm -qf /usr/sbin/ip iproute-5.3.0-1.el8.x86_64// bin 二进制 binary 二五. /usr 12345678#注：/usr 存放安装软件的目录 unix system resource// /usr 是linux里存放安装软件的目录 unix system resource unix 系统资源 相当于windows里的Program Files// 链接文件 浅蓝色 正常文件 深蓝色// / 根目录 /root root用户的家目录 /home/用户名同名的目录 普通用户的家目录 二六. / 与 /root关系 1234// 根目录和root用户的家目录的关系？ /root 在/目录下，是包含关系// ~ 代表家目录，当你所在的文件夹的路径是家目录，就会显示 ~ 普通用户只能进自己家目录，root用户能进任何家目录↓↓↓ 进入其他用户家目录 123456789[xulilin@localhost /]$ cd ~xulilin # 注：普通用户只能进自己家目录[xulilin@localhost ~]$ cd ~cali-bash: cd: /home/cali: 权限不够[xulilin@localhost ~]$ exit注销[root@localhost ~]# cd ~cali[root@localhost cali]# pwd/home/cali[root@localhost cali]# 二七. hostname 12// # hostname 查看主机名 localhost.localdomain 临时、永久修改主机名 临时修改 1234// # hostname sanchuang-linux 临时修改主机名（不能用下划线_） 接着重新登录 su - root （当前终端登录）/ 或者重新建立一个连接（开一个终端登录） 重启后失效// 为什么要修改主机名？ 方便识别，区别不同的服务器 永久修改 12345678910//* 永久修改主机名 # vim /etc/hostname 改这个文件，打个新名字。 # cat /etc/hostname sanchuang-linux 重启后生效// reboot 重启// 不一定非得 虚拟机 登录后 xshell才能登录// 提示符 PS1 第一提示符 PS2 第二提示符 二八. vim 12345678910// vim编辑器的使用 vim 是linux里的字符界面的文本编辑器 ——》记事本 只能写文字 安装vim yum install vim -y// vim sc.txt 1.按字母键i进入输入模式 insert 2.输入内容，可以是中文或者英文 3.按ESC键，返回到命令模式 escape 离开，逃离 4.输入:wq 退出并且保存 write quit :q! 退出不保存 :q 退出（没有修改可以退出） 二九. cat 1// # cat sc.txt 查看文本文件里的内容 三十. 快捷键 123456789// 快捷键 // ctrl + l // ctrl + c 强行终止命令 # ^ C 比如 ping www.baidu.com ctrl + c // tab 补齐命令 # mkd （之后按2下tab键）mkd开头的命令都列出来了 补齐路径 # mkdir wang 唯一性就直接补齐 否则敲两下 列出wang… 能识别唯一性的时候，按一次tab键 不能识别唯一性的时候，需要按2次，然后自己输入 // 上下方向键，可以调用以前使用过的命令 三一. pwd 123456// pwd 查看工作目录 cd 切换工作目录 cd ~ （cd） 进入用户家目录 cd - 返回上一次目录 cd ~ liangluyao 进入liangluyao家目录 cd .. 返回上一级目录 三二. 别名 123456// ll 是 ls -l --color=auto的别名// # alias 查看linux里有哪些定义好的别名// # alias c=clear 临时定义c是clear的别名 clear 是linux系统里的命令 命令有选项的 要同’ ’ （单引号）引起来 再开启一个终端 就没效了 临时定义 c是自定义的名字，定义别名的时候，不要和系统里已经存在的命令冲突 取消别名 123// unalias 取消别名 # alias mkdir=ls # unalias mkdir 取消别名 永久修改别名 12// # vim /root/.bashrc 永久修改别名，需要重新登陆，或者su切换用户到root .bashrc 是一个隐藏文件 按i进去 进行别名定义——》ESC :wq 三三. ls 1234567891011121314151617181920212223// ls命令 用途：列表（List）显示目录内容 格式：ls [选项]... [目录或文件名] 常用命令选项 -l ：以长格式显示 -d：显示目录本身的属性 -t： 按文件修改时间进行排序 -r ：将目录的内容清单以英文字母顺序的逆序显示 -a：显示所有子目录和文件的信息，包括隐藏文件 -A：类似于“-a”，但不显示“.”和“..”目录的信息 -h：以更易读的字节单位（K、M等）显示信息 // 必须和 -l 一起用 -h, --human-readable with -l and -s, print sizes like 1K 234M 2G etc. -R：递归显示内容 一层一层显示，作用远远不及 tree好，很繁琐// ls 查看当前 目录 ls /boot 查看/boot 下目录 ls -l -d /boot 只显示本身的文件夹信息 ls -ld / ls -dl ls -t 时间 文件修改时间排序 ls -r 英文字母 逆序显示 ls -l -h /boot 显示/boot的各个文件的大小 -h 必须和 -l 一起用 显示大小 K M G \\ls -l 1// \\ls -l 不显示列出的文件类型颜色 ls -l |grep “^d” 1234567891011121314151617181920// # ls -l|grep &quot;^d&quot; 解释如下// | 管道符号： 进程和进程之间通信的一种方式 作用:将前面一个命令的输出送给后面一个命令作为输入 中间商，借花献佛，提篮子// grep ：文本过滤的命令 会根据匹配的字符串去过滤，显示出匹配内容的行// ^d 表示以d开头的行// # ll|grep &quot;txt&quot; -rw-r--r--. 1 root root 0 9月 17 15:58 a.txt -rw-r--r--. 1 root root 0 9月 17 16:02 sc10.txt # ll|grep &quot;^d&quot; drwxr-xr-x. 5 root root 48 9月 17 09:51 hunantv drwxr-xr-x. 4 root root 42 9月 17 09:54 jiangsutv # ll|grep &quot;^-&quot; -rw-r--r--. 1 root root 0 9月 17 15:58 a.txt -rw-r--r--. 1 root root 0 9月 17 16:02 sc10.txt # ll|grep &quot;^-&quot;|wc -l 11 三四. ASCII 1234567891011// ASCII 美国信息交换标准代码 数字、大写字母、小写字母 ASCII码值 小——》大// 一个字节=8位 101010101// man ls ——》/-h 查找 -h// # man ls 回车：一行一行的往下走 /-h 查找包含-h的行 n 查找下一个 next N 查找上一个 next q 退出 三五. 文件类型 12345678// 文件类型 缩写 应用 常规文件 - 保存数据 目录 d 存放文件 directory 符号链接文件 l 指向其它文件 link 字符设备文件 c character --》与字符显示相关的文件 块设备文件 b block --&gt;存放数据的块文件 s socket文件 p 管道文件 pipe 三六. 「drwxr-xr-x. 5 root root 48 9月 17 09:51 hunantv」解释 1234567891011// [root@sanchuang-linux china_voice]# ls -l 总用量 0 drwxr-xr-x. 5 root root 48 9月 17 09:51 hunantv d 代表文件类型 directory 目录 rwxr-xr-x 权限 r 读 read w写 write x 执行 execute . 和selinux权限相关 5 文件的链接数 root 用户 root 组 48 文件大小 9月 17 09:51 文件的创建时间 三七. wc 123// wc 是一个统计命令，可以统计文件里有多少行，多少单词，多少字节 -l 统计行数 lines wc -l 统计行数 不显示文件名 123456789101112//# wc -l a.txt (wc -l 也可以统计文件的行数) 直接统计会显示文件名 3 a.txt//# cat a.txt |wc -l （cat管道传给wc 不会显示文件名） 3 //# cat /etc/passwd|wc -l 27//# cat /etc/passwd|grep &quot;liang&quot; liangluyao:x:1001:1001::/home/liangluyao:/bin/bash liangluyao2:x:1002:1002::/home/liangluyao2:/bin/bash # cat /etc/passwd|grep &quot;root&quot; root:x:0:0:root:/root:/bin/bash operator:x:11:0:operator:/root:/sbin/nologin 练习 123456789101112131415// 1.统计出/dev目录下有多少字符设备文件 ll /dev|grep “^c”|wc -l 2.统计出/dev目录下有多少块设备文件 ll /dev|grep “^b”|wc -l 3.统计/etc/目录下有多少文件夹和普通的文件 ll /dev|grep “^-”|wc -l 文件 ll /dev|grep “^d”|wc -l 文件夹 ll -R /etc|grep “^-”|wc -l 统计/etc和子文件夹下的所有普通文件 更彻底（包含子目录下） ll -R /etc|grep “^d”|wc -l 统计/etc和子文件夹下的所有文件夹 更彻底（包含子目录下） 4.统计/etc/ssh/sshd_config文件有多少行 cat /etc/ssh/sshd_config |wc -l// 统计文件夹里有多少文件 ll | grep wc // 统计文件有多少行 cat | wc 三八. du 1234567891011// du 统计目录及文件的空间占用情况 disk usage（估算值，并不是很准确） *du -sh 统计汇总的大小（常用）黄金组合 -s -s, --summarize 汇总的大小 display only a total for each argument -h -h, --human-readable print sizes in human readable format (e.g., 1K 234M 2G) -a 统计文件和文件夹 -a, --all write counts for all files, not just directories du -sh 与 ll -h 区别 1234567891011121314151617 du -sh /boot ll -h /boot// # ll -h /boot 只能统计文件的大小，文件夹里的所有的文件不会汇总 总用量 134M du -sh 可以汇总 ll -h 就是你文件里面有多少个单词 多少个字符 # du -sh /boot 140M /boot # ll -h -d /boot dr-xr-xr-x. 6 root root 4.0K 9月 13 14:38 /boot// 英文字母，数字 占1个字节 中文字母：utf8编码 3个字节 ll -h 统计的是一个文件里有多少字符 统计文件里面文字的字节数 du 统计占用多少块 统计文件存放在磁盘上消耗了多少个块// 1个块的大小就是4096 （4K） 123456// touch 新建空文件 更新时间// stat host 查看三个时间 最近访问 最近更改 最近改动 三九. 改为英文编码 1234// 改为英文编码 # LANG=en_US.UTF8 # ll hosts -rw-r--r--. 1 root root 158 Sep 17 16:57 hosts 四十. 3个时间 12345678910# stat hosts File: hosts Size: 158 Blocks: 8 IO Block: 4096 regular fileDevice: fd00h/64768d Inode: 17162314 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)Context: unconfined_u:object_r:default_t:s0Access: 2020-09-17 16:57:57.748799777 +0800Modify: 2020-09-17 16:57:57.748799777 +0800Change: 2020-09-17 16:57:57.748799777 +0800 Birth: - 123456时间： 访问时间 access time --》atime 打开这个文件 cat 修改时间 modify time --》mtime 修改里面的内容，增加，删除内容等 vim 更改时间 change time --》ctime 更改了文件的属性（名字，权限，大小，时间，用户，组） 精确到纳秒 touch hosts 三个时间都更新（都改了） 四一. chmod 12// chmod 修改权限 change mode chmod a+w hosts 1chown 修改属主和属组 change owner 12345 vim hosts 输入 ：wq 修改数据// +0800 表示东八区 中国的上海，北京 乌鲁木齐 东六区// # cp /etc/passwd . 将/etc/passwd复制到当前目录 现在我们敲的cp，都是 cp -i ，cp是别名 12345 # alias alias c=&#x27;clear&#x27; alias cp=&#x27;cp -i&#x27;-i, --interactive 交互式 prompt before overwrite (overrides a previous -n option) 四二. cp的时候覆盖文件，不给予提醒的方法 1234// cp的时候覆盖文件，不给与提醒的方法 1.取消别名 --》不推荐 # unalias cp 2.使用cp命令的绝对路径 --》推荐 12345 # which cpalias cp=&#x27;cp -i&#x27; /usr/bin/cp# /usr/bin/cp feng changsha/ -r# /usr/bin/cp feng changsha/ -r 再次复制 覆盖不给提醒","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"}]},{"title":"02_Linux基础-文件系统层次结构-提示符-进程-隐藏文件-通配符-绝对相对路径-其他基础命令","slug":"Linux_基础/02_Linux基础-文件系统层次结构-提示符-进程-命令格式-隐藏文件-通配符-绝对相对路径-{1..100}-ls-mkdir-其他基础命令","date":"2022-08-29T04:00:00.000Z","updated":"2022-08-29T05:00:00.000Z","comments":true,"path":"posts/34556.html","permalink":"https://blog1.cpen.top/posts/34556.html","excerpt":"","text":"一. 基本命令 ls 1ls --- 查看文件夹内容 ==&gt; list ls -l 1// ls -l 显示文件的详细信息 12// ls -l 显示文件的详细信息 (大概能看到文件时间 ，不详细) ll 是 ls -l 的别名 其他参数 1234-l 显示文件的详细信息 // use a long listing format ( 使用长格式显示 )-a 显示所有的文件和文件夹包括.和..-A 显示所有的文件和y文件夹，但是不包括.和.. 1// ls -a 显示所有的文件和文件夹 包括 . 和 .. mkdir 1234mkdir --- 新建文件夹 ==&gt; make directory(目录) --- mkdir可以一次性建多个文件夹 空格隔开 --- 默认情况下 新建文件夹放在你所在的文件夹里 123--- windows下 --- dir ==&gt; Windows里面显示文件夹下内容 (等同于Linux ls) --- mkdir ==&gt; Windows里建目录 mkdir -p 123// mkdir -p ( -P 的作用 ) 1 .如果文件存在就不报错 2 .当父目录不存在就新建 1234567 // -p, --parents [ 选项 ] no error if existing, make parent directories as needed 1.如果文件存在就不报错 2.当父目录不存在就新建// 参数： 参与进来的操作的对象 也可以没有 如果没有参数，当前目录就是参数 cd 1cd --- 进入目录 ==&gt; change directory to other directory pwd 123pwd --- 显示当前所在路径 print working directory name Print name of current/working directory man 123man --- 查询命令的使用手册（指南） --- 按 q 退出 quit --- manual 手册，指南 . &amp; … 123. --- 代表当前目录.. --- 代表上一级目录 ---cd .. 返回上一级目录 useradd 12useradd cpen --- 新建一个普通用户su - cpen --- 切换用户登录 12root用户的家目录在/root普通用户的家目录在/home目录下和用户名同名的目录 su &amp; exit 12345--- su - cpen 切换用户登录--- - 是一个选项--- exit 注销 --- 退出用户/注销 exit rm -rf 123456--- rm -rf 删除 rm --- 删除的命令 (remove) -rf --- 强制删除不给提醒rm -rf /china --- 删除/china目录 --- /china --- 绝对路径 1[root@localhost china]# rm -rf jiangxi/ 删除数据一定要注意，非常不安全 rm -rf * 12rm -rf * rm -rf * 删除当前目录下所有的文件，但是隐藏文件不删除 tree 12345678yum install tree -y --- yum - linux里软件管理的命令 --- install - 安装 --- tree - 安装的具体软件名 --- -y 自动安装，不需要输入yes确认 tree --- 查看目录结构 yum install tree -y tab 1--- 文件路径补齐：tab键 passwd 123// 给用户设置密码 passwd username 默认情况：root用户可以给任何一个用户设置密码 普通用户只能给自己设置密码（root授权除外） 12回文 回文 123321（上海自来水来自海上）从左、右边念一样 w 12// 查看有哪些用户登录在linux系统里 w What ssh 1// ssh ip地址 连接到相同网段 的主机上 Ctrl + L 1// 清屏 Ctrl + L touch 1234// touch 1 .如果文件不存在，新建空文件 2 .如果文件存在，就是更新时间 // touch a.txt 建立文本文件 date 1//更新时间 1// date 查看当前时间 stat 1234// stat 查看文件的状态（详细信息） stat status 状态 文件名、大小、用户、时间 比 ls -l 更加详细的信息 cp 1234// cp 复制（复制的同时会粘贴） copy 将文件复制到文件夹 cp sc.txt hunan 源 目的地 123456// cp -r -r 复制文件夹的时候，需要接的选项 递归复制 ( 将子文件夹也复制过去 ) #注：-r一般表示递归 linux里的操作哲学： 1.没有消息就是好消息 2. 一切皆文件 12// 复制原来有的文件，提示：是否覆盖 空文件夹，不会提醒 是否覆盖 mv 123// mv mv - move (rename) files 1 .移动--》当后面接的文件夹存在就是移动（剪切） move 后面必须是文件夹，不能是文件。 2 .改名字（重命名）--》当后面接的文件夹不存在就是重命名 11.移动 外面就没有这些文件了 12.重命名 du -sh 123#注：查看的是所有文件 汇总的大小，而不是分开的文件// 查看文件夹大小 du -sh -sh 是选项 二. 目录结构 12345Linux目录结构 --- / 根目录 --- /root 家目录 --- /是一个文件夹，/下的root 也是个文件夹 --- Linux目录结构 ==&gt; 文件夹的结构 ==&gt; 倒立的树 ==&gt; 树目录结构 家目录 12345/root 是root用户的家目录 --- root用户是linux超级用户 --- 家目录：用户登录进入Linux系统所在的目录 (home directory)普通用户的家目录在根下面的 home 下面 1--- ~ 所在路径是用户的家目录 文件系统层次结构 1// linux 文件系统层次结构 1234// 危险操作,不能做 rm -rf / rm -rf /* cd / ——》 rm -rf * 三. 提示符 123提示符 --- # root使用的提示符 --- $ 普通用户使用的提示符 四. 进程 1234567// 进程 子进程、父进程 bash 终端交互程序 sshd进程 远程登录 sshd 监听 22号接口 sshd 起的bash bash 接受人输入的东西（人机交互的程序） 内核管操作系统，操作系统最核心的软件 五. 通用命令格式 12345// linux命令的通用命令格式 命令字符 [选项] [参数] // “[ ]” 里的 可接可不接 如：ls -l /home [选项] 和 [参数] 有时候顺序可以颠倒// option 选项： 是可供选项的项目，可接可不接，有特殊作用 六. 隐藏文件 1// . 开头的文件在linux下是隐藏文件 七. * 12// * 是通配符：代表所有的文件// ls -A 显示所有的文件和文件夹，但是不包括 . 和 .. 12// 选项可以组合，一般不分先后顺序 ls -al (常见) ls -a -l 12345// 一般不分先后顺序 [root@localhost ~]# ls -al [root@localhost ~]# ls -la [root@localhost ~]# ls -a -l [root@localhost ~]# ls -l -a 12// 既没有参数，也没有选项，看当前 . 可以没有参数和选项 八. * ? 通配符 12345678// rm -rf 删除 -rf 强制删除 * 代表任意字符 通配符 ? 代表一个字符 通配符-r 递归-f 强制删除，不给予提醒 忽略不存在的文件-f, --force 强制删除。忽略不存在的文件，不提示确认 九. 绝对路径、相对路径 123456789// 相对路径 和 绝对路径 //绝对路径 不考虑你当前的位置，从“/”到达目标文件需要经过的文件系统目录树的所有分支 /home/hello/docs/share 从/开始，一层一层往下走，不能跳跃，而且是绝对不会搞错的路径 //相对路径 参照你当前的位置，到达目标文件需要经过的文件系统目录树的所有分 不以“/”开头 不是以/开头的路径，可进可退 以当前目录作为参照物 1// cd ./hunan（不要这么写） 和 cd hunan 效果一样 十. 123456#注：这些操作也可以↓[root@cPen_centos8 lianxi]# rm -rf &#123;1..50&#125;.txt[root@cPen_centos8 ~]# echo &#123;1..10&#125;1 2 3 4 5 6 7 8 9 10// touch sc&#123;1..100&#125;.txt mkdir hunan&#123;1..100&#125; 1234// rm -rf hunan* 删除上面建的文件 rm -rf sc*.txt 删除上面建的.txt文件// touch sc&#123;1..100&#125;.txt 创建文件 sc1.txt、sc2.txt……sc100.txt cp *.txt beijing 复制文件不需要接 -r 复制这些文件到beijing 文件夹下","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"}]},{"title":"01_Linux基础-部署-VMware-Xshell-Xftp-内核-安迪比尔定理","slug":"Linux_基础/01_Linux基础-部署-VMware-Xshell-Xftp-内核-安迪比尔定理","date":"2022-08-28T04:00:00.000Z","updated":"2022-08-28T05:00:00.000Z","comments":true,"path":"posts/48860.html","permalink":"https://blog1.cpen.top/posts/48860.html","excerpt":"","text":"CentOS开源 免费 — CentOS是Linux里的开源免费版本 一. 配置虚拟机 1. 新建虚拟机 2. 放 镜像文件 1234镜像文件其实就是 系统盘 iso结尾，iso其实就是压缩格式的文件 --- 里面很多文件从虚拟机里出来：按 Ctrl + Alt 总结 12345678注①：root用户不需要创建，默认有，用户名就叫root Linux里的超级用户 root 123456注②：用虚拟机的意思其实和花钱买云服务器一模一样注③：1个CPU核心 对应 4G内存注④：企业服务器用xeon（至强） 二. 云厂商 12345阿里云--- 阿里云国际第四大云服务，主要业务在国内--- 国际上：亚马逊云、Google云、微软云、阿里云--- 带宽在云服务器里面是稀缺资源，越大价格越贵--- 学习时购买一个学生机（阿里云/腾讯云） 三. CPU 123456789cpu的概念 --- 大脑处理器：CPU 中央处理器 （Central Processing Unit） --- 颗：物理的 --- 核心：逻辑的1颗CPU里面有8个核 ==&gt; 1个鸡蛋2个黄 --- 核心越多CPU的处理能力越强，速度越快 --- 个人电脑用酷睿，企业的服务器用至强（xeon） 12345电脑cpu厂家： - Intel 英特尔 美国 Core 酷睿 i3 i5 i7 i9 ==&gt; 个人电脑 Xeon 至强 ==&gt; 服务器使用的CPU - AMD 美国 四. 虚拟机 2G2核 虚拟机2G2C怎么回事？ 1并不是分2个核2G给它，虚拟机跑起来后其实是进程，名字叫VMware .exe 不会消耗1个G，也就几百兆。虚拟机模拟出来的操作系统配置是两个核一个G，虚拟出的虚幻世界，进程并不会消耗一个G两个核，但确实会用电脑里面的cpu。都是模拟出来的，假的。 五. 虚拟机软件 1234部署环境--- 软件：vmware workstation 15 pro--- xshell - windows里连接Linux系统的工具 ==&gt; 远程连接工具--- xftp - windows里和Linux之间传输文件的工具 Xshell 1234登录提示符 (vmware)--- Localhost 代表本机的主机名(默认主机名) ==&gt; local 本地；host 主机(电脑)--- login 登录--- root Linux里的超级用户，默认有 不需要新建 1234--- exit 退出系统 / 注销--- Ctrl + L 清除屏幕--- ip add 查看ip地址 ==&gt; 每台计算机都需要一个ip地址 去上网--- inet ==&gt; Internet 使用步骤 123451. 双击 Xshell2. 未知主机秘钥，点“接受并保存”3. 用户名输入“root”密码输入“123456”，点确定（点记住用户名、密码） 1--- 看到# 显示连接成功 ==&gt; 在Windows里成功连到Linux 12--- 调背景的（ANSI Colors），可以调成白色背景--- 旁边的A logo 可以调字体 六. CentOS 123CentOS --- Community ENTerprise Operating System ==&gt; 社区企业版操作系统Red Hat Enterprise Linux (RHEL) ==&gt; 红帽企业版linux系统 ==&gt; 开源 ==&gt; centosCentOS 山寨的Redhat ==&gt; CentOS被Redhat收购了 内核 12345内核 --- 主要使用 C语言 编写 ==&gt; 开源免费 --- 安卓/centos/redhat/Ubuntu用的Linux内核 --- Linus李纳斯 写出内核，还写了GIT 版本控制软件 --- 内核相当于汽车的发动机 123kernel内核 --- 内核：Linux系统内部最核心的软件 --- http://www.kernel.org/ ==&gt; organization 组织 内核作用 123456内核的作用： - 1.对CPU进行调度管理 - 2.对内存进行分配管理 - 3.对磁盘进行管理 - 4.对进程进行管理 - 5.其他硬件 (网卡、声卡、显卡等) 七. Linux 与 Windows 区别 12Linux和windows的区别： --- Linux开源 12345678910# root @ CentOS in ~ [13:51:11]$ uname -r4.18.0-193.14.2.el8_2.x86_64# 解释 --- el8 ==&gt; Enterprise Linux 8 --- x86_64 ==&gt; 系统64位 - 64位 CPU一次性处理数据的大小 - 1字节 = 8位 - CPU带领操作系统的发展 八. 安迪比尔定理 12安迪比尔定理 --- CPU带领操作系统的发展 ==&gt; 硬件与软件，现在手机行业 1安迪-比尔定理 （Andy and Bill’s Law）是对IT产业中软件和硬件升级换代关系的一个概括。原话是 “Andy gives, Bill takes away.（安迪提供什么，比尔拿走什么。）” 安迪指英特尔前CEO安迪·格鲁夫，比尔指微软前任CEO比尔·盖茨，这句话的意思是，硬件提高的性能，很快被软件消耗掉了。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"}]}],"categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/categories/Hexo/"},{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/categories/Other/"},{"name":"Error","slug":"Error","permalink":"https://blog1.cpen.top/categories/Error/"},{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/categories/Linux/"},{"name":"PHP","slug":"PHP","permalink":"https://blog1.cpen.top/categories/PHP/"},{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/categories/Python/"},{"name":"Django","slug":"Django","permalink":"https://blog1.cpen.top/categories/Django/"},{"name":"Java","slug":"Java","permalink":"https://blog1.cpen.top/categories/Java/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog1.cpen.top/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://blog1.cpen.top/tags/GitHub/"},{"name":"NPM","slug":"NPM","permalink":"https://blog1.cpen.top/tags/NPM/"},{"name":"转载","slug":"转载","permalink":"https://blog1.cpen.top/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"习惯","slug":"习惯","permalink":"https://blog1.cpen.top/tags/%E4%B9%A0%E6%83%AF/"},{"name":"学习","slug":"学习","permalink":"https://blog1.cpen.top/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Python","slug":"Python","permalink":"https://blog1.cpen.top/tags/Python/"},{"name":"Other","slug":"Other","permalink":"https://blog1.cpen.top/tags/Other/"},{"name":"FTP","slug":"FTP","permalink":"https://blog1.cpen.top/tags/FTP/"},{"name":"Git","slug":"Git","permalink":"https://blog1.cpen.top/tags/Git/"},{"name":"SSH","slug":"SSH","permalink":"https://blog1.cpen.top/tags/SSH/"},{"name":"Error","slug":"Error","permalink":"https://blog1.cpen.top/tags/Error/"},{"name":"Replit","slug":"Replit","permalink":"https://blog1.cpen.top/tags/Replit/"},{"name":"Memos","slug":"Memos","permalink":"https://blog1.cpen.top/tags/Memos/"},{"name":"字体","slug":"字体","permalink":"https://blog1.cpen.top/tags/%E5%AD%97%E4%BD%93/"},{"name":"插件","slug":"插件","permalink":"https://blog1.cpen.top/tags/%E6%8F%92%E4%BB%B6/"},{"name":"TinyPNG","slug":"TinyPNG","permalink":"https://blog1.cpen.top/tags/TinyPNG/"},{"name":"图床","slug":"图床","permalink":"https://blog1.cpen.top/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Open","slug":"Open","permalink":"https://blog1.cpen.top/tags/Open/"},{"name":"工具","slug":"工具","permalink":"https://blog1.cpen.top/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Element","slug":"Element","permalink":"https://blog1.cpen.top/tags/Element/"},{"name":"Twikoo","slug":"Twikoo","permalink":"https://blog1.cpen.top/tags/Twikoo/"},{"name":"PJAX","slug":"PJAX","permalink":"https://blog1.cpen.top/tags/PJAX/"},{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://blog1.cpen.top/tags/Troubleshooting/"},{"name":"AList","slug":"AList","permalink":"https://blog1.cpen.top/tags/AList/"},{"name":"Linux","slug":"Linux","permalink":"https://blog1.cpen.top/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://blog1.cpen.top/tags/Shell/"},{"name":"Sed","slug":"Sed","permalink":"https://blog1.cpen.top/tags/Sed/"},{"name":"Awk","slug":"Awk","permalink":"https://blog1.cpen.top/tags/Awk/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog1.cpen.top/tags/Nginx/"},{"name":"NFS","slug":"NFS","permalink":"https://blog1.cpen.top/tags/NFS/"},{"name":"DNS","slug":"DNS","permalink":"https://blog1.cpen.top/tags/DNS/"},{"name":"Ansible","slug":"Ansible","permalink":"https://blog1.cpen.top/tags/Ansible/"},{"name":"Supervisor","slug":"Supervisor","permalink":"https://blog1.cpen.top/tags/Supervisor/"},{"name":"PHP","slug":"PHP","permalink":"https://blog1.cpen.top/tags/PHP/"},{"name":"脚本","slug":"脚本","permalink":"https://blog1.cpen.top/tags/%E8%84%9A%E6%9C%AC/"},{"name":"内存管理","slug":"内存管理","permalink":"https://blog1.cpen.top/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"上下文管理器","slug":"上下文管理器","permalink":"https://blog1.cpen.top/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"},{"name":"OOP","slug":"OOP","permalink":"https://blog1.cpen.top/tags/OOP/"},{"name":"函数","slug":"函数","permalink":"https://blog1.cpen.top/tags/%E5%87%BD%E6%95%B0/"},{"name":"模块","slug":"模块","permalink":"https://blog1.cpen.top/tags/%E6%A8%A1%E5%9D%97/"},{"name":"Psutil","slug":"Psutil","permalink":"https://blog1.cpen.top/tags/Psutil/"},{"name":"算法","slug":"算法","permalink":"https://blog1.cpen.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"Mail","slug":"Mail","permalink":"https://blog1.cpen.top/tags/Mail/"},{"name":"数据类型","slug":"数据类型","permalink":"https://blog1.cpen.top/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"环境","slug":"环境","permalink":"https://blog1.cpen.top/tags/%E7%8E%AF%E5%A2%83/"},{"name":"Django","slug":"Django","permalink":"https://blog1.cpen.top/tags/Django/"},{"name":"URL","slug":"URL","permalink":"https://blog1.cpen.top/tags/URL/"},{"name":"MTV","slug":"MTV","permalink":"https://blog1.cpen.top/tags/MTV/"},{"name":"HTTP","slug":"HTTP","permalink":"https://blog1.cpen.top/tags/HTTP/"},{"name":"GET","slug":"GET","permalink":"https://blog1.cpen.top/tags/GET/"},{"name":"POST","slug":"POST","permalink":"https://blog1.cpen.top/tags/POST/"},{"name":"MVC","slug":"MVC","permalink":"https://blog1.cpen.top/tags/MVC/"},{"name":"状态码","slug":"状态码","permalink":"https://blog1.cpen.top/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"},{"name":"Java","slug":"Java","permalink":"https://blog1.cpen.top/tags/Java/"},{"name":"运算符","slug":"运算符","permalink":"https://blog1.cpen.top/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"进制","slug":"进制","permalink":"https://blog1.cpen.top/tags/%E8%BF%9B%E5%88%B6/"},{"name":"编码","slug":"编码","permalink":"https://blog1.cpen.top/tags/%E7%BC%96%E7%A0%81/"},{"name":"Pure","slug":"Pure","permalink":"https://blog1.cpen.top/tags/Pure/"},{"name":"权限","slug":"权限","permalink":"https://blog1.cpen.top/tags/%E6%9D%83%E9%99%90/"},{"name":"用户与组","slug":"用户与组","permalink":"https://blog1.cpen.top/tags/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84/"},{"name":"Vim","slug":"Vim","permalink":"https://blog1.cpen.top/tags/Vim/"},{"name":"Crontab","slug":"Crontab","permalink":"https://blog1.cpen.top/tags/Crontab/"}]}